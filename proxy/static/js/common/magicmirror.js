(function (exports) {
  'use strict';

  const beforeExpr = true;
  const startsExpr = true;
  const isLoop = true;
  const isAssign = true;
  const prefix = true;
  const postfix = true;

  class TokenType {
    constructor(label, conf = {}) {
      this.label = void 0;
      this.keyword = void 0;
      this.beforeExpr = void 0;
      this.startsExpr = void 0;
      this.rightAssociative = void 0;
      this.isLoop = void 0;
      this.isAssign = void 0;
      this.prefix = void 0;
      this.postfix = void 0;
      this.binop = void 0;
      this.updateContext = void 0;
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
      this.updateContext = null;
    }
  }

  const keywords = new Map();

  function createKeyword(name, options = {}) {
    options.keyword = name;
    const token = new TokenType(name, options);
    keywords.set(name, token);
    return token;
  }

  function createBinop(name, binop) {
    return new TokenType(name, {
      beforeExpr,
      binop,
    });
  }

  const types = {
    num: new TokenType('num', {
      startsExpr,
    }),
    bigint: new TokenType('bigint', {
      startsExpr,
    }),
    decimal: new TokenType('decimal', {
      startsExpr,
    }),
    regexp: new TokenType('regexp', {
      startsExpr,
    }),
    string: new TokenType('string', {
      startsExpr,
    }),
    name: new TokenType('name', {
      startsExpr,
    }),
    eof: new TokenType('eof'),
    bracketL: new TokenType('[', {
      beforeExpr,
      startsExpr,
    }),
    bracketHashL: new TokenType('#[', {
      beforeExpr,
      startsExpr,
    }),
    bracketBarL: new TokenType('[|', {
      beforeExpr,
      startsExpr,
    }),
    bracketR: new TokenType(']'),
    bracketBarR: new TokenType('|]'),
    braceL: new TokenType('{', {
      beforeExpr,
      startsExpr,
    }),
    braceBarL: new TokenType('{|', {
      beforeExpr,
      startsExpr,
    }),
    braceHashL: new TokenType('#{', {
      beforeExpr,
      startsExpr,
    }),
    braceR: new TokenType('}'),
    braceBarR: new TokenType('|}'),
    parenL: new TokenType('(', {
      beforeExpr,
      startsExpr,
    }),
    parenR: new TokenType(')'),
    comma: new TokenType(',', {
      beforeExpr,
    }),
    semi: new TokenType(';', {
      beforeExpr,
    }),
    colon: new TokenType(':', {
      beforeExpr,
    }),
    doubleColon: new TokenType('::', {
      beforeExpr,
    }),
    dot: new TokenType('.'),
    question: new TokenType('?', {
      beforeExpr,
    }),
    questionDot: new TokenType('?.'),
    arrow: new TokenType('=>', {
      beforeExpr,
    }),
    template: new TokenType('template'),
    ellipsis: new TokenType('...', {
      beforeExpr,
    }),
    backQuote: new TokenType('`', {
      startsExpr,
    }),
    dollarBraceL: new TokenType('${', {
      beforeExpr,
      startsExpr,
    }),
    at: new TokenType('@'),
    hash: new TokenType('#', {
      startsExpr,
    }),
    interpreterDirective: new TokenType('#!...'),
    eq: new TokenType('=', {
      beforeExpr,
      isAssign,
    }),
    assign: new TokenType('_=', {
      beforeExpr,
      isAssign,
    }),
    incDec: new TokenType('++/--', {
      prefix,
      postfix,
      startsExpr,
    }),
    bang: new TokenType('!', {
      beforeExpr,
      prefix,
      startsExpr,
    }),
    tilde: new TokenType('~', {
      beforeExpr,
      prefix,
      startsExpr,
    }),
    pipeline: createBinop('|>', 0),
    nullishCoalescing: createBinop('??', 1),
    logicalOR: createBinop('||', 1),
    logicalAND: createBinop('&&', 2),
    bitwiseOR: createBinop('|', 3),
    bitwiseXOR: createBinop('^', 4),
    bitwiseAND: createBinop('&', 5),
    equality: createBinop('==/!=/===/!==', 6),
    relational: createBinop('</>/<=/>=', 7),
    bitShift: createBinop('<</>>/>>>', 8),
    plusMin: new TokenType('+/-', {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr,
    }),
    modulo: new TokenType('%', {
      beforeExpr,
      binop: 10,
      startsExpr,
    }),
    star: new TokenType('*', {
      binop: 10,
    }),
    slash: createBinop('/', 10),
    exponent: new TokenType('**', {
      beforeExpr,
      binop: 11,
      rightAssociative: true,
    }),
    _break: createKeyword('break'),
    _case: createKeyword('case', {
      beforeExpr,
    }),
    _catch: createKeyword('catch'),
    _continue: createKeyword('continue'),
    _debugger: createKeyword('debugger'),
    _default: createKeyword('default', {
      beforeExpr,
    }),
    _do: createKeyword('do', {
      isLoop,
      beforeExpr,
    }),
    _else: createKeyword('else', {
      beforeExpr,
    }),
    _finally: createKeyword('finally'),
    _for: createKeyword('for', {
      isLoop,
    }),
    _function: createKeyword('function', {
      startsExpr,
    }),
    _if: createKeyword('if'),
    _return: createKeyword('return', {
      beforeExpr,
    }),
    _switch: createKeyword('switch'),
    _throw: createKeyword('throw', {
      beforeExpr,
      prefix,
      startsExpr,
    }),
    _try: createKeyword('try'),
    _var: createKeyword('var'),
    _const: createKeyword('const'),
    _while: createKeyword('while', {
      isLoop,
    }),
    _with: createKeyword('with'),
    _new: createKeyword('new', {
      beforeExpr,
      startsExpr,
    }),
    _this: createKeyword('this', {
      startsExpr,
    }),
    _super: createKeyword('super', {
      startsExpr,
    }),
    _class: createKeyword('class', {
      startsExpr,
    }),
    _extends: createKeyword('extends', {
      beforeExpr,
    }),
    _export: createKeyword('export'),
    _import: createKeyword('import', {
      startsExpr,
    }),
    _null: createKeyword('null', {
      startsExpr,
    }),
    _true: createKeyword('true', {
      startsExpr,
    }),
    _false: createKeyword('false', {
      startsExpr,
    }),
    _in: createKeyword('in', {
      beforeExpr,
      binop: 7,
    }),
    _instanceof: createKeyword('instanceof', {
      beforeExpr,
      binop: 7,
    }),
    _typeof: createKeyword('typeof', {
      beforeExpr,
      prefix,
      startsExpr,
    }),
    _void: createKeyword('void', {
      beforeExpr,
      prefix,
      startsExpr,
    }),
    _delete: createKeyword('delete', {
      beforeExpr,
      prefix,
      startsExpr,
    }),
  };
  const lineBreak = /\r\n?|[\n\u2028\u2029]/;
  const lineBreakG = new RegExp(lineBreak.source, 'g');

  function isNewLine(code) {
    switch (code) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;

      default:
        return false;
    }
  }

  const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  function isWhitespace(code) {
    switch (code) {
      case 0x0009:
      case 0x000b:
      case 0x000c:
      case 32:
      case 160:
      case 5760:
      case 0x2000:
      case 0x2001:
      case 0x2002:
      case 0x2003:
      case 0x2004:
      case 0x2005:
      case 0x2006:
      case 0x2007:
      case 0x2008:
      case 0x2009:
      case 0x200a:
      case 0x202f:
      case 0x205f:
      case 0x3000:
      case 0xfeff:
        return true;

      default:
        return false;
    }
  }

  class Position {
    constructor(line, col) {
      this.line = void 0;
      this.column = void 0;
      this.line = line;
      this.column = col;
    }
  }

  class SourceLocation {
    constructor(start, end) {
      this.start = void 0;
      this.end = void 0;
      this.filename = void 0;
      this.identifierName = void 0;
      this.start = start;
      this.end = end;
    }
  }

  function getLineInfo(input, offset) {
    let line = 1;
    let lineStart = 0;
    let match;
    lineBreakG.lastIndex = 0;

    while ((match = lineBreakG.exec(input)) && match.index < offset) {
      line++;
      lineStart = lineBreakG.lastIndex;
    }

    return new Position(line, offset - lineStart);
  }

  class BaseParser {
    constructor() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }

    hasPlugin(name) {
      return this.plugins.has(name);
    }

    getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    }
  }

  function last(stack) {
    return stack[stack.length - 1];
  }

  class CommentsParser extends BaseParser {
    addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    }

    adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (this.state.leadingComments.length === 0) {
        return;
      }

      let lastElement = null;
      let i = elements.length;

      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }

      if (lastElement === null) {
        return;
      }

      for (let j = 0; j < this.state.leadingComments.length; j++) {
        if (
          this.state.leadingComments[j].end < this.state.commentPreviousNode.end
        ) {
          this.state.leadingComments.splice(j, 1);
          j--;
        }
      }

      const newTrailingComments = [];

      for (let i = 0; i < this.state.leadingComments.length; i++) {
        const leadingComment = this.state.leadingComments[i];

        if (leadingComment.end < node.end) {
          newTrailingComments.push(leadingComment);

          if (!takeAllComments) {
            this.state.leadingComments.splice(i, 1);
            i--;
          }
        } else {
          if (node.trailingComments === undefined) {
            node.trailingComments = [];
          }

          node.trailingComments.push(leadingComment);
        }
      }

      if (takeAllComments) this.state.leadingComments = [];

      if (newTrailingComments.length > 0) {
        lastElement.trailingComments = newTrailingComments;
      } else if (lastElement.trailingComments !== undefined) {
        lastElement.trailingComments = [];
      }
    }

    processComment(node) {
      if (node.type === 'Program' && node.body.length > 0) return;
      const stack = this.state.commentStack;
      let firstChild, lastChild, trailingComments, i, j;

      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else if (stack.length > 0) {
        const lastInStack = last(stack);

        if (
          lastInStack.trailingComments &&
          lastInStack.trailingComments[0].start >= node.end
        ) {
          trailingComments = lastInStack.trailingComments;
          delete lastInStack.trailingComments;
        }
      }

      if (stack.length > 0 && last(stack).start >= node.start) {
        firstChild = stack.pop();
      }

      while (stack.length > 0 && last(stack).start >= node.start) {
        lastChild = stack.pop();
      }

      if (!lastChild && firstChild) lastChild = firstChild;

      if (firstChild) {
        switch (node.type) {
          case 'ObjectExpression':
            this.adjustCommentsAfterTrailingComma(node, node.properties);
            break;

          case 'ObjectPattern':
            this.adjustCommentsAfterTrailingComma(node, node.properties, true);
            break;

          case 'CallExpression':
            this.adjustCommentsAfterTrailingComma(node, node.arguments);
            break;

          case 'ArrayExpression':
            this.adjustCommentsAfterTrailingComma(node, node.elements);
            break;

          case 'ArrayPattern':
            this.adjustCommentsAfterTrailingComma(node, node.elements, true);
            break;
        }
      } else if (
        this.state.commentPreviousNode &&
        ((this.state.commentPreviousNode.type === 'ImportSpecifier' &&
          node.type !== 'ImportSpecifier') ||
          (this.state.commentPreviousNode.type === 'ExportSpecifier' &&
            node.type !== 'ExportSpecifier'))
      ) {
        this.adjustCommentsAfterTrailingComma(node, [
          this.state.commentPreviousNode,
        ]);
      }

      if (lastChild) {
        if (lastChild.leadingComments) {
          if (
            lastChild !== node &&
            lastChild.leadingComments.length > 0 &&
            last(lastChild.leadingComments).end <= node.start
          ) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(
                  0,
                  i + 1,
                );
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (
                this.state.leadingComments[j].end <
                this.state.commentPreviousNode.end
              ) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }

          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }

          const leadingComments = this.state.leadingComments.slice(0, i);

          if (leadingComments.length) {
            node.leadingComments = leadingComments;
          }

          trailingComments = this.state.leadingComments.slice(i);

          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }

      this.state.commentPreviousNode = node;

      if (trailingComments) {
        if (
          trailingComments.length &&
          trailingComments[0].start >= node.start &&
          last(trailingComments).end <= node.end
        ) {
          node.innerComments = trailingComments;
        } else {
          const firstTrailingCommentIndex = trailingComments.findIndex(
            (comment) => comment.end >= node.end,
          );

          if (firstTrailingCommentIndex > 0) {
            node.innerComments = trailingComments.slice(
              0,
              firstTrailingCommentIndex,
            );
            node.trailingComments = trailingComments.slice(
              firstTrailingCommentIndex,
            );
          } else {
            node.trailingComments = trailingComments;
          }
        }
      }

      stack.push(node);
    }
  }

  const ErrorMessages = Object.freeze({
    AccessorIsGenerator: 'A %0ter cannot be a generator',
    ArgumentsInClass:
      "'arguments' is only allowed in functions and class methods",
    AsyncFunctionInSingleStatementContext:
      'Async functions can only be declared at the top level or inside a block',
    AwaitBindingIdentifier:
      "Can not use 'await' as identifier inside an async function",
    AwaitBindingIdentifierInStaticBlock:
      "Can not use 'await' as identifier inside a static block",
    AwaitExpressionFormalParameter:
      'await is not allowed in async function parameters',
    AwaitNotInAsyncContext:
      "'await' is only allowed within async functions and at the top levels of modules",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions",
    BadGetterArity: 'getter must not have any formal parameters',
    BadSetterArity: 'setter must have exactly one formal parameter',
    BadSetterRestParameter:
      'setter function argument must not be a rest parameter',
    ConstructorClassField: "Classes may not have a field named 'constructor'",
    ConstructorClassPrivateField:
      "Classes may not have a private field named '#constructor'",
    ConstructorIsAccessor: 'Class constructor may not be an accessor',
    ConstructorIsAsync: "Constructor can't be an async function",
    ConstructorIsGenerator: "Constructor can't be a generator",
    DeclarationMissingInitializer: '%0 require an initialization value',
    DecoratorBeforeExport:
      "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
    DecoratorConstructor:
      "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass:
      'Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.',
    DecoratorSemicolon: 'Decorators must not be followed by a semicolon',
    DecoratorStaticBlock: "Decorators can't be used with a static block",
    DeletePrivateField: 'Deleting a private field is not allowed',
    DestructureNamedImport:
      'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
    DuplicateConstructor: 'Duplicate constructor in the same class',
    DuplicateDefaultExport: 'Only one default export allowed per module.',
    DuplicateExport:
      '`%0` has already been exported. Exported identifiers must be unique.',
    DuplicateProto: 'Redefinition of __proto__ property',
    DuplicateRegExpFlags: 'Duplicate regular expression flag',
    ElementAfterRest: 'Rest element must be last element',
    EscapedCharNotAnIdentifier: 'Invalid Unicode escape',
    ExportBindingIsString:
      "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
    ExportDefaultFromAsIdentifier:
      "'from' is not allowed as an identifier after 'export default'",
    ForInOfLoopInitializer:
      '%0 loop variable declaration may not have an initializer',
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext:
      'Generators can only be declared at the top level or inside a block',
    IllegalBreakContinue: 'Unsyntactic %0',
    IllegalLanguageModeDirective:
      "Illegal 'use strict' directive in function with non-simple parameter list",
    IllegalReturn: "'return' outside of function",
    ImportBindingIsString:
      'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
    ImportCallArgumentTrailingComma:
      'Trailing comma is disallowed inside import(...) arguments',
    ImportCallArity: 'import() requires exactly %0',
    ImportCallNotNewExpression: 'Cannot use new with import(...)',
    ImportCallSpreadArgument: '... is not allowed in import()',
    ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
    ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    InvalidBigIntLiteral: 'Invalid BigIntLiteral',
    InvalidCodePoint: 'Code point out of bounds',
    InvalidDecimal: 'Invalid decimal',
    InvalidDigit: 'Expected number in radix %0',
    InvalidEscapeSequence: 'Bad character escape sequence',
    InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template',
    InvalidEscapedReservedWord: 'Escape sequence in keyword %0',
    InvalidIdentifier: 'Invalid identifier %0',
    InvalidLhs: 'Invalid left-hand side in %0',
    InvalidLhsBinding: 'Binding invalid left-hand side in %0',
    InvalidNumber: 'Invalid number',
    InvalidOrMissingExponent:
      "Floating-point numbers require a valid exponent after the 'e'",
    InvalidOrUnexpectedToken: "Unexpected character '%0'",
    InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern',
    InvalidPrivateFieldResolution: 'Private name #%0 is not defined',
    InvalidPropertyBindingPattern: 'Binding member expression',
    InvalidRecordProperty:
      'Only properties and spread elements are allowed in record definitions',
    InvalidRestAssignmentPattern: "Invalid rest operator's argument",
    LabelRedeclaration: "Label '%0' is already declared",
    LetInLexicalBinding:
      "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'",
    MalformedRegExpFlags: 'Invalid regular expression flag',
    MissingClassName: 'A class name is required',
    MissingEqInAssignment:
      "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: 'Missing semicolon',
    MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX',
    MixingCoalesceWithLogical:
      'Nullish coalescing operator(??) requires parens when mixing with logical operators',
    ModuleAttributeDifferentFromType:
      'The only accepted module attribute is `type`',
    ModuleAttributeInvalidValue:
      'Only string literals are allowed as module attribute values',
    ModuleAttributesWithDuplicateKeys:
      'Duplicate key "%0" is not allowed in module attributes',
    ModuleExportNameHasLoneSurrogate:
      "An export name cannot include a lone surrogate, found '\\u%0'",
    ModuleExportUndefined: "Export '%0' is not defined",
    MultipleDefaultsInSwitch: 'Multiple default clauses',
    NewlineAfterThrow: 'Illegal newline after throw',
    NoCatchOrFinally: 'Missing catch or finally clause',
    NumberIdentifier: 'Identifier directly after number',
    NumericSeparatorInEscapeSequence:
      'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences',
    ObsoleteAwaitStar:
      'await* has been removed from the async functions proposal. Use Promise.all() instead.',
    OptionalChainingNoNew:
      'constructors in/after an Optional Chain are not allowed',
    OptionalChainingNoTemplate:
      'Tagged Template Literals are not allowed in optionalChain',
    ParamDupe: 'Argument name clash',
    PatternHasAccessor: "Object pattern can't contain getter or setter",
    PatternHasMethod: "Object pattern can't contain methods",
    PipelineBodyNoArrow:
      'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
    PipelineBodySequenceExpression:
      'Pipeline body may not be a comma-separated sequence expression',
    PipelineHeadSequenceExpression:
      'Pipeline head should not be a comma-separated sequence expression',
    PipelineTopicUnused:
      'Pipeline is in topic style but does not use topic reference',
    PrimaryTopicNotAllowed:
      'Topic reference was used in a lexical context without topic binding',
    PrimaryTopicRequiresSmartPipeline:
      "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
    PrivateInExpectedIn:
      'Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)',
    PrivateNameRedeclaration: 'Duplicate private name #%0',
    RecordExpressionBarIncorrectEndSyntaxType:
      "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionBarIncorrectStartSyntaxType:
      "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionHashIncorrectStartSyntaxType:
      "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    RecordNoProto: "'__proto__' is not allowed in Record expressions",
    RestTrailingComma: 'Unexpected trailing comma after rest element',
    SloppyFunction:
      'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement',
    StaticPrototype: 'Classes may not have static property named prototype',
    StrictDelete: 'Deleting local variable in strict mode',
    StrictEvalArguments: "Assigning to '%0' in strict mode",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
    StrictFunction:
      'In strict mode code, functions can only be declared at top level or inside a block',
    StrictNumericEscape:
      "The only valid numeric escape in strict mode is '\\0'",
    StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode',
    StrictWith: "'with' in strict mode",
    SuperNotAllowed:
      "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super",
    TrailingDecorator: 'Decorators must be attached to a class element',
    TupleExpressionBarIncorrectEndSyntaxType:
      "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionBarIncorrectStartSyntaxType:
      "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionHashIncorrectStartSyntaxType:
      "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder',
    UnexpectedAwaitAfterPipelineBody:
      'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
    UnexpectedDigitAfterHash: 'Unexpected digit after hash token',
    UnexpectedImportExport:
      "'import' and 'export' may only appear at the top level",
    UnexpectedKeyword: "Unexpected keyword '%0'",
    UnexpectedLeadingDecorator:
      'Leading decorators must be attached to a class declaration',
    UnexpectedLexicalDeclaration:
      'Lexical declaration cannot appear in a single-statement context',
    UnexpectedNewTarget: 'new.target can only be used in functions',
    UnexpectedNumericSeparator:
      'A numeric separator is only allowed between two digits',
    UnexpectedPrivateField:
      'Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).',
    UnexpectedReservedWord: "Unexpected reserved word '%0'",
    UnexpectedSuper: 'super is only allowed in object methods and classes',
    UnexpectedToken: "Unexpected token '%0'",
    UnexpectedTokenUnaryExponentiation:
      'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
    UnsupportedBind: 'Binding should be performed on object property.',
    UnsupportedDecoratorExport:
      'A decorated export must export a class declaration',
    UnsupportedDefaultExport:
      'Only expressions, functions or classes are allowed as the `default` export.',
    UnsupportedImport: 'import can only be used in import() or import.meta',
    UnsupportedMetaProperty: 'The only valid meta property for %0 is %0.%1',
    UnsupportedParameterDecorator:
      'Decorators cannot be used to decorate parameters',
    UnsupportedPropertyDecorator:
      'Decorators cannot be used to decorate object literal properties',
    UnsupportedSuper:
      'super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])',
    UnterminatedComment: 'Unterminated comment',
    UnterminatedRegExp: 'Unterminated regular expression',
    UnterminatedString: 'Unterminated string constant',
    UnterminatedTemplate: 'Unterminated template',
    VarRedeclaration: "Identifier '%0' has already been declared",
    YieldBindingIdentifier:
      "Can not use 'yield' as identifier inside a generator",
    YieldInParameter: 'Yield expression is not allowed in formal parameters',
    ZeroDigitNumericSeparator:
      'Numeric separator can not be used after leading 0',
  });

  class ParserError extends CommentsParser {
    getLocationForPosition(pos) {
      let loc;
      if (pos === this.state.start) loc = this.state.startLoc;
      else if (pos === this.state.lastTokStart)
        loc = this.state.lastTokStartLoc;
      else if (pos === this.state.end) loc = this.state.endLoc;
      else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;
      else loc = getLineInfo(this.input, pos);
      return loc;
    }

    raise(pos, errorTemplate, ...params) {
      return this.raiseWithData(pos, undefined, errorTemplate, ...params);
    }

    raiseOverwrite(pos, errorTemplate, ...params) {
      const loc = this.getLocationForPosition(pos);
      const message =
        errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) +
        ` (${loc.line}:${loc.column})`;

      if (this.options.errorRecovery) {
        const errors = this.state.errors;

        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];

          if (error.pos === pos) {
            return Object.assign(error, {
              message,
            });
          } else if (error.pos < pos) {
            break;
          }
        }
      }

      return this._raise(
        {
          loc,
          pos,
        },
        message,
      );
    }

    raiseWithData(pos, data, errorTemplate, ...params) {
      const loc = this.getLocationForPosition(pos);
      const message =
        errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) +
        ` (${loc.line}:${loc.column})`;
      return this._raise(
        Object.assign(
          {
            loc,
            pos,
          },
          data,
        ),
        message,
      );
    }

    _raise(errorContext, message) {
      const err = new SyntaxError(message);
      Object.assign(err, errorContext);

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    }
  }

  var estree = (superClass) =>
    class extends superClass {
      estreeParseRegExpLiteral({pattern, flags}) {
        let regex = null;

        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {}

        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags,
        };
        return node;
      }

      estreeParseBigIntLiteral(value) {
        let bigInt;

        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }

        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }

      estreeParseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }

      estreeParseLiteral(value) {
        return this.parseLiteral(value, 'Literal');
      }

      directiveToStmt(directive) {
        const directiveLiteral = directive.value;
        const stmt = this.startNodeAt(directive.start, directive.loc.start);
        const expression = this.startNodeAt(
          directiveLiteral.start,
          directiveLiteral.loc.start,
        );
        expression.value = directiveLiteral.extra.expressionValue;
        expression.raw = directiveLiteral.extra.raw;
        stmt.expression = this.finishNodeAt(
          expression,
          'Literal',
          directiveLiteral.end,
          directiveLiteral.loc.end,
        );
        stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
        return this.finishNodeAt(
          stmt,
          'ExpressionStatement',
          directive.end,
          directive.loc.end,
        );
      }

      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }

      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }

      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }

      isValidDirective(stmt) {
        var _stmt$expression$extr;

        return (
          stmt.type === 'ExpressionStatement' &&
          stmt.expression.type === 'Literal' &&
          typeof stmt.expression.value === 'string' &&
          !(
            (_stmt$expression$extr = stmt.expression.extra) != null &&
            _stmt$expression$extr.parenthesized
          )
        );
      }

      stmtToDirective(stmt) {
        const directive = super.stmtToDirective(stmt);
        const value = stmt.expression.value;
        this.addExtra(directive.value, 'expressionValue', value);
        return directive;
      }

      parseBlockBody(node, ...args) {
        super.parseBlockBody(node, ...args);
        const directiveStatements = node.directives.map((d) =>
          this.directiveToStmt(d),
        );
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }

      pushClassMethod(
        classBody,
        method,
        isGenerator,
        isAsync,
        isConstructor,
        allowsDirectSuper,
      ) {
        this.parseMethod(
          method,
          isGenerator,
          isAsync,
          isConstructor,
          allowsDirectSuper,
          'ClassMethod',
          true,
        );

        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }

        classBody.body.push(method);
      }

      parseExprAtom(refExpressionErrors) {
        switch (this.state.type) {
          case types.num:
          case types.string:
            return this.estreeParseLiteral(this.state.value);

          case types.regexp:
            return this.estreeParseRegExpLiteral(this.state.value);

          case types.bigint:
            return this.estreeParseBigIntLiteral(this.state.value);

          case types.decimal:
            return this.estreeParseDecimalLiteral(this.state.value);

          case types._null:
            return this.estreeParseLiteral(null);

          case types._true:
            return this.estreeParseLiteral(true);

          case types._false:
            return this.estreeParseLiteral(false);

          default:
            return super.parseExprAtom(refExpressionErrors);
        }
      }

      parseMaybePrivateName(...args) {
        const node = super.parseMaybePrivateName(...args);

        if (
          node.type === 'PrivateName' &&
          this.getPluginOption('estree', 'classFeatures')
        ) {
          return this.convertPrivateNameToPrivateIdentifier(node);
        }

        return node;
      }

      convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name;
        node.type = 'PrivateIdentifier';
        return node;
      }

      isPrivateName(node) {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return super.isPrivateName(node);
        }

        return node.type === 'PrivateIdentifier';
      }

      getPrivateNameSV(node) {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return super.getPrivateNameSV(node);
        }

        return node.name;
      }

      parseLiteral(value, type, startPos, startLoc) {
        const node = super.parseLiteral(value, type, startPos, startLoc);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }

      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== 'BlockStatement';
      }

      parseMethod(
        node,
        isGenerator,
        isAsync,
        isConstructor,
        allowDirectSuper,
        type,
        inClassScope = false,
      ) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(
          funcNode,
          isGenerator,
          isAsync,
          isConstructor,
          allowDirectSuper,
          type,
          inClassScope,
        );
        funcNode.type = 'FunctionExpression';
        delete funcNode.kind;
        node.value = funcNode;

        if (type === 'ClassPrivateMethod') {
          node.computed = false;
        }

        type = 'MethodDefinition';
        return this.finishNode(node, type);
      }

      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);

        if (this.getPluginOption('estree', 'classFeatures')) {
          propertyNode.type = 'PropertyDefinition';
        }

        return propertyNode;
      }

      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);

        if (this.getPluginOption('estree', 'classFeatures')) {
          propertyNode.type = 'PropertyDefinition';
          propertyNode.computed = false;
        }

        return propertyNode;
      }

      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node = super.parseObjectMethod(
          prop,
          isGenerator,
          isAsync,
          isPattern,
          isAccessor,
        );

        if (node) {
          node.type = 'Property';
          if (node.kind === 'method') node.kind = 'init';
          node.shorthand = false;
        }

        return node;
      }

      parseObjectProperty(
        prop,
        startPos,
        startLoc,
        isPattern,
        refExpressionErrors,
      ) {
        const node = super.parseObjectProperty(
          prop,
          startPos,
          startLoc,
          isPattern,
          refExpressionErrors,
        );

        if (node) {
          node.kind = 'init';
          node.type = 'Property';
        }

        return node;
      }

      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          this.toAssignable(node.value, isLHS);
          return node;
        }

        return super.toAssignable(node, isLHS);
      }

      toAssignableObjectExpressionProp(prop, ...args) {
        if (prop.kind === 'get' || prop.kind === 'set') {
          this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
        } else if (prop.method) {
          this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
        } else {
          super.toAssignableObjectExpressionProp(prop, ...args);
        }
      }

      finishCallExpression(node, optional) {
        super.finishCallExpression(node, optional);

        if (node.callee.type === 'Import') {
          node.type = 'ImportExpression';
          node.source = node.arguments[0];
          delete node.arguments;
          delete node.callee;
        }

        return node;
      }

      toReferencedArguments(node) {
        if (node.type === 'ImportExpression') {
          return;
        }

        super.toReferencedArguments(node);
      }

      parseExport(node) {
        super.parseExport(node);

        switch (node.type) {
          case 'ExportAllDeclaration':
            node.exported = null;
            break;

          case 'ExportNamedDeclaration':
            if (
              node.specifiers.length === 1 &&
              node.specifiers[0].type === 'ExportNamespaceSpecifier'
            ) {
              node.type = 'ExportAllDeclaration';
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }

            break;
        }

        return node;
      }

      parseSubscript(base, startPos, startLoc, noCalls, state) {
        const node = super.parseSubscript(
          base,
          startPos,
          startLoc,
          noCalls,
          state,
        );

        if (state.optionalChainMember) {
          if (
            node.type === 'OptionalMemberExpression' ||
            node.type === 'OptionalCallExpression'
          ) {
            node.type = node.type.substring(8);
          }

          if (state.stop) {
            const chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, 'ChainExpression');
          }
        } else if (
          node.type === 'MemberExpression' ||
          node.type === 'CallExpression'
        ) {
          node.optional = false;
        }

        return node;
      }

      hasPropertyAsPrivateName(node) {
        if (node.type === 'ChainExpression') {
          node = node.expression;
        }

        return super.hasPropertyAsPrivateName(node);
      }

      isOptionalChain(node) {
        return node.type === 'ChainExpression';
      }

      isObjectProperty(node) {
        return node.type === 'Property' && node.kind === 'init' && !node.method;
      }

      isObjectMethod(node) {
        return node.method || node.kind === 'get' || node.kind === 'set';
      }
    };

  class TokContext {
    constructor(token, isExpr, preserveSpace, override) {
      this.token = void 0;
      this.isExpr = void 0;
      this.preserveSpace = void 0;
      this.override = void 0;
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
    }
  }

  const types$1 = {
    braceStatement: new TokContext('{', false),
    braceExpression: new TokContext('{', true),
    recordExpression: new TokContext('#{', true),
    templateQuasi: new TokContext('${', false),
    parenStatement: new TokContext('(', false),
    parenExpression: new TokContext('(', true),
    template: new TokContext('`', true, true, (p) => p.readTmplToken()),
    functionExpression: new TokContext('function', true),
    functionStatement: new TokContext('function', false),
  };

  types.parenR.updateContext = types.braceR.updateContext = function () {
    if (this.state.context.length === 1) {
      this.state.exprAllowed = true;
      return;
    }

    let out = this.state.context.pop();

    if (
      out === types$1.braceStatement &&
      this.curContext().token === 'function'
    ) {
      out = this.state.context.pop();
    }

    this.state.exprAllowed = !out.isExpr;
  };

  types.name.updateContext = function (prevType) {
    let allowed = false;

    if (prevType !== types.dot) {
      if (
        this.state.value === 'of' &&
        !this.state.exprAllowed &&
        prevType !== types._function &&
        prevType !== types._class
      ) {
        allowed = true;
      }
    }

    this.state.exprAllowed = allowed;

    if (this.state.isIterator) {
      this.state.isIterator = false;
    }
  };

  types.braceL.updateContext = function (prevType) {
    this.state.context.push(
      this.braceIsBlock(prevType)
        ? types$1.braceStatement
        : types$1.braceExpression,
    );
    this.state.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function () {
    this.state.context.push(types$1.templateQuasi);
    this.state.exprAllowed = true;
  };

  types.parenL.updateContext = function (prevType) {
    const statementParens =
      prevType === types._if ||
      prevType === types._for ||
      prevType === types._with ||
      prevType === types._while;
    this.state.context.push(
      statementParens ? types$1.parenStatement : types$1.parenExpression,
    );
    this.state.exprAllowed = true;
  };

  types.incDec.updateContext = function () {};

  types._function.updateContext = types._class.updateContext = function (
    prevType,
  ) {
    if (
      prevType.beforeExpr &&
      prevType !== types.semi &&
      prevType !== types._else &&
      !(prevType === types._return && this.hasPrecedingLineBreak()) &&
      !(
        (prevType === types.colon || prevType === types.braceL) &&
        this.curContext() === types$1.b_stat
      )
    ) {
      this.state.context.push(types$1.functionExpression);
    } else {
      this.state.context.push(types$1.functionStatement);
    }

    this.state.exprAllowed = false;
  };

  types.backQuote.updateContext = function () {
    if (this.curContext() === types$1.template) {
      this.state.context.pop();
    } else {
      this.state.context.push(types$1.template);
    }

    this.state.exprAllowed = false;
  };

  types.braceHashL.updateContext = function () {
    this.state.context.push(types$1.recordExpression);
    this.state.exprAllowed = true;
  };

  let nonASCIIidentifierStartChars =
    '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc';
  let nonASCIIidentifierChars =
    '\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f';
  const nonASCIIidentifierStart = new RegExp(
    '[' + nonASCIIidentifierStartChars + ']',
  );
  const nonASCIIidentifier = new RegExp(
    '[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']',
  );
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    157,
    310,
    10,
    21,
    11,
    7,
    153,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    107,
    20,
    28,
    22,
    13,
    52,
    76,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    230,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    35,
    56,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    190,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2749,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    114,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8952,
    286,
    50,
    2,
    18,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    2357,
    44,
    11,
    6,
    17,
    0,
    370,
    43,
    1301,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42717,
    35,
    4148,
    12,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938,
  ];
  const astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    154,
    10,
    176,
    2,
    54,
    14,
    32,
    9,
    16,
    3,
    46,
    10,
    54,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    19306,
    9,
    135,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    5319,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    262,
    6,
    10,
    9,
    419,
    13,
    1495,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239,
  ];

  function isInAstralSet(code, set) {
    let pos = 0x10000;

    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return (
        code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))
      );
    }

    return isInAstralSet(code, astralIdentifierStartCodes);
  }

  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return (
      isInAstralSet(code, astralIdentifierStartCodes) ||
      isInAstralSet(code, astralIdentifierCodes)
    );
  }

  const reservedWords = {
    keyword: [
      'break',
      'case',
      'catch',
      'continue',
      'debugger',
      'default',
      'do',
      'else',
      'finally',
      'for',
      'function',
      'if',
      'return',
      'switch',
      'throw',
      'try',
      'var',
      'const',
      'while',
      'with',
      'new',
      'this',
      'super',
      'class',
      'extends',
      'export',
      'import',
      'null',
      'true',
      'false',
      'in',
      'instanceof',
      'typeof',
      'void',
      'delete',
    ],
    strict: [
      'implements',
      'interface',
      'let',
      'package',
      'private',
      'protected',
      'public',
      'static',
      'yield',
    ],
    strictBind: ['eval', 'arguments'],
  };
  const keywords$1 = new Set(reservedWords.keyword);
  const reservedWordsStrictSet = new Set(reservedWords.strict);
  const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

  function isReservedWord(word, inModule) {
    return (inModule && word === 'await') || word === 'enum';
  }

  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }

  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }

  function isStrictBindReservedWord(word, inModule) {
    return (
      isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)
    );
  }

  function isKeyword(word) {
    return keywords$1.has(word);
  }

  const keywordRelationalOperator = /^in(stanceof)?$/;

  function isIteratorStart(current, next) {
    return current === 64 && next === 64;
  }

  const SCOPE_OTHER = 0b000000000,
    SCOPE_PROGRAM = 0b000000001,
    SCOPE_FUNCTION = 0b000000010,
    SCOPE_ARROW = 0b000000100,
    SCOPE_SIMPLE_CATCH = 0b000001000,
    SCOPE_SUPER = 0b000010000,
    SCOPE_DIRECT_SUPER = 0b000100000,
    SCOPE_CLASS = 0b001000000,
    SCOPE_STATIC_BLOCK = 0b010000000,
    SCOPE_TS_MODULE = 0b100000000,
    SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
  const BIND_KIND_VALUE = 0b000000000001,
    BIND_KIND_TYPE = 0b000000000010,
    BIND_SCOPE_VAR = 0b000000000100,
    BIND_SCOPE_LEXICAL = 0b000000001000,
    BIND_SCOPE_FUNCTION = 0b000000010000,
    BIND_FLAGS_NONE = 0b000001000000,
    BIND_FLAGS_CLASS = 0b000010000000,
    BIND_FLAGS_TS_ENUM = 0b000100000000,
    BIND_FLAGS_TS_CONST_ENUM = 0b001000000000,
    BIND_FLAGS_TS_EXPORT_ONLY = 0b010000000000,
    BIND_FLAGS_FLOW_DECLARE_FN = 0b100000000000;
  const BIND_CLASS =
      BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
    BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
    BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
    BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
    BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
    BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
    BIND_TS_ENUM =
      BIND_KIND_VALUE |
      BIND_KIND_TYPE |
      BIND_SCOPE_LEXICAL |
      BIND_FLAGS_TS_ENUM,
    BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
    BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
    BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
    BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
    BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
    BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
  const CLASS_ELEMENT_FLAG_STATIC = 0b100,
    CLASS_ELEMENT_KIND_GETTER = 0b010,
    CLASS_ELEMENT_KIND_SETTER = 0b001,
    CLASS_ELEMENT_KIND_ACCESSOR =
      CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
  const CLASS_ELEMENT_STATIC_GETTER =
      CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
    CLASS_ELEMENT_STATIC_SETTER =
      CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
    CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
    CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
    CLASS_ELEMENT_OTHER = 0;

  class Scope {
    constructor(flags) {
      this.flags = void 0;
      this.var = [];
      this.lexical = [];
      this.functions = [];
      this.flags = flags;
    }
  }

  class ScopeHandler {
    constructor(raise, inModule) {
      this.scopeStack = [];
      this.undefinedExports = new Map();
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
      this.inModule = inModule;
    }

    get inFunction() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    }

    get allowSuper() {
      return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
    }

    get allowDirectSuper() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    }

    get inClass() {
      return (this.currentThisScope().flags & SCOPE_CLASS) > 0;
    }

    get inStaticBlock() {
      return (this.currentThisScope().flags & SCOPE_STATIC_BLOCK) > 0;
    }

    get inNonArrowFunction() {
      return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
    }

    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }

    createScope(flags) {
      return new Scope(flags);
    }

    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }

    exit() {
      this.scopeStack.pop();
    }

    treatFunctionsAsVarInScope(scope) {
      return !!(
        scope.flags & SCOPE_FUNCTION ||
        (!this.inModule && scope.flags & SCOPE_PROGRAM)
      );
    }

    declareName(name, bindingType, pos) {
      let scope = this.currentScope();

      if (
        bindingType & BIND_SCOPE_LEXICAL ||
        bindingType & BIND_SCOPE_FUNCTION
      ) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.push(name);
        } else {
          scope.lexical.push(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (let i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope.var.push(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }

    maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }

    checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, ErrorMessages.VarRedeclaration, name);
      }
    }

    isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return (
          scope.lexical.indexOf(name) > -1 ||
          scope.functions.indexOf(name) > -1 ||
          scope.var.indexOf(name) > -1
        );
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return (
          scope.lexical.indexOf(name) > -1 ||
          (!this.treatFunctionsAsVarInScope(scope) &&
            scope.var.indexOf(name) > -1)
        );
      }

      return (
        (scope.lexical.indexOf(name) > -1 &&
          !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name)) ||
        (!this.treatFunctionsAsVarInScope(scope) &&
          scope.functions.indexOf(name) > -1)
      );
    }

    checkLocalExport(id) {
      if (
        this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1 &&
        this.scopeStack[0].functions.indexOf(id.name) === -1
      ) {
        this.undefinedExports.set(id.name, id.start);
      }
    }

    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }

    currentVarScope() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const scope = this.scopeStack[i];

        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    }

    currentThisScope() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const scope = this.scopeStack[i];

        if (
          (scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) &&
          !(scope.flags & SCOPE_ARROW)
        ) {
          return scope;
        }
      }
    }
  }

  class FlowScope extends Scope {
    constructor(...args) {
      super(...args);
      this.declareFunctions = [];
    }
  }

  class FlowScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new FlowScope(flags);
    }

    declareName(name, bindingType, pos) {
      const scope = this.currentScope();

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.push(name);
        return;
      }

      super.declareName(...arguments);
    }

    isRedeclaredInScope(scope, name, bindingType) {
      if (super.isRedeclaredInScope(...arguments)) return true;

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        return (
          !scope.declareFunctions.includes(name) &&
          (scope.lexical.includes(name) || scope.functions.includes(name))
        );
      }

      return false;
    }

    checkLocalExport(id) {
      if (this.scopeStack[0].declareFunctions.indexOf(id.name) === -1) {
        super.checkLocalExport(id);
      }
    }
  }

  const reservedTypes = new Set([
    '_',
    'any',
    'bool',
    'boolean',
    'empty',
    'extends',
    'false',
    'interface',
    'mixed',
    'null',
    'number',
    'static',
    'string',
    'true',
    'typeof',
    'void',
  ]);
  const FlowErrors = Object.freeze({
    AmbiguousConditionalArrow:
      'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.',
    AmbiguousDeclareModuleKind:
      'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module',
    AssignReservedType: 'Cannot overwrite reserved type %0',
    DeclareClassElement:
      'The `declare` modifier can only appear on class fields.',
    DeclareClassFieldInitializer:
      'Initializers are not allowed in fields with the `declare` modifier.',
    DuplicateDeclareModuleExports:
      'Duplicate `declare module.exports` statement',
    EnumBooleanMemberNotInitialized:
      'Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.',
    EnumDuplicateMemberName:
      'Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.',
    EnumInconsistentMemberValues:
      'Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.',
    EnumInvalidExplicitType:
      'Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.',
    EnumInvalidExplicitTypeUnknownSupplied:
      'Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.',
    EnumInvalidMemberInitializerPrimaryType:
      'Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.',
    EnumInvalidMemberInitializerSymbolType:
      'Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.',
    EnumInvalidMemberInitializerUnknownType:
      'The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.',
    EnumInvalidMemberName:
      "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized:
      'Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.',
    EnumStringMemberInconsistentlyInitailized:
      'String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.',
    GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.',
    ImportTypeShorthandOnlyInPureImport:
      'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements',
    InexactInsideExact:
      'Explicit inexact syntax cannot appear inside an explicit exact object type',
    InexactInsideNonObject:
      'Explicit inexact syntax cannot appear in class or interface definitions',
    InexactVariance: 'Explicit inexact syntax cannot have variance',
    InvalidNonTypeImportInDeclareModule:
      'Imports within a `declare module` body must always be `import type` or `import typeof`',
    MissingTypeParamDefault:
      'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.',
    NestedDeclareModule:
      '`declare module` cannot be used inside another `declare module`',
    NestedFlowComment: 'Cannot have a flow comment inside another flow comment',
    OptionalBindingPattern:
      'A binding pattern parameter cannot be optional in an implementation signature.',
    SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.',
    SpreadVariance: 'Spread properties cannot have variance',
    ThisParamAnnotationRequired:
      'A type annotation is required for the `this` parameter.',
    ThisParamBannedInConstructor:
      "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.',
    ThisParamMustBeFirst:
      'The `this` parameter must be the first function parameter.',
    ThisParamNoDefault: 'The `this` parameter may not have a default value.',
    TypeBeforeInitializer:
      'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`',
    TypeCastInPattern:
      'The type cast expression is expected to be wrapped with parenthesis',
    UnexpectedExplicitInexactInObject:
      'Explicit inexact syntax must appear at the end of an inexact object',
    UnexpectedReservedType: 'Unexpected reserved type %0',
    UnexpectedReservedUnderscore:
      '`_` is only allowed as a type argument to call or new',
    UnexpectedSpaceBetweenModuloChecks:
      'Spaces between `%` and `checks` are not allowed here.',
    UnexpectedSpreadType:
      'Spread operator cannot appear in class or interface definitions',
    UnexpectedSubtractionOperand:
      'Unexpected token, expected "number" or "bigint"',
    UnexpectedTokenAfterTypeParameter:
      'Expected an arrow function after this type parameter declaration',
    UnexpectedTypeParameterBeforeAsyncArrowFunction:
      'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`',
    UnsupportedDeclareExportKind:
      '`declare export %0` is not supported. Use `%1` instead',
    UnsupportedStatementInDeclareModule:
      'Only declares and type imports are allowed inside declare module',
    UnterminatedFlowComment: 'Unterminated flow-comment',
  });

  function isEsModuleType(bodyElement) {
    return (
      bodyElement.type === 'DeclareExportAllDeclaration' ||
      (bodyElement.type === 'DeclareExportDeclaration' &&
        (!bodyElement.declaration ||
          (bodyElement.declaration.type !== 'TypeAlias' &&
            bodyElement.declaration.type !== 'InterfaceDeclaration')))
    );
  }

  function hasTypeImportKind(node) {
    return node.importKind === 'type' || node.importKind === 'typeof';
  }

  function isMaybeDefaultImport(state) {
    return (
      (state.type === types.name || !!state.type.keyword) &&
      state.value !== 'from'
    );
  }

  const exportSuggestions = {
    const: 'declare export var',
    let: 'declare export var',
    type: 'export type',
    interface: 'export interface',
  };

  function partition(list, test) {
    const list1 = [];
    const list2 = [];

    for (let i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }

    return [list1, list2];
  }

  const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;

  var flow = (superClass) =>
    class extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = undefined;
      }

      getScopeHandler() {
        return FlowScopeHandler;
      }

      shouldParseTypes() {
        return (
          this.getPluginOption('flow', 'all') || this.flowPragma === 'flow'
        );
      }

      shouldParseEnums() {
        return !!this.getPluginOption('flow', 'enums');
      }

      finishToken(type, val) {
        if (
          type !== types.string &&
          type !== types.semi &&
          type !== types.interpreterDirective
        ) {
          if (this.flowPragma === undefined) {
            this.flowPragma = null;
          }
        }

        return super.finishToken(type, val);
      }

      addComment(comment) {
        if (this.flowPragma === undefined) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches);
          else if (matches[1] === 'flow') {
            this.flowPragma = 'flow';
          } else if (matches[1] === 'noflow') {
            this.flowPragma = 'noflow';
          } else {
            throw new Error('Unexpected flow pragma');
          }
        }

        return super.addComment(comment);
      }

      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || types.colon);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }

      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        const moduloPos = this.state.start;
        this.expect(types.modulo);
        const checksLoc = this.state.startLoc;
        this.expectContextual('checks');

        if (
          moduloLoc.line !== checksLoc.line ||
          moduloLoc.column !== checksLoc.column - 1
        ) {
          this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
        }

        if (this.eat(types.parenL)) {
          node.value = this.parseExpression();
          this.expect(types.parenR);
          return this.finishNode(node, 'DeclaredPredicate');
        } else {
          return this.finishNode(node, 'InferredPredicate');
        }
      }

      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(types.colon);
        let type = null;
        let predicate = null;

        if (this.match(types.modulo)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;

          if (this.match(types.modulo)) {
            predicate = this.flowParsePredicate();
          }
        }

        return [type, predicate];
      }

      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, 'DeclareClass');
      }

      flowParseDeclareFunction(node) {
        this.next();
        const id = (node.id = this.parseIdentifier());
        const typeNode = this.startNode();
        const typeContainer = this.startNode();

        if (this.isRelational('<')) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }

        this.expect(types.parenL);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(types.parenR);
        [
          typeNode.returnType,
          node.predicate,
        ] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(
          typeNode,
          'FunctionTypeAnnotation',
        );
        id.typeAnnotation = this.finishNode(typeContainer, 'TypeAnnotation');
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(
          node.id.name,
          BIND_FLOW_DECLARE_FN,
          node.id.start,
        );
        return this.finishNode(node, 'DeclareFunction');
      }

      flowParseDeclare(node, insideModule) {
        if (this.match(types._class)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(types._function)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(types._var)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual('module')) {
          if (this.match(types.dot)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(
                this.state.lastTokStart,
                FlowErrors.NestedDeclareModule,
              );
            }

            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual('type')) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual('opaque')) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual('interface')) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(types._export)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          throw this.unexpected();
        }
      }

      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
        this.semicolon();
        return this.finishNode(node, 'DeclareVariable');
      }

      flowParseDeclareModule(node) {
        this.scope.enter(SCOPE_OTHER);

        if (this.match(types.string)) {
          node.id = this.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }

        const bodyNode = (node.body = this.startNode());
        const body = (bodyNode.body = []);
        this.expect(types.braceL);

        while (!this.match(types.braceR)) {
          let bodyNode = this.startNode();

          if (this.match(types._import)) {
            this.next();

            if (!this.isContextual('type') && !this.match(types._typeof)) {
              this.raise(
                this.state.lastTokStart,
                FlowErrors.InvalidNonTypeImportInDeclareModule,
              );
            }

            this.parseImport(bodyNode);
          } else {
            this.expectContextual(
              'declare',
              FlowErrors.UnsupportedStatementInDeclareModule,
            );
            bodyNode = this.flowParseDeclare(bodyNode, true);
          }

          body.push(bodyNode);
        }

        this.scope.exit();
        this.expect(types.braceR);
        this.finishNode(bodyNode, 'BlockStatement');
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === 'CommonJS') {
              this.raise(
                bodyElement.start,
                FlowErrors.AmbiguousDeclareModuleKind,
              );
            }

            kind = 'ES';
          } else if (bodyElement.type === 'DeclareModuleExports') {
            if (hasModuleExport) {
              this.raise(
                bodyElement.start,
                FlowErrors.DuplicateDeclareModuleExports,
              );
            }

            if (kind === 'ES') {
              this.raise(
                bodyElement.start,
                FlowErrors.AmbiguousDeclareModuleKind,
              );
            }

            kind = 'CommonJS';
            hasModuleExport = true;
          }
        });
        node.kind = kind || 'CommonJS';
        return this.finishNode(node, 'DeclareModule');
      }

      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(types._export);

        if (this.eat(types._default)) {
          if (this.match(types._function) || this.match(types._class)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }

          node.default = true;
          return this.finishNode(node, 'DeclareExportDeclaration');
        } else {
          if (
            this.match(types._const) ||
            this.isLet() ||
            ((this.isContextual('type') || this.isContextual('interface')) &&
              !insideModule)
          ) {
            const label = this.state.value;
            const suggestion = exportSuggestions[label];
            throw this.raise(
              this.state.start,
              FlowErrors.UnsupportedDeclareExportKind,
              label,
              suggestion,
            );
          }

          if (
            this.match(types._var) ||
            this.match(types._function) ||
            this.match(types._class) ||
            this.isContextual('opaque')
          ) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, 'DeclareExportDeclaration');
          } else if (
            this.match(types.star) ||
            this.match(types.braceL) ||
            this.isContextual('interface') ||
            this.isContextual('type') ||
            this.isContextual('opaque')
          ) {
            node = this.parseExport(node);

            if (node.type === 'ExportNamedDeclaration') {
              node.type = 'ExportDeclaration';
              node.default = false;
              delete node.exportKind;
            }

            node.type = 'Declare' + node.type;
            return node;
          }
        }

        throw this.unexpected();
      }

      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual('exports');
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, 'DeclareModuleExports');
      }

      flowParseDeclareTypeAlias(node) {
        this.next();
        this.flowParseTypeAlias(node);
        node.type = 'DeclareTypeAlias';
        return node;
      }

      flowParseDeclareOpaqueType(node) {
        this.next();
        this.flowParseOpaqueType(node, true);
        node.type = 'DeclareOpaqueType';
        return node;
      }

      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node);
        return this.finishNode(node, 'DeclareInterface');
      }

      flowParseInterfaceish(node, isClass = false) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(
          node.id.name,
          isClass ? BIND_FUNCTION : BIND_LEXICAL,
          node.id.start,
        );

        if (this.isRelational('<')) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.extends = [];
        node.implements = [];
        node.mixins = [];

        if (this.eat(types._extends)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(types.comma));
        }

        if (this.isContextual('mixins')) {
          this.next();

          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        if (this.isContextual('implements')) {
          this.next();

          do {
            node.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false,
        });
      }

      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();

        if (this.isRelational('<')) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }

        return this.finishNode(node, 'InterfaceExtends');
      }

      flowParseInterface(node) {
        this.flowParseInterfaceish(node);
        return this.finishNode(node, 'InterfaceDeclaration');
      }

      checkNotUnderscore(word) {
        if (word === '_') {
          this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
        }
      }

      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(
          startLoc,
          declaration
            ? FlowErrors.AssignReservedType
            : FlowErrors.UnexpectedReservedType,
          word,
        );
      }

      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.start, declaration);
        return this.parseIdentifier(liberal);
      }

      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational('<')) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.right = this.flowParseTypeInitialiser(types.eq);
        this.semicolon();
        return this.finishNode(node, 'TypeAlias');
      }

      flowParseOpaqueType(node, declare) {
        this.expectContextual('type');
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational('<')) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.supertype = null;

        if (this.match(types.colon)) {
          node.supertype = this.flowParseTypeInitialiser(types.colon);
        }

        node.impltype = null;

        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(types.eq);
        }

        this.semicolon();
        return this.finishNode(node, 'OpaqueType');
      }

      flowParseTypeParameter(requireDefault = false) {
        const nodeStart = this.state.start;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;

        if (this.match(types.eq)) {
          this.eat(types.eq);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
          }
        }

        return this.finishNode(node, 'TypeParameter');
      }

      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;

        if (this.isRelational('<') || this.match(types.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        let defaultRequired = false;

        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);

          if (typeParameter.default) {
            defaultRequired = true;
          }

          if (!this.isRelational('>')) {
            this.expect(types.comma);
          }
        } while (!this.isRelational('>'));

        this.expectRelational('>');
        this.state.inType = oldInType;
        return this.finishNode(node, 'TypeParameterDeclaration');
      }

      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational('<');
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;

        while (!this.isRelational('>')) {
          node.params.push(this.flowParseType());

          if (!this.isRelational('>')) {
            this.expect(types.comma);
          }
        }

        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expectRelational('>');
        this.state.inType = oldInType;
        return this.finishNode(node, 'TypeParameterInstantiation');
      }

      flowParseTypeParameterInstantiationCallOrNew() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational('<');

        while (!this.isRelational('>')) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());

          if (!this.isRelational('>')) {
            this.expect(types.comma);
          }
        }

        this.expectRelational('>');
        this.state.inType = oldInType;
        return this.finishNode(node, 'TypeParameterInstantiation');
      }

      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual('interface');
        node.extends = [];

        if (this.eat(types._extends)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false,
        });
        return this.finishNode(node, 'InterfaceTypeAnnotation');
      }

      flowParseObjectPropertyKey() {
        return this.match(types.num) || this.match(types.string)
          ? this.parseExprAtom()
          : this.parseIdentifier(true);
      }

      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;

        if (this.lookahead().type === types.colon) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }

        this.expect(types.bracketR);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, 'ObjectTypeIndexer');
      }

      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(types.bracketR);
        this.expect(types.bracketR);

        if (this.isRelational('<') || this.match(types.parenL)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(
            this.startNodeAt(node.start, node.loc.start),
          );
        } else {
          node.method = false;

          if (this.eat(types.question)) {
            node.optional = true;
          }

          node.value = this.flowParseTypeInitialiser();
        }

        return this.finishNode(node, 'ObjectTypeInternalSlot');
      }

      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;

        if (this.isRelational('<')) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        this.expect(types.parenL);

        if (this.match(types._this)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          node.params.push(this.flowParseFunctionTypeParam(false));

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        if (this.eat(types.ellipsis)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }

        this.expect(types.parenR);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, 'FunctionTypeAnnotation');
      }

      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, 'ObjectTypeCallProperty');
      }

      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact,
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;

        if (allowExact && this.match(types.braceBarL)) {
          this.expect(types.braceBarL);
          endDelim = types.braceBarR;
          exact = true;
        } else {
          this.expect(types.braceL);
          endDelim = types.braceR;
          exact = false;
        }

        nodeStart.exact = exact;

        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStart = null;
          let inexactStart = null;
          const node = this.startNode();

          if (allowProto && this.isContextual('proto')) {
            const lookahead = this.lookahead();

            if (
              lookahead.type !== types.colon &&
              lookahead.type !== types.question
            ) {
              this.next();
              protoStart = this.state.start;
              allowStatic = false;
            }
          }

          if (allowStatic && this.isContextual('static')) {
            const lookahead = this.lookahead();

            if (
              lookahead.type !== types.colon &&
              lookahead.type !== types.question
            ) {
              this.next();
              isStatic = true;
            }
          }

          const variance = this.flowParseVariance();

          if (this.eat(types.bracketL)) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (this.eat(types.bracketL)) {
              if (variance) {
                this.unexpected(variance.start);
              }

              nodeStart.internalSlots.push(
                this.flowParseObjectTypeInternalSlot(node, isStatic),
              );
            } else {
              nodeStart.indexers.push(
                this.flowParseObjectTypeIndexer(node, isStatic, variance),
              );
            }
          } else if (this.match(types.parenL) || this.isRelational('<')) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            nodeStart.callProperties.push(
              this.flowParseObjectTypeCallProperty(node, isStatic),
            );
          } else {
            let kind = 'init';

            if (this.isContextual('get') || this.isContextual('set')) {
              const lookahead = this.lookahead();

              if (
                lookahead.type === types.name ||
                lookahead.type === types.string ||
                lookahead.type === types.num
              ) {
                kind = this.state.value;
                this.next();
              }
            }

            const propOrInexact = this.flowParseObjectTypeProperty(
              node,
              isStatic,
              protoStart,
              variance,
              kind,
              allowSpread,
              allowInexact != null ? allowInexact : !exact,
            );

            if (propOrInexact === null) {
              inexact = true;
              inexactStart = this.state.lastTokStart;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }

          this.flowObjectTypeSemicolon();

          if (
            inexactStart &&
            !this.match(types.braceR) &&
            !this.match(types.braceBarR)
          ) {
            this.raise(
              inexactStart,
              FlowErrors.UnexpectedExplicitInexactInObject,
            );
          }
        }

        this.expect(endDelim);

        if (allowSpread) {
          nodeStart.inexact = inexact;
        }

        const out = this.finishNode(nodeStart, 'ObjectTypeAnnotation');
        this.state.inType = oldInType;
        return out;
      }

      flowParseObjectTypeProperty(
        node,
        isStatic,
        protoStart,
        variance,
        kind,
        allowSpread,
        allowInexact,
      ) {
        if (this.eat(types.ellipsis)) {
          const isInexactToken =
            this.match(types.comma) ||
            this.match(types.semi) ||
            this.match(types.braceR) ||
            this.match(types.braceBarR);

          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(
                this.state.lastTokStart,
                FlowErrors.InexactInsideNonObject,
              );
            } else if (!allowInexact) {
              this.raise(
                this.state.lastTokStart,
                FlowErrors.InexactInsideExact,
              );
            }

            if (variance) {
              this.raise(variance.start, FlowErrors.InexactVariance);
            }

            return null;
          }

          if (!allowSpread) {
            this.raise(
              this.state.lastTokStart,
              FlowErrors.UnexpectedSpreadType,
            );
          }

          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.raise(variance.start, FlowErrors.SpreadVariance);
          }

          node.argument = this.flowParseType();
          return this.finishNode(node, 'ObjectTypeSpreadProperty');
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStart != null;
          node.kind = kind;
          let optional = false;

          if (this.isRelational('<') || this.match(types.parenL)) {
            node.method = true;

            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            node.value = this.flowParseObjectTypeMethodish(
              this.startNodeAt(node.start, node.loc.start),
            );

            if (kind === 'get' || kind === 'set') {
              this.flowCheckGetterSetterParams(node);
            }

            if (
              !allowSpread &&
              node.key.name === 'constructor' &&
              node.value.this
            ) {
              this.raise(
                node.value.this.start,
                FlowErrors.ThisParamBannedInConstructor,
              );
            }
          } else {
            if (kind !== 'init') this.unexpected();
            node.method = false;

            if (this.eat(types.question)) {
              optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }

          node.optional = optional;
          return this.finishNode(node, 'ObjectTypeProperty');
        }
      }

      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === 'get' ? 0 : 1;
        const start = property.start;
        const length =
          property.value.params.length + (property.value.rest ? 1 : 0);

        if (property.value.this) {
          this.raise(
            property.value.this.start,
            property.kind === 'get'
              ? FlowErrors.GetterMayNotHaveThisParam
              : FlowErrors.SetterMayNotHaveThisParam,
          );
        }

        if (length !== paramCount) {
          if (property.kind === 'get') {
            this.raise(start, ErrorMessages.BadGetterArity);
          } else {
            this.raise(start, ErrorMessages.BadSetterArity);
          }
        }

        if (property.kind === 'set' && property.value.rest) {
          this.raise(start, ErrorMessages.BadSetterRestParameter);
        }
      }

      flowObjectTypeSemicolon() {
        if (
          !this.eat(types.semi) &&
          !this.eat(types.comma) &&
          !this.match(types.braceR) &&
          !this.match(types.braceBarR)
        ) {
          this.unexpected();
        }
      }

      flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
        startPos = startPos || this.state.start;
        startLoc = startLoc || this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);

        while (this.eat(types.dot)) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, 'QualifiedTypeIdentifier');
        }

        return node;
      }

      flowParseGenericType(startPos, startLoc, id) {
        const node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

        if (this.isRelational('<')) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }

        return this.finishNode(node, 'GenericTypeAnnotation');
      }

      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(types._typeof);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, 'TypeofTypeAnnotation');
      }

      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(types.bracketL);

        while (this.state.pos < this.length && !this.match(types.bracketR)) {
          node.types.push(this.flowParseType());
          if (this.match(types.bracketR)) break;
          this.expect(types.comma);
        }

        this.expect(types.bracketR);
        return this.finishNode(node, 'TupleTypeAnnotation');
      }

      flowParseFunctionTypeParam(first) {
        let name = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === types._this;

        if (lh.type === types.colon || lh.type === types.question) {
          if (isThis && !first) {
            this.raise(node.start, FlowErrors.ThisParamMustBeFirst);
          }

          name = this.parseIdentifier(isThis);

          if (this.eat(types.question)) {
            optional = true;

            if (isThis) {
              this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);
            }
          }

          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }

        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, 'FunctionTypeParam');
      }

      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.start, type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, 'FunctionTypeParam');
      }

      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;

        if (this.match(types._this)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          params.push(this.flowParseFunctionTypeParam(false));

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        if (this.eat(types.ellipsis)) {
          rest = this.flowParseFunctionTypeParam(false);
        }

        return {
          params,
          rest,
          _this,
        };
      }

      flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
        switch (id.name) {
          case 'any':
            return this.finishNode(node, 'AnyTypeAnnotation');

          case 'bool':
          case 'boolean':
            return this.finishNode(node, 'BooleanTypeAnnotation');

          case 'mixed':
            return this.finishNode(node, 'MixedTypeAnnotation');

          case 'empty':
            return this.finishNode(node, 'EmptyTypeAnnotation');

          case 'number':
            return this.finishNode(node, 'NumberTypeAnnotation');

          case 'string':
            return this.finishNode(node, 'StringTypeAnnotation');

          case 'symbol':
            return this.finishNode(node, 'SymbolTypeAnnotation');

          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startPos, startLoc, id);
        }
      }

      flowParsePrimaryType() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;

        switch (this.state.type) {
          case types.name:
            if (this.isContextual('interface')) {
              return this.flowParseInterfaceType();
            }

            return this.flowIdentToTypeAnnotation(
              startPos,
              startLoc,
              node,
              this.parseIdentifier(),
            );

          case types.braceL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true,
            });

          case types.braceBarL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false,
            });

          case types.bracketL:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;

          case types.relational:
            if (this.state.value === '<') {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(types.parenL);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(types.parenR);
              this.expect(types.arrow);
              node.returnType = this.flowParseType();
              return this.finishNode(node, 'FunctionTypeAnnotation');
            }

            break;

          case types.parenL:
            this.next();

            if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
              if (this.match(types.name) || this.match(types._this)) {
                const token = this.lookahead().type;
                isGroupedType =
                  token !== types.question && token !== types.colon;
              } else {
                isGroupedType = true;
              }
            }

            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;

              if (
                this.state.noAnonFunctionType ||
                !(
                  this.match(types.comma) ||
                  (this.match(types.parenR) &&
                    this.lookahead().type === types.arrow)
                )
              ) {
                this.expect(types.parenR);
                return type;
              } else {
                this.eat(types.comma);
              }
            }

            if (type) {
              tmp = this.flowParseFunctionTypeParams([
                this.reinterpretTypeAsFunctionTypeParam(type),
              ]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }

            node.params = tmp.params;
            node.rest = tmp.rest;
            node.this = tmp._this;
            this.expect(types.parenR);
            this.expect(types.arrow);
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, 'FunctionTypeAnnotation');

          case types.string:
            return this.parseLiteral(
              this.state.value,
              'StringLiteralTypeAnnotation',
            );

          case types._true:
          case types._false:
            node.value = this.match(types._true);
            this.next();
            return this.finishNode(node, 'BooleanLiteralTypeAnnotation');

          case types.plusMin:
            if (this.state.value === '-') {
              this.next();

              if (this.match(types.num)) {
                return this.parseLiteral(
                  -this.state.value,
                  'NumberLiteralTypeAnnotation',
                  node.start,
                  node.loc.start,
                );
              }

              if (this.match(types.bigint)) {
                return this.parseLiteral(
                  -this.state.value,
                  'BigIntLiteralTypeAnnotation',
                  node.start,
                  node.loc.start,
                );
              }

              throw this.raise(
                this.state.start,
                FlowErrors.UnexpectedSubtractionOperand,
              );
            }

            throw this.unexpected();

          case types.num:
            return this.parseLiteral(
              this.state.value,
              'NumberLiteralTypeAnnotation',
            );

          case types.bigint:
            return this.parseLiteral(
              this.state.value,
              'BigIntLiteralTypeAnnotation',
            );

          case types._void:
            this.next();
            return this.finishNode(node, 'VoidTypeAnnotation');

          case types._null:
            this.next();
            return this.finishNode(node, 'NullLiteralTypeAnnotation');

          case types._this:
            this.next();
            return this.finishNode(node, 'ThisTypeAnnotation');

          case types.star:
            this.next();
            return this.finishNode(node, 'ExistsTypeAnnotation');

          default:
            if (this.state.type.keyword === 'typeof') {
              return this.flowParseTypeofType();
            } else if (this.state.type.keyword) {
              const label = this.state.type.label;
              this.next();
              return super.createIdentifier(node, label);
            }
        }

        throw this.unexpected();
      }

      flowParsePostfixType() {
        const startPos = this.state.start,
          startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();

        while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startPos, startLoc);
          node.elementType = type;
          this.expect(types.bracketL);
          this.expect(types.bracketR);
          type = this.finishNode(node, 'ArrayTypeAnnotation');
        }

        return type;
      }

      flowParsePrefixType() {
        const node = this.startNode();

        if (this.eat(types.question)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, 'NullableTypeAnnotation');
        } else {
          return this.flowParsePostfixType();
        }
      }

      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();

        if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
          const node = this.startNodeAt(param.start, param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, 'FunctionTypeAnnotation');
        }

        return param;
      }

      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(types.bitwiseAND);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];

        while (this.eat(types.bitwiseAND)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }

        return node.types.length === 1
          ? type
          : this.finishNode(node, 'IntersectionTypeAnnotation');
      }

      flowParseUnionType() {
        const node = this.startNode();
        this.eat(types.bitwiseOR);
        const type = this.flowParseIntersectionType();
        node.types = [type];

        while (this.eat(types.bitwiseOR)) {
          node.types.push(this.flowParseIntersectionType());
        }

        return node.types.length === 1
          ? type
          : this.finishNode(node, 'UnionTypeAnnotation');
      }

      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        this.state.exprAllowed =
          this.state.exprAllowed || this.state.noAnonFunctionType;
        return type;
      }

      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === types.name && this.state.value === '_') {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startPos, startLoc, node);
        } else {
          return this.flowParseType();
        }
      }

      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, 'TypeAnnotation');
      }

      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride
          ? this.parseIdentifier()
          : this.flowParseRestrictedIdentifier();

        if (this.match(types.colon)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }

        return ident;
      }

      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(
          node.expression,
          node.typeAnnotation.end,
          node.typeAnnotation.loc.end,
        );
        return node.expression;
      }

      flowParseVariance() {
        let variance = null;

        if (this.match(types.plusMin)) {
          variance = this.startNode();

          if (this.state.value === '+') {
            variance.kind = 'plus';
          } else {
            variance.kind = 'minus';
          }

          this.next();
          this.finishNode(variance, 'Variance');
        }

        return variance;
      }

      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          return this.forwardNoArrowParamsConversionAt(node, () =>
            super.parseFunctionBody(node, true, isMethod),
          );
        }

        return super.parseFunctionBody(node, false, isMethod);
      }

      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(types.colon)) {
          const typeNode = this.startNode();
          [
            typeNode.typeAnnotation,
            node.predicate,
          ] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation
            ? this.finishNode(typeNode, 'TypeAnnotation')
            : null;
        }

        super.parseFunctionBodyAndFinish(node, type, isMethod);
      }

      parseStatement(context, topLevel) {
        if (
          this.state.strict &&
          this.match(types.name) &&
          this.state.value === 'interface'
        ) {
          const lookahead = this.lookahead();

          if (lookahead.type === types.name || isKeyword(lookahead.value)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.shouldParseEnums() && this.isContextual('enum')) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }

        const stmt = super.parseStatement(context, topLevel);

        if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }

        return stmt;
      }

      parseExpressionStatement(node, expr) {
        if (expr.type === 'Identifier') {
          if (expr.name === 'declare') {
            if (
              this.match(types._class) ||
              this.match(types.name) ||
              this.match(types._function) ||
              this.match(types._var) ||
              this.match(types._export)
            ) {
              return this.flowParseDeclare(node);
            }
          } else if (this.match(types.name)) {
            if (expr.name === 'interface') {
              return this.flowParseInterface(node);
            } else if (expr.name === 'type') {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === 'opaque') {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }

        return super.parseExpressionStatement(node, expr);
      }

      shouldParseExportDeclaration() {
        return (
          this.isContextual('type') ||
          this.isContextual('interface') ||
          this.isContextual('opaque') ||
          (this.shouldParseEnums() && this.isContextual('enum')) ||
          super.shouldParseExportDeclaration()
        );
      }

      isExportDefaultSpecifier() {
        if (
          this.match(types.name) &&
          (this.state.value === 'type' ||
            this.state.value === 'interface' ||
            this.state.value === 'opaque' ||
            (this.shouldParseEnums() && this.state.value === 'enum'))
        ) {
          return false;
        }

        return super.isExportDefaultSpecifier();
      }

      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual('enum')) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }

        return super.parseExportDefaultExpression();
      }

      parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
        if (!this.match(types.question)) return expr;

        if (refNeedsArrowPos) {
          const result = this.tryParse(() =>
            super.parseConditional(expr, startPos, startLoc),
          );

          if (!result.node) {
            refNeedsArrowPos.start = result.error.pos || this.state.start;
            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        }

        this.expect(types.question);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startPos, startLoc);
        let {consequent, failed} = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);

        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];

          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;

            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }

            ({consequent, failed} = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }

          if (failed && valid.length > 1) {
            this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
          }

          if (failed && valid.length === 1) {
            this.state = state;
            this.state.noArrowAt = noArrowAt.concat(valid[0].start);
            ({consequent, failed} = this.tryParseConditionalConsequent());
          }
        }

        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(types.colon);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>
          this.parseMaybeAssign(undefined, undefined, undefined),
        );
        return this.finishNode(node, 'ConditionalExpression');
      }

      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(types.colon);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed,
        };
      }

      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];

        while (stack.length !== 0) {
          const node = stack.pop();

          if (node.type === 'ArrowFunctionExpression') {
            if (node.typeParameters || !node.returnType) {
              this.finishArrowValidation(node);
            } else {
              arrows.push(node);
            }

            stack.push(node.body);
          } else if (node.type === 'ConditionalExpression') {
            stack.push(node.consequent);
            stack.push(node.alternate);
          }
        }

        if (disallowInvalid) {
          arrows.forEach((node) => this.finishArrowValidation(node));
          return [arrows, []];
        }

        return partition(arrows, (node) =>
          node.params.every((param) => this.isAssignable(param, true)),
        );
      }

      finishArrowValidation(node) {
        var _node$extra;

        this.toAssignableList(
          node.params,
          (_node$extra = node.extra) == null
            ? void 0
            : _node$extra.trailingComma,
          false,
        );
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        super.checkParams(node, false, true);
        this.scope.exit();
      }

      forwardNoArrowParamsConversionAt(node, parse) {
        let result;

        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse();
        }

        return result;
      }

      parseParenItem(node, startPos, startLoc) {
        node = super.parseParenItem(node, startPos, startLoc);

        if (this.eat(types.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, 'TypeCastExpression');
        }

        return node;
      }

      assertModuleNodeAllowed(node) {
        if (
          (node.type === 'ImportDeclaration' &&
            (node.importKind === 'type' || node.importKind === 'typeof')) ||
          (node.type === 'ExportNamedDeclaration' &&
            node.exportKind === 'type') ||
          (node.type === 'ExportAllDeclaration' && node.exportKind === 'type')
        ) {
          return;
        }

        super.assertModuleNodeAllowed(node);
      }

      parseExport(node) {
        const decl = super.parseExport(node);

        if (
          decl.type === 'ExportNamedDeclaration' ||
          decl.type === 'ExportAllDeclaration'
        ) {
          decl.exportKind = decl.exportKind || 'value';
        }

        return decl;
      }

      parseExportDeclaration(node) {
        if (this.isContextual('type')) {
          node.exportKind = 'type';
          const declarationNode = this.startNode();
          this.next();

          if (this.match(types.braceL)) {
            node.specifiers = this.parseExportSpecifiers();
            this.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual('opaque')) {
          node.exportKind = 'type';
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual('interface')) {
          node.exportKind = 'type';
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.shouldParseEnums() && this.isContextual('enum')) {
          node.exportKind = 'value';
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }

      eatExportStar(node) {
        if (super.eatExportStar(...arguments)) return true;

        if (this.isContextual('type') && this.lookahead().type === types.star) {
          node.exportKind = 'type';
          this.next();
          this.next();
          return true;
        }

        return false;
      }

      maybeParseExportNamespaceSpecifier(node) {
        const pos = this.state.start;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);

        if (hasNamespace && node.exportKind === 'type') {
          this.unexpected(pos);
        }

        return hasNamespace;
      }

      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);

        if (this.isRelational('<')) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }

      parseClassMember(classBody, member, state) {
        const pos = this.state.start;

        if (this.isContextual('declare')) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }

          member.declare = true;
        }

        super.parseClassMember(classBody, member, state);

        if (member.declare) {
          if (
            member.type !== 'ClassProperty' &&
            member.type !== 'ClassPrivateProperty' &&
            member.type !== 'PropertyDefinition'
          ) {
            this.raise(pos, FlowErrors.DeclareClassElement);
          } else if (member.value) {
            this.raise(
              member.value.start,
              FlowErrors.DeclareClassFieldInitializer,
            );
          }
        }
      }

      getTokenFromCode(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 123 && next === 124) {
          return this.finishOp(types.braceBarL, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types.relational, 1);
        } else if (this.state.inType && code === 63) {
          return this.finishOp(types.question, 1);
        } else if (isIteratorStart(code, next)) {
          this.state.isIterator = true;
          return super.readWord();
        } else {
          return super.getTokenFromCode(code);
        }
      }

      isAssignable(node, isBinding) {
        switch (node.type) {
          case 'Identifier':
          case 'ObjectPattern':
          case 'ArrayPattern':
          case 'AssignmentPattern':
            return true;

          case 'ObjectExpression': {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return (
                prop.type !== 'ObjectMethod' &&
                (i === last || prop.type === 'SpreadElement') &&
                this.isAssignable(prop)
              );
            });
          }

          case 'ObjectProperty':
            return this.isAssignable(node.value);

          case 'SpreadElement':
            return this.isAssignable(node.argument);

          case 'ArrayExpression':
            return node.elements.every((element) => this.isAssignable(element));

          case 'AssignmentExpression':
            return node.operator === '=';

          case 'ParenthesizedExpression':
          case 'TypeCastExpression':
            return this.isAssignable(node.expression);

          case 'MemberExpression':
          case 'OptionalMemberExpression':
            return !isBinding;

          default:
            return false;
        }
      }

      toAssignable(node, isLHS = false) {
        if (node.type === 'TypeCastExpression') {
          return super.toAssignable(this.typeCastToParameter(node), isLHS);
        } else {
          return super.toAssignable(node, isLHS);
        }
      }

      toAssignableList(exprList, trailingCommaPos, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];

          if ((expr == null ? void 0 : expr.type) === 'TypeCastExpression') {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }

        return super.toAssignableList(exprList, trailingCommaPos, isLHS);
      }

      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;

          const expr = exprList[i];

          if (
            expr &&
            expr.type === 'TypeCastExpression' &&
            !(
              (_expr$extra = expr.extra) != null && _expr$extra.parenthesized
            ) &&
            (exprList.length > 1 || !isParenthesizedExpr)
          ) {
            this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
          }
        }

        return exprList;
      }

      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(
          close,
          canBePattern,
          isTuple,
          refExpressionErrors,
        );

        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }

        return node;
      }

      checkLVal(expr, ...args) {
        if (expr.type !== 'TypeCastExpression') {
          return super.checkLVal(expr, ...args);
        }
      }

      parseClassProperty(node) {
        if (this.match(types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return super.parseClassProperty(node);
      }

      parseClassPrivateProperty(node) {
        if (this.match(types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return super.parseClassPrivateProperty(node);
      }

      isClassMethod() {
        return this.isRelational('<') || super.isClassMethod();
      }

      isClassProperty() {
        return this.match(types.colon) || super.isClassProperty();
      }

      isNonstaticConstructor(method) {
        return !this.match(types.colon) && super.isNonstaticConstructor(method);
      }

      isThisParam(param) {
        return param.type === 'Identifier' && param.name === 'this';
      }

      pushClassMethod(
        classBody,
        method,
        isGenerator,
        isAsync,
        isConstructor,
        allowsDirectSuper,
      ) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational('<')) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        super.pushClassMethod(
          classBody,
          method,
          isGenerator,
          isAsync,
          isConstructor,
          allowsDirectSuper,
        );

        if (method.params && isConstructor) {
          const params = method.params;

          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
          }
        } else if (
          method.type === 'MethodDefinition' &&
          isConstructor &&
          method.value.params
        ) {
          const params = method.value.params;

          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
          }
        }
      }

      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational('<')) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }

      parseClassSuper(node) {
        super.parseClassSuper(node);

        if (node.superClass && this.isRelational('<')) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }

        if (this.isContextual('implements')) {
          this.next();
          const implemented = (node.implements = []);

          do {
            const node = this.startNode();
            node.id = this.flowParseRestrictedIdentifier(true);

            if (this.isRelational('<')) {
              node.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node.typeParameters = null;
            }

            implemented.push(this.finishNode(node, 'ClassImplements'));
          } while (this.eat(types.comma));
        }
      }

      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);

        if (params.length > 0) {
          const param = params[0];

          if (this.isThisParam(param) && method.kind === 'get') {
            this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
          } else if (this.isThisParam(param)) {
            this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
          }
        }
      }

      parsePropertyName(node, isPrivateNameAllowed) {
        const variance = this.flowParseVariance();
        const key = super.parsePropertyName(node, isPrivateNameAllowed);
        node.variance = variance;
        return key;
      }

      parseObjPropValue(
        prop,
        startPos,
        startLoc,
        isGenerator,
        isAsync,
        isPattern,
        isAccessor,
        refExpressionErrors,
      ) {
        if (prop.variance) {
          this.unexpected(prop.variance.start);
        }

        delete prop.variance;
        let typeParameters;

        if (this.isRelational('<') && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(types.parenL)) this.unexpected();
        }

        super.parseObjPropValue(
          prop,
          startPos,
          startLoc,
          isGenerator,
          isAsync,
          isPattern,
          isAccessor,
          refExpressionErrors,
        );

        if (typeParameters) {
          (prop.value || prop).typeParameters = typeParameters;
        }
      }

      parseAssignableListItemTypes(param) {
        if (this.eat(types.question)) {
          if (param.type !== 'Identifier') {
            this.raise(param.start, FlowErrors.OptionalBindingPattern);
          }

          if (this.isThisParam(param)) {
            this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
          }

          param.optional = true;
        }

        if (this.match(types.colon)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
        }

        if (this.match(types.eq) && this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.ThisParamNoDefault);
        }

        this.resetEndLocation(param);
        return param;
      }

      parseMaybeDefault(startPos, startLoc, left) {
        const node = super.parseMaybeDefault(startPos, startLoc, left);

        if (
          node.type === 'AssignmentPattern' &&
          node.typeAnnotation &&
          node.right.start < node.typeAnnotation.start
        ) {
          this.raise(
            node.typeAnnotation.start,
            FlowErrors.TypeBeforeInitializer,
          );
        }

        return node;
      }

      shouldParseDefaultImport(node) {
        if (!hasTypeImportKind(node)) {
          return super.shouldParseDefaultImport(node);
        }

        return isMaybeDefaultImport(this.state);
      }

      parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = hasTypeImportKind(node)
          ? this.flowParseRestrictedIdentifier(true, true)
          : this.parseIdentifier();
        this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, type));
      }

      maybeParseDefaultImportSpecifier(node) {
        node.importKind = 'value';
        let kind = null;

        if (this.match(types._typeof)) {
          kind = 'typeof';
        } else if (this.isContextual('type')) {
          kind = 'type';
        }

        if (kind) {
          const lh = this.lookahead();

          if (kind === 'type' && lh.type === types.star) {
            this.unexpected(lh.start);
          }

          if (
            isMaybeDefaultImport(lh) ||
            lh.type === types.braceL ||
            lh.type === types.star
          ) {
            this.next();
            node.importKind = kind;
          }
        }

        return super.maybeParseDefaultImportSpecifier(node);
      }

      parseImportSpecifier(node) {
        const specifier = this.startNode();
        const firstIdentLoc = this.state.start;
        const firstIdent = this.parseModuleExportName();
        let specifierTypeKind = null;

        if (firstIdent.type === 'Identifier') {
          if (firstIdent.name === 'type') {
            specifierTypeKind = 'type';
          } else if (firstIdent.name === 'typeof') {
            specifierTypeKind = 'typeof';
          }
        }

        let isBinding = false;

        if (this.isContextual('as') && !this.isLookaheadContextual('as')) {
          const as_ident = this.parseIdentifier(true);

          if (
            specifierTypeKind !== null &&
            !this.match(types.name) &&
            !this.state.type.keyword
          ) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = as_ident.__clone();
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else if (
          specifierTypeKind !== null &&
          (this.match(types.name) || this.state.type.keyword)
        ) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;

          if (this.eatContextual('as')) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = specifier.imported.__clone();
          }
        } else {
          if (firstIdent.type === 'StringLiteral') {
            throw this.raise(
              specifier.start,
              ErrorMessages.ImportBindingIsString,
              firstIdent.value,
            );
          }

          isBinding = true;
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = specifier.imported.__clone();
        }

        const nodeIsTypeImport = hasTypeImportKind(node);
        const specifierIsTypeImport = hasTypeImportKind(specifier);

        if (nodeIsTypeImport && specifierIsTypeImport) {
          this.raise(
            firstIdentLoc,
            FlowErrors.ImportTypeShorthandOnlyInPureImport,
          );
        }

        if (nodeIsTypeImport || specifierIsTypeImport) {
          this.checkReservedType(
            specifier.local.name,
            specifier.local.start,
            true,
          );
        }

        if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
          this.checkReservedWord(
            specifier.local.name,
            specifier.start,
            true,
            true,
          );
        }

        this.checkLVal(specifier.local, 'import specifier', BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, 'ImportSpecifier'));
      }

      parseBindingAtom() {
        switch (this.state.type) {
          case types._this:
            return this.parseIdentifier(true);

          default:
            return super.parseBindingAtom();
        }
      }

      parseFunctionParams(node, allowModifiers) {
        const kind = node.kind;

        if (kind !== 'get' && kind !== 'set' && this.isRelational('<')) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        super.parseFunctionParams(node, allowModifiers);
      }

      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);

        if (this.match(types.colon)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }

      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }

        return super.parseAsyncArrowFromCallExpression(node, call);
      }

      shouldParseAsyncArrow() {
        return this.match(types.colon) || super.shouldParseAsyncArrow();
      }

      parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
        var _jsx;

        let state = null;
        let jsx;

        if (
          this.hasPlugin('jsx') &&
          (this.match(types.jsxTagStart) || this.isRelational('<'))
        ) {
          state = this.state.clone();
          jsx = this.tryParse(
            () =>
              super.parseMaybeAssign(
                refExpressionErrors,
                afterLeftParse,
                refNeedsArrowPos,
              ),
            state,
          );
          if (!jsx.error) return jsx.node;
          const {context} = this.state;

          if (context[context.length - 1] === types$1.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types$1.j_expr) {
            context.length -= 1;
          }
        }

        if (((_jsx = jsx) != null && _jsx.error) || this.isRelational('<')) {
          var _jsx2, _jsx3;

          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;

            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression = this.forwardNoArrowParamsConversionAt(
              typeParameters,
              () => {
                const result = super.parseMaybeAssign(
                  refExpressionErrors,
                  afterLeftParse,
                  refNeedsArrowPos,
                );
                this.resetStartLocationFromNode(result, typeParameters);
                return result;
              },
            );

            if (
              arrowExpression.type !== 'ArrowFunctionExpression' &&
              (_arrowExpression$extr = arrowExpression.extra) != null &&
              _arrowExpression$extr.parenthesized
            ) {
              abort();
            }

            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression;
          }, state);
          let arrowExpression = null;

          if (
            arrow.node &&
            this.maybeUnwrapTypeCastExpression(arrow.node).type ===
              'ArrowFunctionExpression'
          ) {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(
                  typeParameters.start,
                  FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,
                );
              }

              return arrow.node;
            }

            arrowExpression = arrow.node;
          }

          if ((_jsx2 = jsx) != null && _jsx2.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }

          if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(
            typeParameters.start,
            FlowErrors.UnexpectedTokenAfterTypeParameter,
          );
        }

        return super.parseMaybeAssign(
          refExpressionErrors,
          afterLeftParse,
          refNeedsArrowPos,
        );
      }

      parseArrow(node) {
        if (this.match(types.colon)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [
              typeNode.typeAnnotation,
              node.predicate,
            ] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon()) this.unexpected();
            if (!this.match(types.arrow)) this.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation
            ? this.finishNode(result.node, 'TypeAnnotation')
            : null;
        }

        return super.parseArrow(node);
      }

      shouldParseArrow() {
        return this.match(types.colon) || super.shouldParseArrow();
      }

      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }

      checkParams(node, allowDuplicates, isArrowFunction) {
        if (
          isArrowFunction &&
          this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1
        ) {
          return;
        }

        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);
          }
        }

        return super.checkParams(...arguments);
      }

      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(
          canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,
        );
      }

      parseSubscripts(base, startPos, startLoc, noCalls) {
        if (
          base.type === 'Identifier' &&
          base.name === 'async' &&
          this.state.noArrowAt.indexOf(startPos) !== -1
        ) {
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseCallExpressionArguments(
            types.parenR,
            false,
          );
          base = this.finishNode(node, 'CallExpression');
        } else if (
          base.type === 'Identifier' &&
          base.name === 'async' &&
          this.isRelational('<')
        ) {
          const state = this.state.clone();
          const arrow = this.tryParse(
            (abort) =>
              this.parseAsyncArrowWithTypeParameters(startPos, startLoc) ||
              abort(),
            state,
          );
          if (!arrow.error && !arrow.aborted) return arrow.node;
          const result = this.tryParse(
            () => super.parseSubscripts(base, startPos, startLoc, noCalls),
            state,
          );
          if (result.node && !result.error) return result.node;

          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }

          if (result.node) {
            this.state = result.failState;
            return result.node;
          }

          throw arrow.error || result.error;
        }

        return super.parseSubscripts(base, startPos, startLoc, noCalls);
      }

      parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
        if (this.match(types.questionDot) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;

          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }

          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(types.parenL);
          node.arguments = this.parseCallExpressionArguments(
            types.parenR,
            false,
          );
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (
          !noCalls &&
          this.shouldParseTypes() &&
          this.isRelational('<')
        ) {
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(types.parenL);
            node.arguments = this.parseCallExpressionArguments(
              types.parenR,
              false,
            );
            if (subscriptState.optionalChainMember) node.optional = false;
            return this.finishCallExpression(
              node,
              subscriptState.optionalChainMember,
            );
          });

          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }

        return super.parseSubscript(
          base,
          startPos,
          startLoc,
          noCalls,
          subscriptState,
        );
      }

      parseNewArguments(node) {
        let targs = null;

        if (this.shouldParseTypes() && this.isRelational('<')) {
          targs = this.tryParse(() =>
            this.flowParseTypeParameterInstantiationCallOrNew(),
          ).node;
        }

        node.typeArguments = targs;
        super.parseNewArguments(node);
      }

      parseAsyncArrowWithTypeParameters(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        this.parseFunctionParams(node);
        if (!this.parseArrow(node)) return;
        return this.parseArrowExpression(node, undefined, true);
      }

      readToken_mult_modulo(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }

        super.readToken_mult_modulo(code);
      }

      readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 124 && next === 125) {
          this.finishOp(types.braceBarR, 2);
          return;
        }

        super.readToken_pipe_amp(code);
      }

      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);

        if (this.state.hasFlowComment) {
          this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
        }

        return fileNode;
      }

      skipBlockComment() {
        if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            this.unexpected(null, FlowErrors.NestedFlowComment);
          }

          this.hasFlowCommentCompletion();
          this.state.pos += this.skipFlowComment();
          this.state.hasFlowComment = true;
          return;
        }

        if (this.state.hasFlowComment) {
          const end = this.input.indexOf('*-/', (this.state.pos += 2));

          if (end === -1) {
            throw this.raise(
              this.state.pos - 2,
              ErrorMessages.UnterminatedComment,
            );
          }

          this.state.pos = end + 3;
          return;
        }

        super.skipBlockComment();
      }

      skipFlowComment() {
        const {pos} = this.state;
        let shiftToFirstNonWhiteSpace = 2;

        while (
          [32, 9].includes(
            this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),
          )
        ) {
          shiftToFirstNonWhiteSpace++;
        }

        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }

        if (
          this.input.slice(
            shiftToFirstNonWhiteSpace + pos,
            shiftToFirstNonWhiteSpace + pos + 12,
          ) === 'flow-include'
        ) {
          return shiftToFirstNonWhiteSpace + 12;
        }

        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }

        return false;
      }

      hasFlowCommentCompletion() {
        const end = this.input.indexOf('*/', this.state.pos);

        if (end === -1) {
          throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
        }
      }

      flowEnumErrorBooleanMemberNotInitialized(pos, {enumName, memberName}) {
        this.raise(
          pos,
          FlowErrors.EnumBooleanMemberNotInitialized,
          memberName,
          enumName,
        );
      }

      flowEnumErrorInvalidMemberName(pos, {enumName, memberName}) {
        const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
        this.raise(
          pos,
          FlowErrors.EnumInvalidMemberName,
          memberName,
          suggestion,
          enumName,
        );
      }

      flowEnumErrorDuplicateMemberName(pos, {enumName, memberName}) {
        this.raise(
          pos,
          FlowErrors.EnumDuplicateMemberName,
          memberName,
          enumName,
        );
      }

      flowEnumErrorInconsistentMemberValues(pos, {enumName}) {
        this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
      }

      flowEnumErrorInvalidExplicitType(pos, {enumName, suppliedType}) {
        return this.raise(
          pos,
          suppliedType === null
            ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied
            : FlowErrors.EnumInvalidExplicitType,
          enumName,
          suppliedType,
        );
      }

      flowEnumErrorInvalidMemberInitializer(
        pos,
        {enumName, explicitType, memberName},
      ) {
        let message = null;

        switch (explicitType) {
          case 'boolean':
          case 'number':
          case 'string':
            message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
            break;

          case 'symbol':
            message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
            break;

          default:
            message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
        }

        return this.raise(pos, message, enumName, memberName, explicitType);
      }

      flowEnumErrorNumberMemberNotInitialized(pos, {enumName, memberName}) {
        this.raise(
          pos,
          FlowErrors.EnumNumberMemberNotInitialized,
          enumName,
          memberName,
        );
      }

      flowEnumErrorStringMemberInconsistentlyInitailized(pos, {enumName}) {
        this.raise(
          pos,
          FlowErrors.EnumStringMemberInconsistentlyInitailized,
          enumName,
        );
      }

      flowEnumMemberInit() {
        const startPos = this.state.start;

        const endOfInit = () =>
          this.match(types.comma) || this.match(types.braceR);

        switch (this.state.type) {
          case types.num: {
            const literal = this.parseLiteral(
              this.state.value,
              'NumericLiteral',
            );

            if (endOfInit()) {
              return {
                type: 'number',
                pos: literal.start,
                value: literal,
              };
            }

            return {
              type: 'invalid',
              pos: startPos,
            };
          }

          case types.string: {
            const literal = this.parseLiteral(
              this.state.value,
              'StringLiteral',
            );

            if (endOfInit()) {
              return {
                type: 'string',
                pos: literal.start,
                value: literal,
              };
            }

            return {
              type: 'invalid',
              pos: startPos,
            };
          }

          case types._true:
          case types._false: {
            const literal = this.parseBooleanLiteral();

            if (endOfInit()) {
              return {
                type: 'boolean',
                pos: literal.start,
                value: literal,
              };
            }

            return {
              type: 'invalid',
              pos: startPos,
            };
          }

          default:
            return {
              type: 'invalid',
              pos: startPos,
            };
        }
      }

      flowEnumMemberRaw() {
        const pos = this.state.start;
        const id = this.parseIdentifier(true);
        const init = this.eat(types.eq)
          ? this.flowEnumMemberInit()
          : {
              type: 'none',
              pos,
            };
        return {
          id,
          init,
        };
      }

      flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
        const {explicitType} = context;

        if (explicitType === null) {
          return;
        }

        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(pos, context);
        }
      }

      flowEnumMembers({enumName, explicitType}) {
        const seenNames = new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: [],
        };
        let hasUnknownMembers = false;

        while (!this.match(types.braceR)) {
          if (this.eat(types.ellipsis)) {
            hasUnknownMembers = true;
            break;
          }

          const memberNode = this.startNode();
          const {id, init} = this.flowEnumMemberRaw();
          const memberName = id.name;

          if (memberName === '') {
            continue;
          }

          if (/^[a-z]/.test(memberName)) {
            this.flowEnumErrorInvalidMemberName(id.start, {
              enumName,
              memberName,
            });
          }

          if (seenNames.has(memberName)) {
            this.flowEnumErrorDuplicateMemberName(id.start, {
              enumName,
              memberName,
            });
          }

          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName,
          };
          memberNode.id = id;

          switch (init.type) {
            case 'boolean': {
              this.flowEnumCheckExplicitTypeMismatch(
                init.pos,
                context,
                'boolean',
              );
              memberNode.init = init.value;
              members.booleanMembers.push(
                this.finishNode(memberNode, 'EnumBooleanMember'),
              );
              break;
            }

            case 'number': {
              this.flowEnumCheckExplicitTypeMismatch(
                init.pos,
                context,
                'number',
              );
              memberNode.init = init.value;
              members.numberMembers.push(
                this.finishNode(memberNode, 'EnumNumberMember'),
              );
              break;
            }

            case 'string': {
              this.flowEnumCheckExplicitTypeMismatch(
                init.pos,
                context,
                'string',
              );
              memberNode.init = init.value;
              members.stringMembers.push(
                this.finishNode(memberNode, 'EnumStringMember'),
              );
              break;
            }

            case 'invalid': {
              throw this.flowEnumErrorInvalidMemberInitializer(
                init.pos,
                context,
              );
            }

            case 'none': {
              switch (explicitType) {
                case 'boolean':
                  this.flowEnumErrorBooleanMemberNotInitialized(
                    init.pos,
                    context,
                  );
                  break;

                case 'number':
                  this.flowEnumErrorNumberMemberNotInitialized(
                    init.pos,
                    context,
                  );
                  break;

                default:
                  members.defaultedMembers.push(
                    this.finishNode(memberNode, 'EnumDefaultedMember'),
                  );
              }
            }
          }

          if (!this.match(types.braceR)) {
            this.expect(types.comma);
          }
        }

        return {
          members,
          hasUnknownMembers,
        };
      }

      flowEnumStringMembers(initializedMembers, defaultedMembers, {enumName}) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitailized(
              member.start,
              {
                enumName,
              },
            );
          }

          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitailized(
              member.start,
              {
                enumName,
              },
            );
          }

          return initializedMembers;
        }
      }

      flowEnumParseExplicitType({enumName}) {
        if (this.eatContextual('of')) {
          if (!this.match(types.name)) {
            throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName,
              suppliedType: null,
            });
          }

          const {value} = this.state;
          this.next();

          if (
            value !== 'boolean' &&
            value !== 'number' &&
            value !== 'string' &&
            value !== 'symbol'
          ) {
            this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName,
              suppliedType: value,
            });
          }

          return value;
        }

        return null;
      }

      flowEnumBody(node, {enumName, nameLoc}) {
        const explicitType = this.flowEnumParseExplicitType({
          enumName,
        });
        this.expect(types.braceL);
        const {members, hasUnknownMembers} = this.flowEnumMembers({
          enumName,
          explicitType,
        });
        node.hasUnknownMembers = hasUnknownMembers;

        switch (explicitType) {
          case 'boolean':
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(types.braceR);
            return this.finishNode(node, 'EnumBooleanBody');

          case 'number':
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(types.braceR);
            return this.finishNode(node, 'EnumNumberBody');

          case 'string':
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(
              members.stringMembers,
              members.defaultedMembers,
              {
                enumName,
              },
            );
            this.expect(types.braceR);
            return this.finishNode(node, 'EnumStringBody');

          case 'symbol':
            node.members = members.defaultedMembers;
            this.expect(types.braceR);
            return this.finishNode(node, 'EnumSymbolBody');

          default: {
            const empty = () => {
              node.members = [];
              this.expect(types.braceR);
              return this.finishNode(node, 'EnumStringBody');
            };

            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;

            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(
                members.stringMembers,
                members.defaultedMembers,
                {
                  enumName,
                },
              );
              this.expect(types.braceR);
              return this.finishNode(node, 'EnumStringBody');
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                  enumName,
                  memberName: member.id.name,
                });
              }

              node.members = members.booleanMembers;
              this.expect(types.braceR);
              return this.finishNode(node, 'EnumBooleanBody');
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.start, {
                  enumName,
                  memberName: member.id.name,
                });
              }

              node.members = members.numberMembers;
              this.expect(types.braceR);
              return this.finishNode(node, 'EnumNumberBody');
            } else {
              this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                enumName,
              });
              return empty();
            }
          }
        }
      }

      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), {
          enumName: id.name,
          nameLoc: id.start,
        });
        return this.finishNode(node, 'EnumDeclaration');
      }

      updateContext(prevType) {
        if (
          this.match(types.name) &&
          this.state.value === 'of' &&
          prevType === types.name &&
          this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) ===
            'interface'
        ) {
          this.state.exprAllowed = false;
        } else {
          super.updateContext(prevType);
        }
      }

      isLookaheadToken_lt() {
        const next = this.nextTokenStart();

        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }

        return false;
      }

      maybeUnwrapTypeCastExpression(node) {
        return node.type === 'TypeCastExpression' ? node.expression : node;
      }
    };

  const entities = {
    quot: '\u0022',
    amp: '&',
    apos: '\u0027',
    lt: '<',
    gt: '>',
    nbsp: '\u00A0',
    iexcl: '\u00A1',
    cent: '\u00A2',
    pound: '\u00A3',
    curren: '\u00A4',
    yen: '\u00A5',
    brvbar: '\u00A6',
    sect: '\u00A7',
    uml: '\u00A8',
    copy: '\u00A9',
    ordf: '\u00AA',
    laquo: '\u00AB',
    not: '\u00AC',
    shy: '\u00AD',
    reg: '\u00AE',
    macr: '\u00AF',
    deg: '\u00B0',
    plusmn: '\u00B1',
    sup2: '\u00B2',
    sup3: '\u00B3',
    acute: '\u00B4',
    micro: '\u00B5',
    para: '\u00B6',
    middot: '\u00B7',
    cedil: '\u00B8',
    sup1: '\u00B9',
    ordm: '\u00BA',
    raquo: '\u00BB',
    frac14: '\u00BC',
    frac12: '\u00BD',
    frac34: '\u00BE',
    iquest: '\u00BF',
    Agrave: '\u00C0',
    Aacute: '\u00C1',
    Acirc: '\u00C2',
    Atilde: '\u00C3',
    Auml: '\u00C4',
    Aring: '\u00C5',
    AElig: '\u00C6',
    Ccedil: '\u00C7',
    Egrave: '\u00C8',
    Eacute: '\u00C9',
    Ecirc: '\u00CA',
    Euml: '\u00CB',
    Igrave: '\u00CC',
    Iacute: '\u00CD',
    Icirc: '\u00CE',
    Iuml: '\u00CF',
    ETH: '\u00D0',
    Ntilde: '\u00D1',
    Ograve: '\u00D2',
    Oacute: '\u00D3',
    Ocirc: '\u00D4',
    Otilde: '\u00D5',
    Ouml: '\u00D6',
    times: '\u00D7',
    Oslash: '\u00D8',
    Ugrave: '\u00D9',
    Uacute: '\u00DA',
    Ucirc: '\u00DB',
    Uuml: '\u00DC',
    Yacute: '\u00DD',
    THORN: '\u00DE',
    szlig: '\u00DF',
    agrave: '\u00E0',
    aacute: '\u00E1',
    acirc: '\u00E2',
    atilde: '\u00E3',
    auml: '\u00E4',
    aring: '\u00E5',
    aelig: '\u00E6',
    ccedil: '\u00E7',
    egrave: '\u00E8',
    eacute: '\u00E9',
    ecirc: '\u00EA',
    euml: '\u00EB',
    igrave: '\u00EC',
    iacute: '\u00ED',
    icirc: '\u00EE',
    iuml: '\u00EF',
    eth: '\u00F0',
    ntilde: '\u00F1',
    ograve: '\u00F2',
    oacute: '\u00F3',
    ocirc: '\u00F4',
    otilde: '\u00F5',
    ouml: '\u00F6',
    divide: '\u00F7',
    oslash: '\u00F8',
    ugrave: '\u00F9',
    uacute: '\u00FA',
    ucirc: '\u00FB',
    uuml: '\u00FC',
    yacute: '\u00FD',
    thorn: '\u00FE',
    yuml: '\u00FF',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02C6',
    tilde: '\u02DC',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039A',
    Lambda: '\u039B',
    Mu: '\u039C',
    Nu: '\u039D',
    Xi: '\u039E',
    Omicron: '\u039F',
    Pi: '\u03A0',
    Rho: '\u03A1',
    Sigma: '\u03A3',
    Tau: '\u03A4',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Chi: '\u03A7',
    Psi: '\u03A8',
    Omega: '\u03A9',
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03B5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigmaf: '\u03C2',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03C6',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    thetasym: '\u03D1',
    upsih: '\u03D2',
    piv: '\u03D6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200C',
    zwj: '\u200D',
    lrm: '\u200E',
    rlm: '\u200F',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201A',
    ldquo: '\u201C',
    rdquo: '\u201D',
    bdquo: '\u201E',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203A',
    oline: '\u203E',
    frasl: '\u2044',
    euro: '\u20AC',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211C',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21B5',
    lArr: '\u21D0',
    uArr: '\u21D1',
    rArr: '\u21D2',
    dArr: '\u21D3',
    hArr: '\u21D4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220B',
    prod: '\u220F',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221A',
    prop: '\u221D',
    infin: '\u221E',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    int: '\u222B',
    there4: '\u2234',
    sim: '\u223C',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22A5',
    sdot: '\u22C5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230A',
    rfloor: '\u230B',
    lang: '\u2329',
    rang: '\u232A',
    loz: '\u25CA',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666',
  };
  const HEX_NUMBER = /^[\da-fA-F]+$/;
  const DECIMAL_NUMBER = /^\d+$/;
  const JsxErrors = Object.freeze({
    AttributeIsEmpty:
      'JSX attributes must only be assigned a non-empty expression',
    MissingClosingTagElement: 'Expected corresponding JSX closing tag for <%0>',
    MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>',
    UnexpectedSequenceExpression:
      'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?',
    UnsupportedJsxValue:
      'JSX value should be either an expression or a quoted JSX text',
    UnterminatedJsxContent: 'Unterminated JSX contents',
    UnwrappedAdjacentJSXElements:
      'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?',
  });
  types$1.j_oTag = new TokContext('<tag', false);
  types$1.j_cTag = new TokContext('</tag', false);
  types$1.j_expr = new TokContext('<tag>...</tag>', true, true);
  types.jsxName = new TokenType('jsxName');
  types.jsxText = new TokenType('jsxText', {
    beforeExpr: true,
  });
  types.jsxTagStart = new TokenType('jsxTagStart', {
    startsExpr: true,
  });
  types.jsxTagEnd = new TokenType('jsxTagEnd');

  types.jsxTagStart.updateContext = function () {
    this.state.context.push(types$1.j_expr);
    this.state.context.push(types$1.j_oTag);
    this.state.exprAllowed = false;
  };

  types.jsxTagEnd.updateContext = function (prevType) {
    const out = this.state.context.pop();

    if (
      (out === types$1.j_oTag && prevType === types.slash) ||
      out === types$1.j_cTag
    ) {
      this.state.context.pop();
      this.state.exprAllowed = this.curContext() === types$1.j_expr;
    } else {
      this.state.exprAllowed = true;
    }
  };

  function isFragment(object) {
    return object
      ? object.type === 'JSXOpeningFragment' ||
          object.type === 'JSXClosingFragment'
      : false;
  }

  function getQualifiedJSXName(object) {
    if (object.type === 'JSXIdentifier') {
      return object.name;
    }

    if (object.type === 'JSXNamespacedName') {
      return object.namespace.name + ':' + object.name.name;
    }

    if (object.type === 'JSXMemberExpression') {
      return (
        getQualifiedJSXName(object.object) +
        '.' +
        getQualifiedJSXName(object.property)
      );
    }

    throw new Error('Node had unexpected type: ' + object.type);
  }

  var jsx = (superClass) =>
    class extends superClass {
      jsxReadToken() {
        let out = '';
        let chunkStart = this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(
              this.state.start,
              JsxErrors.UnterminatedJsxContent,
            );
          }

          const ch = this.input.charCodeAt(this.state.pos);

          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.exprAllowed) {
                  ++this.state.pos;
                  return this.finishToken(types.jsxTagStart);
                }

                return super.getTokenFromCode(ch);
              }

              out += this.input.slice(chunkStart, this.state.pos);
              return this.finishToken(types.jsxText, out);

            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;

            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }

      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;

        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? '\n' : '\r\n';
        } else {
          out = String.fromCharCode(ch);
        }

        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }

      jsxReadString(quote) {
        let out = '';
        let chunkStart = ++this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(
              this.state.start,
              ErrorMessages.UnterminatedString,
            );
          }

          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;

          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }

        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(types.string, out);
      }

      jsxReadEntity() {
        let str = '';
        let count = 0;
        let entity;
        let ch = this.input[this.state.pos];
        const startPos = ++this.state.pos;

        while (this.state.pos < this.length && count++ < 10) {
          ch = this.input[this.state.pos++];

          if (ch === ';') {
            if (str[0] === '#') {
              if (str[1] === 'x') {
                str = str.substr(2);

                if (HEX_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 16));
                }
              } else {
                str = str.substr(1);

                if (DECIMAL_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 10));
                }
              }
            } else {
              entity = entities[str];
            }

            break;
          }

          str += ch;
        }

        if (!entity) {
          this.state.pos = startPos;
          return '&';
        }

        return entity;
      }

      jsxReadWord() {
        let ch;
        const start = this.state.pos;

        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);

        return this.finishToken(
          types.jsxName,
          this.input.slice(start, this.state.pos),
        );
      }

      jsxParseIdentifier() {
        const node = this.startNode();

        if (this.match(types.jsxName)) {
          node.name = this.state.value;
        } else if (this.state.type.keyword) {
          node.name = this.state.type.keyword;
        } else {
          this.unexpected();
        }

        this.next();
        return this.finishNode(node, 'JSXIdentifier');
      }

      jsxParseNamespacedName() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        if (!this.eat(types.colon)) return name;
        const node = this.startNodeAt(startPos, startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, 'JSXNamespacedName');
      }

      jsxParseElementName() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();

        if (node.type === 'JSXNamespacedName') {
          return node;
        }

        while (this.eat(types.dot)) {
          const newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, 'JSXMemberExpression');
        }

        return node;
      }

      jsxParseAttributeValue() {
        let node;

        switch (this.state.type) {
          case types.braceL:
            node = this.startNode();
            this.next();
            node = this.jsxParseExpressionContainer(node);

            if (node.expression.type === 'JSXEmptyExpression') {
              this.raise(node.start, JsxErrors.AttributeIsEmpty);
            }

            return node;

          case types.jsxTagStart:
          case types.string:
            return this.parseExprAtom();

          default:
            throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
        }
      }

      jsxParseEmptyExpression() {
        const node = this.startNodeAt(
          this.state.lastTokEnd,
          this.state.lastTokEndLoc,
        );
        return this.finishNodeAt(
          node,
          'JSXEmptyExpression',
          this.state.start,
          this.state.startLoc,
        );
      }

      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.expect(types.braceR);
        return this.finishNode(node, 'JSXSpreadChild');
      }

      jsxParseExpressionContainer(node) {
        if (this.match(types.braceR)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }

        this.expect(types.braceR);
        return this.finishNode(node, 'JSXExpressionContainer');
      }

      jsxParseAttribute() {
        const node = this.startNode();

        if (this.eat(types.braceL)) {
          this.expect(types.ellipsis);
          node.argument = this.parseMaybeAssignAllowIn();
          this.expect(types.braceR);
          return this.finishNode(node, 'JSXSpreadAttribute');
        }

        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, 'JSXAttribute');
      }

      jsxParseOpeningElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);

        if (this.match(types.jsxTagEnd)) {
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, 'JSXOpeningFragment');
        }

        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }

      jsxParseOpeningElementAfterName(node) {
        const attributes = [];

        while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
          attributes.push(this.jsxParseAttribute());
        }

        node.attributes = attributes;
        node.selfClosing = this.eat(types.slash);
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, 'JSXOpeningElement');
      }

      jsxParseClosingElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);

        if (this.match(types.jsxTagEnd)) {
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, 'JSXClosingFragment');
        }

        node.name = this.jsxParseElementName();
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, 'JSXClosingElement');
      }

      jsxParseElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(
          startPos,
          startLoc,
        );
        let closingElement = null;

        if (!openingElement.selfClosing) {
          contents: for (;;) {
            switch (this.state.type) {
              case types.jsxTagStart:
                startPos = this.state.start;
                startLoc = this.state.startLoc;
                this.next();

                if (this.eat(types.slash)) {
                  closingElement = this.jsxParseClosingElementAt(
                    startPos,
                    startLoc,
                  );
                  break contents;
                }

                children.push(this.jsxParseElementAt(startPos, startLoc));
                break;

              case types.jsxText:
                children.push(this.parseExprAtom());
                break;

              case types.braceL: {
                const node = this.startNode();
                this.next();

                if (this.match(types.ellipsis)) {
                  children.push(this.jsxParseSpreadChild(node));
                } else {
                  children.push(this.jsxParseExpressionContainer(node));
                }

                break;
              }

              default:
                throw this.unexpected();
            }
          }

          if (isFragment(openingElement) && !isFragment(closingElement)) {
            this.raise(
              closingElement.start,
              JsxErrors.MissingClosingTagFragment,
            );
          } else if (
            !isFragment(openingElement) &&
            isFragment(closingElement)
          ) {
            this.raise(
              closingElement.start,
              JsxErrors.MissingClosingTagElement,
              getQualifiedJSXName(openingElement.name),
            );
          } else if (
            !isFragment(openingElement) &&
            !isFragment(closingElement)
          ) {
            if (
              getQualifiedJSXName(closingElement.name) !==
              getQualifiedJSXName(openingElement.name)
            ) {
              this.raise(
                closingElement.start,
                JsxErrors.MissingClosingTagElement,
                getQualifiedJSXName(openingElement.name),
              );
            }
          }
        }

        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }

        node.children = children;

        if (this.isRelational('<')) {
          throw this.raise(
            this.state.start,
            JsxErrors.UnwrappedAdjacentJSXElements,
          );
        }

        return isFragment(openingElement)
          ? this.finishNode(node, 'JSXFragment')
          : this.finishNode(node, 'JSXElement');
      }

      jsxParseElement() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startPos, startLoc);
      }

      parseExprAtom(refExpressionErrors) {
        if (this.match(types.jsxText)) {
          return this.parseLiteral(this.state.value, 'JSXText');
        } else if (this.match(types.jsxTagStart)) {
          return this.jsxParseElement();
        } else if (
          this.isRelational('<') &&
          this.input.charCodeAt(this.state.pos) !== 33
        ) {
          this.finishToken(types.jsxTagStart);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }

      getTokenFromCode(code) {
        if (this.state.inPropertyName) return super.getTokenFromCode(code);
        const context = this.curContext();

        if (context === types$1.j_expr) {
          return this.jsxReadToken();
        }

        if (context === types$1.j_oTag || context === types$1.j_cTag) {
          if (isIdentifierStart(code)) {
            return this.jsxReadWord();
          }

          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagEnd);
          }

          if ((code === 34 || code === 39) && context === types$1.j_oTag) {
            return this.jsxReadString(code);
          }
        }

        if (
          code === 60 &&
          this.state.exprAllowed &&
          this.input.charCodeAt(this.state.pos + 1) !== 33
        ) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagStart);
        }

        return super.getTokenFromCode(code);
      }

      updateContext(prevType) {
        if (this.match(types.braceL)) {
          const curContext = this.curContext();

          if (curContext === types$1.j_oTag) {
            this.state.context.push(types$1.braceExpression);
          } else if (curContext === types$1.j_expr) {
            this.state.context.push(types$1.templateQuasi);
          } else {
            super.updateContext(prevType);
          }

          this.state.exprAllowed = true;
        } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
          this.state.context.length -= 2;
          this.state.context.push(types$1.j_cTag);
          this.state.exprAllowed = false;
        } else {
          return super.updateContext(prevType);
        }
      }
    };

  class TypeScriptScope extends Scope {
    constructor(...args) {
      super(...args);
      this.types = [];
      this.enums = [];
      this.constEnums = [];
      this.classes = [];
      this.exportOnlyBindings = [];
    }
  }

  class TypeScriptScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new TypeScriptScope(flags);
    }

    declareName(name, bindingType, pos) {
      const scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.push(name);
        return;
      }

      super.declareName(...arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.push(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);
    }

    isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.indexOf(name) > -1) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          const wasConst = scope.constEnums.indexOf(name) > -1;
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {
        if (scope.lexical.indexOf(name) > -1) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {
        return true;
      }

      return super.isRedeclaredInScope(...arguments);
    }

    checkLocalExport(id) {
      if (
        this.scopeStack[0].types.indexOf(id.name) === -1 &&
        this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1
      ) {
        super.checkLocalExport(id);
      }
    }
  }

  const PARAM = 0b0000,
    PARAM_YIELD = 0b0001,
    PARAM_AWAIT = 0b0010,
    PARAM_RETURN = 0b0100,
    PARAM_IN = 0b1000;

  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }

    enter(flags) {
      this.stacks.push(flags);
    }

    exit() {
      this.stacks.pop();
    }

    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }

    get hasAwait() {
      return (this.currentFlags() & PARAM_AWAIT) > 0;
    }

    get hasYield() {
      return (this.currentFlags() & PARAM_YIELD) > 0;
    }

    get hasReturn() {
      return (this.currentFlags() & PARAM_RETURN) > 0;
    }

    get hasIn() {
      return (this.currentFlags() & PARAM_IN) > 0;
    }
  }

  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
  }

  function nonNull(x) {
    if (x == null) {
      throw new Error(`Unexpected ${x} value.`);
    }

    return x;
  }

  function assert(x) {
    if (!x) {
      throw new Error('Assert fail');
    }
  }

  const TSErrors = Object.freeze({
    AbstractMethodHasImplementation:
      "Method '%0' cannot have an implementation because it is marked abstract.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
    ConstructorHasTypeParameters:
      'Type parameters cannot appear on a constructor declaration.',
    DeclareAccessor: "'declare' is not allowed in %0ters.",
    DeclareClassFieldHasInitializer:
      'Initializers are not allowed in ambient contexts.',
    DeclareFunctionHasImplementation:
      'An implementation cannot be declared in ambient contexts.',
    DuplicateAccessibilityModifier: 'Accessibility modifier already seen.',
    DuplicateModifier: "Duplicate modifier: '%0'",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    EmptyTypeArguments: 'Type argument list cannot be empty.',
    EmptyTypeParameters: 'Type parameter list cannot be empty.',
    ExpectedAmbientAfterExportDeclare:
      "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'",
    IndexSignatureHasAbstract:
      "Index signatures cannot have the 'abstract' modifier",
    IndexSignatureHasAccessibility:
      "Index signatures cannot have an accessibility modifier ('%0')",
    IndexSignatureHasDeclare:
      "Index signatures cannot have the 'declare' modifier",
    IndexSignatureHasStatic:
      "Index signatures cannot have the 'static' modifier",
    InvalidModifierOnTypeMember:
      "'%0' modifier cannot appear on a type member.",
    InvalidTupleMemberLabel:
      'Tuple members must be labeled with a simple identifier.',
    MixedLabeledAndUnlabeledElements:
      'Tuple members must all have names or all not have names.',
    NonAbstractClassHasAbstractMethod:
      'Abstract methods can only appear within an abstract class.',
    NonClassMethodPropertyHasAbstractModifer:
      "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired:
      'A required element cannot follow an optional element.',
    PatternIsOptional:
      'A binding pattern parameter cannot be optional in an implementation signature.',
    PrivateElementHasAbstract:
      "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility:
      "Private elements cannot have an accessibility modifier ('%0')",
    ReadonlyForMethodSignature:
      "'readonly' modifier can only appear on a property declaration or index signature.",
    TypeAnnotationAfterAssign:
      'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`',
    UnexpectedParameterModifier:
      'A parameter property is only allowed in a constructor implementation.',
    UnexpectedReadonly:
      "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: 'Did not expect a type annotation here.',
    UnexpectedTypeCastInParameter:
      'Unexpected type cast in parameter position.',
    UnsupportedImportTypeArgument:
      'Argument in a type import must be a string literal',
    UnsupportedParameterPropertyKind:
      'A parameter property may not be declared using a binding pattern.',
    UnsupportedSignatureParameterKind:
      'Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0',
  });

  function keywordTypeFromName(value) {
    switch (value) {
      case 'any':
        return 'TSAnyKeyword';

      case 'boolean':
        return 'TSBooleanKeyword';

      case 'bigint':
        return 'TSBigIntKeyword';

      case 'never':
        return 'TSNeverKeyword';

      case 'number':
        return 'TSNumberKeyword';

      case 'object':
        return 'TSObjectKeyword';

      case 'string':
        return 'TSStringKeyword';

      case 'symbol':
        return 'TSSymbolKeyword';

      case 'undefined':
        return 'TSUndefinedKeyword';

      case 'unknown':
        return 'TSUnknownKeyword';

      default:
        return undefined;
    }
  }

  function tsIsAccessModifier(modifier) {
    return (
      modifier === 'private' ||
      modifier === 'public' ||
      modifier === 'protected'
    );
  }

  var typescript = (superClass) =>
    class extends superClass {
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }

      tsIsIdentifier() {
        return this.match(types.name);
      }

      tsNextTokenCanFollowModifier() {
        this.next();
        return (
          (this.match(types.bracketL) ||
            this.match(types.braceL) ||
            this.match(types.star) ||
            this.match(types.ellipsis) ||
            this.match(types.hash) ||
            this.isLiteralPropertyName()) &&
          !this.hasPrecedingLineBreak()
        );
      }

      tsParseModifier(allowedModifiers) {
        if (!this.match(types.name)) {
          return undefined;
        }

        const modifier = this.state.value;

        if (
          allowedModifiers.indexOf(modifier) !== -1 &&
          this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))
        ) {
          return modifier;
        }

        return undefined;
      }

      tsParseModifiers(
        modified,
        allowedModifiers,
        disallowedModifiers,
        errorTemplate,
      ) {
        for (;;) {
          const startPos = this.state.start;
          const modifier = this.tsParseModifier(
            allowedModifiers.concat(
              disallowedModifiers != null ? disallowedModifiers : [],
            ),
          );
          if (!modifier) break;

          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
            } else {
              modified.accessibility = modifier;
            }
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(startPos, TSErrors.DuplicateModifier, modifier);
            }

            modified[modifier] = true;
          }

          if (
            disallowedModifiers != null &&
            disallowedModifiers.includes(modifier)
          ) {
            this.raise(startPos, errorTemplate, modifier);
          }
        }
      }

      tsIsListTerminator(kind) {
        switch (kind) {
          case 'EnumMembers':
          case 'TypeMembers':
            return this.match(types.braceR);

          case 'HeritageClauseElement':
            return this.match(types.braceL);

          case 'TupleElementTypes':
            return this.match(types.bracketR);

          case 'TypeParametersOrArguments':
            return this.isRelational('>');
        }

        throw new Error('Unreachable');
      }

      tsParseList(kind, parseElement) {
        const result = [];

        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }

        return result;
      }

      tsParseDelimitedList(kind, parseElement) {
        return nonNull(
          this.tsParseDelimitedListWorker(kind, parseElement, true),
        );
      }

      tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
        const result = [];

        for (;;) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }

          const element = parseElement();

          if (element == null) {
            return undefined;
          }

          result.push(element);

          if (this.eat(types.comma)) {
            continue;
          }

          if (this.tsIsListTerminator(kind)) {
            break;
          }

          if (expectSuccess) {
            this.expect(types.comma);
          }

          return undefined;
        }

        return result;
      }

      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(types.bracketL);
          } else {
            this.expectRelational('<');
          }
        }

        const result = this.tsParseDelimitedList(kind, parseElement);

        if (bracket) {
          this.expect(types.bracketR);
        } else {
          this.expectRelational('>');
        }

        return result;
      }

      tsParseImportType() {
        const node = this.startNode();
        this.expect(types._import);
        this.expect(types.parenL);

        if (!this.match(types.string)) {
          this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
        }

        node.argument = this.parseExprAtom();
        this.expect(types.parenR);

        if (this.eat(types.dot)) {
          node.qualifier = this.tsParseEntityName(true);
        }

        if (this.isRelational('<')) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, 'TSImportType');
      }

      tsParseEntityName(allowReservedWords) {
        let entity = this.parseIdentifier();

        while (this.eat(types.dot)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, 'TSQualifiedName');
        }

        return entity;
      }

      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName(false);

        if (!this.hasPrecedingLineBreak() && this.isRelational('<')) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, 'TSTypeReference');
      }

      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, 'TSTypePredicate');
      }

      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, 'TSThisType');
      }

      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(types._typeof);

        if (this.match(types._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName(true);
        }

        return this.finishNode(node, 'TSTypeQuery');
      }

      tsParseTypeParameter() {
        const node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsEatThenParseType(types._extends);
        node.default = this.tsEatThenParseType(types.eq);
        return this.finishNode(node, 'TSTypeParameter');
      }

      tsTryParseTypeParameters() {
        if (this.isRelational('<')) {
          return this.tsParseTypeParameters();
        }
      }

      tsParseTypeParameters() {
        const node = this.startNode();

        if (this.isRelational('<') || this.match(types.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        node.params = this.tsParseBracketedList(
          'TypeParametersOrArguments',
          this.tsParseTypeParameter.bind(this),
          false,
          true,
        );

        if (node.params.length === 0) {
          this.raise(node.start, TSErrors.EmptyTypeParameters);
        }

        return this.finishNode(node, 'TSTypeParameterDeclaration');
      }

      tsTryNextParseConstantContext() {
        if (this.lookahead().type === types._const) {
          this.next();
          return this.tsParseTypeReference();
        }

        return null;
      }

      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === types.arrow;
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(types.parenL);
        signature.parameters = this.tsParseBindingListForSignature();

        if (returnTokenRequired) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(
            returnToken,
          );
        } else if (this.match(returnToken)) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(
            returnToken,
          );
        }
      }

      tsParseBindingListForSignature() {
        return this.parseBindingList(types.parenR, 41).map((pattern) => {
          if (
            pattern.type !== 'Identifier' &&
            pattern.type !== 'RestElement' &&
            pattern.type !== 'ObjectPattern' &&
            pattern.type !== 'ArrayPattern'
          ) {
            this.raise(
              pattern.start,
              TSErrors.UnsupportedSignatureParameterKind,
              pattern.type,
            );
          }

          return pattern;
        });
      }

      tsParseTypeMemberSemicolon() {
        if (!this.eat(types.comma)) {
          this.semicolon();
        }
      }

      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(types.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }

      tsIsUnambiguouslyIndexSignature() {
        this.next();
        return this.eat(types.name) && this.match(types.colon);
      }

      tsTryParseIndexSignature(node) {
        if (
          !(
            this.match(types.bracketL) &&
            this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))
          )
        ) {
          return undefined;
        }

        this.expect(types.bracketL);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(types.bracketR);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, 'TSIndexSignature');
      }

      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(types.question)) node.optional = true;
        const nodeAny = node;

        if (this.match(types.parenL) || this.isRelational('<')) {
          if (readonly) {
            this.raise(node.start, TSErrors.ReadonlyForMethodSignature);
          }

          const method = nodeAny;
          this.tsFillSignature(types.colon, method);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(method, 'TSMethodSignature');
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, 'TSPropertySignature');
        }
      }

      tsParseTypeMember() {
        const node = this.startNode();

        if (this.match(types.parenL) || this.isRelational('<')) {
          return this.tsParseSignatureMember(
            'TSCallSignatureDeclaration',
            node,
          );
        }

        if (this.match(types._new)) {
          const id = this.startNode();
          this.next();

          if (this.match(types.parenL) || this.isRelational('<')) {
            return this.tsParseSignatureMember(
              'TSConstructSignatureDeclaration',
              node,
            );
          } else {
            node.key = this.createIdentifier(id, 'new');
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }

        this.tsParseModifiers(
          node,
          ['readonly'],
          ['declare', 'abstract', 'private', 'protected', 'public', 'static'],
          TSErrors.InvalidModifierOnTypeMember,
        );
        const idx = this.tsTryParseIndexSignature(node);

        if (idx) {
          return idx;
        }

        this.parsePropertyName(node, false);
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }

      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, 'TSTypeLiteral');
      }

      tsParseObjectTypeMembers() {
        this.expect(types.braceL);
        const members = this.tsParseList(
          'TypeMembers',
          this.tsParseTypeMember.bind(this),
        );
        this.expect(types.braceR);
        return members;
      }

      tsIsStartOfMappedType() {
        this.next();

        if (this.eat(types.plusMin)) {
          return this.isContextual('readonly');
        }

        if (this.isContextual('readonly')) {
          this.next();
        }

        if (!this.match(types.bracketL)) {
          return false;
        }

        this.next();

        if (!this.tsIsIdentifier()) {
          return false;
        }

        this.next();
        return this.match(types._in);
      }

      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsExpectThenParseType(types._in);
        return this.finishNode(node, 'TSTypeParameter');
      }

      tsParseMappedType() {
        const node = this.startNode();
        this.expect(types.braceL);

        if (this.match(types.plusMin)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual('readonly');
        } else if (this.eatContextual('readonly')) {
          node.readonly = true;
        }

        this.expect(types.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual('as') ? this.tsParseType() : null;
        this.expect(types.bracketR);

        if (this.match(types.plusMin)) {
          node.optional = this.state.value;
          this.next();
          this.expect(types.question);
        } else if (this.eat(types.question)) {
          node.optional = true;
        }

        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(types.braceR);
        return this.finishNode(node, 'TSMappedType');
      }

      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList(
          'TupleElementTypes',
          this.tsParseTupleElementType.bind(this),
          true,
          false,
        );
        let seenOptionalElement = false;
        let labeledElements = null;
        node.elementTypes.forEach((elementNode) => {
          var _labeledElements;

          let {type} = elementNode;

          if (
            seenOptionalElement &&
            type !== 'TSRestType' &&
            type !== 'TSOptionalType' &&
            !(type === 'TSNamedTupleMember' && elementNode.optional)
          ) {
            this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
          }

          seenOptionalElement =
            seenOptionalElement ||
            (type === 'TSNamedTupleMember' && elementNode.optional) ||
            type === 'TSOptionalType';

          if (type === 'TSRestType') {
            elementNode = elementNode.typeAnnotation;
            type = elementNode.type;
          }

          const isLabeled = type === 'TSNamedTupleMember';
          labeledElements =
            (_labeledElements = labeledElements) != null
              ? _labeledElements
              : isLabeled;

          if (labeledElements !== isLabeled) {
            this.raise(
              elementNode.start,
              TSErrors.MixedLabeledAndUnlabeledElements,
            );
          }
        });
        return this.finishNode(node, 'TSTupleType');
      }

      tsParseTupleElementType() {
        const {start: startPos, startLoc} = this.state;
        const rest = this.eat(types.ellipsis);
        let type = this.tsParseType();
        const optional = this.eat(types.question);
        const labeled = this.eat(types.colon);

        if (labeled) {
          const labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;

          if (
            type.type === 'TSTypeReference' &&
            !type.typeParameters &&
            type.typeName.type === 'Identifier'
          ) {
            labeledNode.label = type.typeName;
          } else {
            this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
            labeledNode.label = type;
          }

          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, 'TSNamedTupleMember');
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, 'TSOptionalType');
        }

        if (rest) {
          const restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, 'TSRestType');
        }

        return type;
      }

      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(types.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(types.parenR);
        return this.finishNode(node, 'TSParenthesizedType');
      }

      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();

        if (type === 'TSConstructorType') {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }

        this.tsFillSignature(types.arrow, node);
        return this.finishNode(node, type);
      }

      tsParseLiteralTypeNode() {
        const node = this.startNode();

        node.literal = (() => {
          switch (this.state.type) {
            case types.num:
            case types.bigint:
            case types.string:
            case types._true:
            case types._false:
              return this.parseExprAtom();

            default:
              throw this.unexpected();
          }
        })();

        return this.finishNode(node, 'TSLiteralType');
      }

      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = this.parseTemplate(false);
        return this.finishNode(node, 'TSLiteralType');
      }

      parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return super.parseTemplateSubstitution();
      }

      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();

        if (this.isContextual('is') && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }

      tsParseNonArrayType() {
        switch (this.state.type) {
          case types.name:
          case types._void:
          case types._null: {
            const type = this.match(types._void)
              ? 'TSVoidKeyword'
              : this.match(types._null)
              ? 'TSNullKeyword'
              : keywordTypeFromName(this.state.value);

            if (type !== undefined && this.lookaheadCharCode() !== 46) {
              const node = this.startNode();
              this.next();
              return this.finishNode(node, type);
            }

            return this.tsParseTypeReference();
          }

          case types.string:
          case types.num:
          case types.bigint:
          case types._true:
          case types._false:
            return this.tsParseLiteralTypeNode();

          case types.plusMin:
            if (this.state.value === '-') {
              const node = this.startNode();
              const nextToken = this.lookahead();

              if (
                nextToken.type !== types.num &&
                nextToken.type !== types.bigint
              ) {
                throw this.unexpected();
              }

              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, 'TSLiteralType');
            }

            break;

          case types._this:
            return this.tsParseThisTypeOrThisTypePredicate();

          case types._typeof:
            return this.tsParseTypeQuery();

          case types._import:
            return this.tsParseImportType();

          case types.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
              ? this.tsParseMappedType()
              : this.tsParseTypeLiteral();

          case types.bracketL:
            return this.tsParseTupleType();

          case types.parenL:
            return this.tsParseParenthesizedType();

          case types.backQuote:
            return this.tsParseTemplateLiteralType();
        }

        throw this.unexpected();
      }

      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();

        while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
          if (this.match(types.bracketR)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(types.bracketR);
            type = this.finishNode(node, 'TSArrayType');
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(types.bracketR);
            type = this.finishNode(node, 'TSIndexedAccessType');
          }
        }

        return type;
      }

      tsParseTypeOperator(operator) {
        const node = this.startNode();
        this.expectContextual(operator);
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

        if (operator === 'readonly') {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }

        return this.finishNode(node, 'TSTypeOperator');
      }

      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case 'TSTupleType':
          case 'TSArrayType':
            return;

          default:
            this.raise(node.start, TSErrors.UnexpectedReadonly);
        }
      }

      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual('infer');
        const typeParameter = this.startNode();
        typeParameter.name = this.parseIdentifierName(typeParameter.start);
        node.typeParameter = this.finishNode(typeParameter, 'TSTypeParameter');
        return this.finishNode(node, 'TSInferType');
      }

      tsParseTypeOperatorOrHigher() {
        const operator = ['keyof', 'unique', 'readonly'].find((kw) =>
          this.isContextual(kw),
        );
        return operator
          ? this.tsParseTypeOperator(operator)
          : this.isContextual('infer')
          ? this.tsParseInferType()
          : this.tsParseArrayTypeOrHigher();
      }

      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types = [];

        do {
          types.push(parseConstituentType());
        } while (this.eat(operator));

        if (types.length === 1 && !hasLeadingOperator) {
          return types[0];
        }

        node.types = types;
        return this.finishNode(node, kind);
      }

      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          'TSIntersectionType',
          this.tsParseTypeOperatorOrHigher.bind(this),
          types.bitwiseAND,
        );
      }

      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          'TSUnionType',
          this.tsParseIntersectionTypeOrHigher.bind(this),
          types.bitwiseOR,
        );
      }

      tsIsStartOfFunctionType() {
        if (this.isRelational('<')) {
          return true;
        }

        return (
          this.match(types.parenL) &&
          this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))
        );
      }

      tsSkipParameterStart() {
        if (this.match(types.name) || this.match(types._this)) {
          this.next();
          return true;
        }

        if (this.match(types.braceL)) {
          let braceStackCounter = 1;
          this.next();

          while (braceStackCounter > 0) {
            if (this.match(types.braceL)) {
              ++braceStackCounter;
            } else if (this.match(types.braceR)) {
              --braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        if (this.match(types.bracketL)) {
          let braceStackCounter = 1;
          this.next();

          while (braceStackCounter > 0) {
            if (this.match(types.bracketL)) {
              ++braceStackCounter;
            } else if (this.match(types.bracketR)) {
              --braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        return false;
      }

      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();

        if (this.match(types.parenR) || this.match(types.ellipsis)) {
          return true;
        }

        if (this.tsSkipParameterStart()) {
          if (
            this.match(types.colon) ||
            this.match(types.comma) ||
            this.match(types.question) ||
            this.match(types.eq)
          ) {
            return true;
          }

          if (this.match(types.parenR)) {
            this.next();

            if (this.match(types.arrow)) {
              return true;
            }
          }
        }

        return false;
      }

      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(
            this.tsParseTypePredicateAsserts.bind(this),
          );

          if (asserts && this.match(types._this)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();

            if (thisTypePredicate.type === 'TSThisType') {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              thisTypePredicate = this.finishNode(node, 'TSTypePredicate');
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }

            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, 'TSTypeAnnotation');
          }

          const typePredicateVariable =
            this.tsIsIdentifier() &&
            this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));

          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t);
            }

            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            t.typeAnnotation = this.finishNode(node, 'TSTypePredicate');
            return this.finishNode(t, 'TSTypeAnnotation');
          }

          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, 'TSTypePredicate');
          return this.finishNode(t, 'TSTypeAnnotation');
        });
      }

      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(types.colon)
          ? this.tsParseTypeOrTypePredicateAnnotation(types.colon)
          : undefined;
      }

      tsTryParseTypeAnnotation() {
        return this.match(types.colon)
          ? this.tsParseTypeAnnotation()
          : undefined;
      }

      tsTryParseType() {
        return this.tsEatThenParseType(types.colon);
      }

      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();

        if (this.isContextual('is') && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }

      tsParseTypePredicateAsserts() {
        if (
          !this.match(types.name) ||
          this.state.value !== 'asserts' ||
          this.hasPrecedingLineBreak()
        ) {
          return false;
        }

        const containsEsc = this.state.containsEsc;
        this.next();

        if (!this.match(types.name) && !this.match(types._this)) {
          return false;
        }

        if (containsEsc) {
          this.raise(
            this.state.lastTokStart,
            ErrorMessages.InvalidEscapedReservedWord,
            'asserts',
          );
        }

        return true;
      }

      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(types.colon);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, 'TSTypeAnnotation');
      }

      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();

        if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
          return type;
        }

        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsParseNonConditionalType();
        this.expect(types.question);
        node.trueType = this.tsParseType();
        this.expect(types.colon);
        node.falseType = this.tsParseType();
        return this.finishNode(node, 'TSConditionalType');
      }

      isAbstractConstructorSignature() {
        return (
          this.isContextual('abstract') && this.lookahead().type === types._new
        );
      }

      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType('TSFunctionType');
        }

        if (this.match(types._new)) {
          return this.tsParseFunctionOrConstructorType('TSConstructorType');
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType(
            'TSConstructorType',
            true,
          );
        }

        return this.tsParseUnionTypeOrHigher();
      }

      tsParseTypeAssertion() {
        const node = this.startNode();

        const _const = this.tsTryNextParseConstantContext();

        node.typeAnnotation = _const || this.tsNextThenParseType();
        this.expectRelational('>');
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, 'TSTypeAssertion');
      }

      tsParseHeritageClause(descriptor) {
        const originalStart = this.state.start;
        const delimitedList = this.tsParseDelimitedList(
          'HeritageClauseElement',
          this.tsParseExpressionWithTypeArguments.bind(this),
        );

        if (!delimitedList.length) {
          this.raise(
            originalStart,
            TSErrors.EmptyHeritageClauseType,
            descriptor,
          );
        }

        return delimitedList;
      }

      tsParseExpressionWithTypeArguments() {
        const node = this.startNode();
        node.expression = this.tsParseEntityName(false);

        if (this.isRelational('<')) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, 'TSExpressionWithTypeArguments');
      }

      tsParseInterfaceDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(
          node.id,
          'typescript interface declaration',
          BIND_TS_INTERFACE,
        );
        node.typeParameters = this.tsTryParseTypeParameters();

        if (this.eat(types._extends)) {
          node.extends = this.tsParseHeritageClause('extends');
        }

        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, 'TSInterfaceBody');
        return this.finishNode(node, 'TSInterfaceDeclaration');
      }

      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, 'typescript type alias', BIND_TS_TYPE);
        node.typeParameters = this.tsTryParseTypeParameters();
        node.typeAnnotation = this.tsInType(() => {
          this.expect(types.eq);

          if (
            this.isContextual('intrinsic') &&
            this.lookahead().type !== types.dot
          ) {
            const node = this.startNode();
            this.next();
            return this.finishNode(node, 'TSIntrinsicKeyword');
          }

          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, 'TSTypeAliasDeclaration');
      }

      tsInNoContext(cb) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];

        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }

      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;

        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }

      tsEatThenParseType(token) {
        return !this.match(token) ? undefined : this.tsNextThenParseType();
      }

      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }

      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }

      tsDoThenParseType(cb) {
        return this.tsInType(() => {
          cb();
          return this.tsParseType();
        });
      }

      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(types.string)
          ? this.parseExprAtom()
          : this.parseIdentifier(true);

        if (this.eat(types.eq)) {
          node.initializer = this.parseMaybeAssignAllowIn();
        }

        return this.finishNode(node, 'TSEnumMember');
      }

      tsParseEnumDeclaration(node, isConst) {
        if (isConst) node.const = true;
        node.id = this.parseIdentifier();
        this.checkLVal(
          node.id,
          'typescript enum declaration',
          isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM,
        );
        this.expect(types.braceL);
        node.members = this.tsParseDelimitedList(
          'EnumMembers',
          this.tsParseEnumMember.bind(this),
        );
        this.expect(types.braceR);
        return this.finishNode(node, 'TSEnumDeclaration');
      }

      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(SCOPE_OTHER);
        this.expect(types.braceL);
        this.parseBlockOrModuleBlockBody(
          (node.body = []),
          undefined,
          true,
          types.braceR,
        );
        this.scope.exit();
        return this.finishNode(node, 'TSModuleBlock');
      }

      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();

        if (!nested) {
          this.checkLVal(
            node.id,
            'module or namespace declaration',
            BIND_TS_NAMESPACE,
          );
        }

        if (this.eat(types.dot)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }

        return this.finishNode(node, 'TSModuleDeclaration');
      }

      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual('global')) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(types.string)) {
          node.id = this.parseExprAtom();
        } else {
          this.unexpected();
        }

        if (this.match(types.braceL)) {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }

        return this.finishNode(node, 'TSModuleDeclaration');
      }

      tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, 'import equals declaration', BIND_LEXICAL);
        this.expect(types.eq);
        const moduleReference = this.tsParseModuleReference();

        if (
          node.importKind === 'type' &&
          moduleReference.type !== 'TSExternalModuleReference'
        ) {
          this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
        }

        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, 'TSImportEqualsDeclaration');
      }

      tsIsExternalModuleReference() {
        return this.isContextual('require') && this.lookaheadCharCode() === 40;
      }

      tsParseModuleReference() {
        return this.tsIsExternalModuleReference()
          ? this.tsParseExternalModuleReference()
          : this.tsParseEntityName(false);
      }

      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual('require');
        this.expect(types.parenL);

        if (!this.match(types.string)) {
          throw this.unexpected();
        }

        node.expression = this.parseExprAtom();
        this.expect(types.parenR);
        return this.finishNode(node, 'TSExternalModuleReference');
      }

      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }

      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node) return undefined;
        if (result.error) this.state = result.failState;
        return result.node;
      }

      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();

        if (result !== undefined && result !== false) {
          return result;
        } else {
          this.state = state;
          return undefined;
        }
      }

      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }

        let starttype = this.state.type;
        let kind;

        if (this.isContextual('let')) {
          starttype = types._var;
          kind = 'let';
        }

        return this.tsInDeclareContext(() => {
          switch (starttype) {
            case types._function:
              nany.declare = true;
              return this.parseFunctionStatement(nany, false, true);

            case types._class:
              nany.declare = true;
              return this.parseClass(nany, true, false);

            case types._const:
              if (
                this.match(types._const) &&
                this.isLookaheadContextual('enum')
              ) {
                this.expect(types._const);
                this.expectContextual('enum');
                return this.tsParseEnumDeclaration(nany, true);
              }

            case types._var:
              kind = kind || this.state.value;
              return this.parseVarStatement(nany, kind);

            case types.name: {
              const value = this.state.value;

              if (value === 'global') {
                return this.tsParseAmbientExternalModuleDeclaration(nany);
              } else {
                return this.tsParseDeclaration(nany, value, true);
              }
            }
          }
        });
      }

      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(
          this.startNode(),
          this.state.value,
          true,
        );
      }

      tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case 'declare': {
            const declaration = this.tsTryParseDeclare(node);

            if (declaration) {
              declaration.declare = true;
              return declaration;
            }

            break;
          }

          case 'global':
            if (this.match(types.braceL)) {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, 'TSModuleDeclaration');
            }

            break;

          default:
            return this.tsParseDeclaration(node, expr.name, false);
        }
      }

      tsParseDeclaration(node, value, next) {
        switch (value) {
          case 'abstract':
            if (
              this.tsCheckLineTerminator(next) &&
              (this.match(types._class) || this.match(types.name))
            ) {
              return this.tsParseAbstractDeclaration(node);
            }

            break;

          case 'enum':
            if (next || this.match(types.name)) {
              if (next) this.next();
              return this.tsParseEnumDeclaration(node, false);
            }

            break;

          case 'interface':
            if (this.tsCheckLineTerminator(next) && this.match(types.name)) {
              return this.tsParseInterfaceDeclaration(node);
            }

            break;

          case 'module':
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(types.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (this.match(types.name)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }

            break;

          case 'namespace':
            if (this.tsCheckLineTerminator(next) && this.match(types.name)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }

            break;

          case 'type':
            if (this.tsCheckLineTerminator(next) && this.match(types.name)) {
              return this.tsParseTypeAliasDeclaration(node);
            }

            break;
        }
      }

      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }

        return !this.isLineTerminator();
      }

      tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
        if (!this.isRelational('<')) {
          return undefined;
        }

        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = this.tsParseTypeParameters();
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(types.arrow);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;

        if (!res) {
          return undefined;
        }

        return this.parseArrowExpression(res, null, true);
      }

      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() =>
          this.tsInNoContext(() => {
            this.expectRelational('<');
            return this.tsParseDelimitedList(
              'TypeParametersOrArguments',
              this.tsParseType.bind(this),
            );
          }),
        );

        if (node.params.length === 0) {
          this.raise(node.start, TSErrors.EmptyTypeArguments);
        }

        this.state.exprAllowed = false;
        this.expectRelational('>');
        return this.finishNode(node, 'TSTypeParameterInstantiation');
      }

      tsIsDeclarationStart() {
        if (this.match(types.name)) {
          switch (this.state.value) {
            case 'abstract':
            case 'declare':
            case 'enum':
            case 'interface':
            case 'module':
            case 'namespace':
            case 'type':
              return true;
          }
        }

        return false;
      }

      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return super.isExportDefaultSpecifier();
      }

      parseAssignableListItem(allowModifiers, decorators) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let accessibility;
        let readonly = false;

        if (allowModifiers !== undefined) {
          accessibility = this.parseAccessModifier();
          readonly = !!this.tsParseModifier(['readonly']);

          if (allowModifiers === false && (accessibility || readonly)) {
            this.raise(startPos, TSErrors.UnexpectedParameterModifier);
          }
        }

        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

        if (accessibility || readonly) {
          const pp = this.startNodeAt(startPos, startLoc);

          if (decorators.length) {
            pp.decorators = decorators;
          }

          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;

          if (elt.type !== 'Identifier' && elt.type !== 'AssignmentPattern') {
            this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
          }

          pp.parameter = elt;
          return this.finishNode(pp, 'TSParameterProperty');
        }

        if (decorators.length) {
          left.decorators = decorators;
        }

        return elt;
      }

      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(types.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(
            types.colon,
          );
        }

        const bodilessType =
          type === 'FunctionDeclaration'
            ? 'TSDeclareFunction'
            : type === 'ClassMethod'
            ? 'TSDeclareMethod'
            : undefined;

        if (
          bodilessType &&
          !this.match(types.braceL) &&
          this.isLineTerminator()
        ) {
          this.finishNode(node, bodilessType);
          return;
        }

        if (
          bodilessType === 'TSDeclareFunction' &&
          this.state.isDeclareContext
        ) {
          this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);

          if (node.declare) {
            super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            return;
          }
        }

        super.parseFunctionBodyAndFinish(node, type, isMethod);
      }

      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkLVal(node.id, 'function name', BIND_TS_AMBIENT);
        } else {
          super.registerFunctionStatementId(...arguments);
        }
      }

      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === 'TSTypeCastExpression') {
            this.raise(
              node.typeAnnotation.start,
              TSErrors.UnexpectedTypeAnnotation,
            );
          }
        });
      }

      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }

      parseArrayLike(...args) {
        const node = super.parseArrayLike(...args);

        if (node.type === 'ArrayExpression') {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }

        return node;
      }

      parseSubscript(base, startPos, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
          this.state.exprAllowed = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, 'TSNonNullExpression');
        }

        if (this.isRelational('<')) {
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(
                startPos,
                startLoc,
              );

              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }

            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            const typeArguments = this.tsParseTypeArguments();

            if (typeArguments) {
              if (!noCalls && this.eat(types.parenL)) {
                node.arguments = this.parseCallExpressionArguments(
                  types.parenR,
                  false,
                );
                this.tsCheckForInvalidTypeCasts(node.arguments);
                node.typeParameters = typeArguments;

                if (state.optionalChainMember) {
                  node.optional = false;
                }

                return this.finishCallExpression(
                  node,
                  state.optionalChainMember,
                );
              } else if (this.match(types.backQuote)) {
                const result = this.parseTaggedTemplateExpression(
                  base,
                  startPos,
                  startLoc,
                  state,
                );
                result.typeParameters = typeArguments;
                return result;
              }
            }

            this.unexpected();
          });
          if (result) return result;
        }

        return super.parseSubscript(base, startPos, startLoc, noCalls, state);
      }

      parseNewArguments(node) {
        if (this.isRelational('<')) {
          const typeParameters = this.tsTryParseAndCatch(() => {
            const args = this.tsParseTypeArguments();
            if (!this.match(types.parenL)) this.unexpected();
            return args;
          });

          if (typeParameters) {
            node.typeParameters = typeParameters;
          }
        }

        super.parseNewArguments(node);
      }

      parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
        if (
          nonNull(types._in.binop) > minPrec &&
          !this.hasPrecedingLineBreak() &&
          this.isContextual('as')
        ) {
          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.expression = left;

          const _const = this.tsTryNextParseConstantContext();

          if (_const) {
            node.typeAnnotation = _const;
          } else {
            node.typeAnnotation = this.tsNextThenParseType();
          }

          this.finishNode(node, 'TSAsExpression');
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }

        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
      }

      checkReservedWord(word, startLoc, checkKeywords, isBinding) {}

      checkDuplicateExports() {}

      parseImport(node) {
        node.importKind = 'value';

        if (
          this.match(types.name) ||
          this.match(types.star) ||
          this.match(types.braceL)
        ) {
          let ahead = this.lookahead();

          if (
            this.isContextual('type') &&
            ahead.type !== types.comma &&
            !(ahead.type === types.name && ahead.value === 'from') &&
            ahead.type !== types.eq
          ) {
            node.importKind = 'type';
            this.next();
            ahead = this.lookahead();
          }

          if (this.match(types.name) && ahead.type === types.eq) {
            return this.tsParseImportEqualsDeclaration(node);
          }
        }

        const importNode = super.parseImport(node);

        if (
          importNode.importKind === 'type' &&
          importNode.specifiers.length > 1 &&
          importNode.specifiers[0].type === 'ImportDefaultSpecifier'
        ) {
          this.raise(
            importNode.start,
            'A type-only import can specify a default import or named bindings, but not both.',
          );
        }

        return importNode;
      }

      parseExport(node) {
        if (this.match(types._import)) {
          this.next();

          if (this.isContextual('type') && this.lookaheadCharCode() !== 61) {
            node.importKind = 'type';
            this.next();
          } else {
            node.importKind = 'value';
          }

          return this.tsParseImportEqualsDeclaration(node, true);
        } else if (this.eat(types.eq)) {
          const assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          return this.finishNode(assign, 'TSExportAssignment');
        } else if (this.eatContextual('as')) {
          const decl = node;
          this.expectContextual('namespace');
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, 'TSNamespaceExportDeclaration');
        } else {
          if (
            this.isContextual('type') &&
            this.lookahead().type === types.braceL
          ) {
            this.next();
            node.exportKind = 'type';
          } else {
            node.exportKind = 'value';
          }

          return super.parseExport(node);
        }
      }

      isAbstractClass() {
        return (
          this.isContextual('abstract') &&
          this.lookahead().type === types._class
        );
      }

      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          this.parseClass(cls, true, true);
          return cls;
        }

        if (this.state.value === 'interface') {
          const result = this.tsParseDeclaration(
            this.startNode(),
            this.state.value,
            true,
          );
          if (result) return result;
        }

        return super.parseExportDefaultExpression();
      }

      parseStatementContent(context, topLevel) {
        if (this.state.type === types._const) {
          const ahead = this.lookahead();

          if (ahead.type === types.name && ahead.value === 'enum') {
            const node = this.startNode();
            this.expect(types._const);
            this.expectContextual('enum');
            return this.tsParseEnumDeclaration(node, true);
          }
        }

        return super.parseStatementContent(context, topLevel);
      }

      parseAccessModifier() {
        return this.tsParseModifier(['public', 'protected', 'private']);
      }

      parseClassMember(classBody, member, state) {
        this.tsParseModifiers(member, [
          'declare',
          'private',
          'public',
          'protected',
        ]);

        const callParseClassMember = () => {
          super.parseClassMember(classBody, member, state);
        };

        if (member.declare) {
          this.tsInDeclareContext(callParseClassMember);
        } else {
          callParseClassMember();
        }
      }

      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        this.tsParseModifiers(member, ['abstract', 'readonly', 'declare']);
        const idx = this.tsTryParseIndexSignature(member);

        if (idx) {
          classBody.body.push(idx);

          if (member.abstract) {
            this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
          }

          if (isStatic) {
            this.raise(member.start, TSErrors.IndexSignatureHasStatic);
          }

          if (member.accessibility) {
            this.raise(
              member.start,
              TSErrors.IndexSignatureHasAccessibility,
              member.accessibility,
            );
          }

          if (member.declare) {
            this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
          }

          return;
        }

        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
        }

        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }

      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(types.question);
        if (optional) methodOrProp.optional = true;

        if (methodOrProp.readonly && this.match(types.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
        }

        if (methodOrProp.declare && this.match(types.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
        }
      }

      parseExpressionStatement(node, expr) {
        const decl =
          expr.type === 'Identifier'
            ? this.tsParseExpressionStatement(node, expr)
            : undefined;
        return decl || super.parseExpressionStatement(node, expr);
      }

      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return super.shouldParseExportDeclaration();
      }

      parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
        if (!refNeedsArrowPos || !this.match(types.question)) {
          return super.parseConditional(
            expr,
            startPos,
            startLoc,
            refNeedsArrowPos,
          );
        }

        const result = this.tryParse(() =>
          super.parseConditional(expr, startPos, startLoc),
        );

        if (!result.node) {
          refNeedsArrowPos.start = result.error.pos || this.state.start;
          return expr;
        }

        if (result.error) this.state = result.failState;
        return result.node;
      }

      parseParenItem(node, startPos, startLoc) {
        node = super.parseParenItem(node, startPos, startLoc);

        if (this.eat(types.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, 'TSTypeCastExpression');
        }

        return node;
      }

      parseExportDeclaration(node) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual('declare');

        if (
          isDeclare &&
          (this.isContextual('declare') || !this.shouldParseExportDeclaration())
        ) {
          throw this.raise(
            this.state.start,
            TSErrors.ExpectedAmbientAfterExportDeclare,
          );
        }

        let declaration;

        if (this.match(types.name)) {
          declaration = this.tsTryParseExportDeclaration();
        }

        if (!declaration) {
          declaration = super.parseExportDeclaration(node);
        }

        if (
          declaration &&
          (declaration.type === 'TSInterfaceDeclaration' ||
            declaration.type === 'TSTypeAliasDeclaration' ||
            isDeclare)
        ) {
          node.exportKind = 'type';
        }

        if (declaration && isDeclare) {
          this.resetStartLocation(declaration, startPos, startLoc);
          declaration.declare = true;
        }

        return declaration;
      }

      parseClassId(node, isStatement, optionalId) {
        if ((!isStatement || optionalId) && this.isContextual('implements')) {
          return;
        }

        super.parseClassId(
          node,
          isStatement,
          optionalId,
          node.declare ? BIND_TS_AMBIENT : BIND_CLASS,
        );
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;
      }

      parseClassPropertyAnnotation(node) {
        if (!node.optional && this.eat(types.bang)) {
          node.definite = true;
        }

        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }

      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);

        if (this.state.isDeclareContext && this.match(types.eq)) {
          this.raise(
            this.state.start,
            TSErrors.DeclareClassFieldHasInitializer,
          );
        }

        return super.parseClassProperty(node);
      }

      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(node.start, TSErrors.PrivateElementHasAbstract);
        }

        if (node.accessibility) {
          this.raise(
            node.start,
            TSErrors.PrivateElementHasAccessibility,
            node.accessibility,
          );
        }

        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }

      pushClassMethod(
        classBody,
        method,
        isGenerator,
        isAsync,
        isConstructor,
        allowsDirectSuper,
      ) {
        const typeParameters = this.tsTryParseTypeParameters();

        if (typeParameters && isConstructor) {
          this.raise(
            typeParameters.start,
            TSErrors.ConstructorHasTypeParameters,
          );
        }

        if (
          method.declare &&
          (method.kind === 'get' || method.kind === 'set')
        ) {
          this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
        }

        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassMethod(
          classBody,
          method,
          isGenerator,
          isAsync,
          isConstructor,
          allowsDirectSuper,
        );
      }

      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }

      parseClassSuper(node) {
        super.parseClassSuper(node);

        if (node.superClass && this.isRelational('<')) {
          node.superTypeParameters = this.tsParseTypeArguments();
        }

        if (this.eatContextual('implements')) {
          node.implements = this.tsParseHeritageClause('implements');
        }
      }

      parseObjPropValue(prop, ...args) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) prop.typeParameters = typeParameters;
        super.parseObjPropValue(prop, ...args);
      }

      parseFunctionParams(node, allowModifiers) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node, allowModifiers);
      }

      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);

        if (decl.id.type === 'Identifier' && this.eat(types.bang)) {
          decl.definite = true;
        }

        const type = this.tsTryParseTypeAnnotation();

        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }

      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }

        return super.parseAsyncArrowFromCallExpression(node, call);
      }

      parseMaybeAssign(...args) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;

        let state;
        let jsx;
        let typeCast;

        if (
          this.hasPlugin('jsx') &&
          (this.match(types.jsxTagStart) || this.isRelational('<'))
        ) {
          state = this.state.clone();
          jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);
          if (!jsx.error) return jsx.node;
          const {context} = this.state;

          if (context[context.length - 1] === types$1.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types$1.j_expr) {
            context.length -= 1;
          }
        }

        if (!((_jsx = jsx) != null && _jsx.error) && !this.isRelational('<')) {
          return super.parseMaybeAssign(...args);
        }

        let typeParameters;
        state = state || this.state.clone();
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;

          typeParameters = this.tsParseTypeParameters();
          const expr = super.parseMaybeAssign(...args);

          if (
            expr.type !== 'ArrowFunctionExpression' ||
            ((_expr$extra = expr.extra) != null && _expr$extra.parenthesized)
          ) {
            abort();
          }

          if (
            ((_typeParameters = typeParameters) == null
              ? void 0
              : _typeParameters.params.length) !== 0
          ) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }

          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) return arrow.node;

        if (!jsx) {
          assert(!this.hasPlugin('jsx'));
          typeCast = this.tryParse(
            () => super.parseMaybeAssign(...args),
            state,
          );
          if (!typeCast.error) return typeCast.node;
        }

        if ((_jsx2 = jsx) != null && _jsx2.node) {
          this.state = jsx.failState;
          return jsx.node;
        }

        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }

        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }

        if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
        if (arrow.thrown) throw arrow.error;
        if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
          throw typeCast.error;
        throw (
          ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) ||
          arrow.error ||
          ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error)
        );
      }

      parseMaybeUnary(refExpressionErrors) {
        if (!this.hasPlugin('jsx') && this.isRelational('<')) {
          return this.tsParseTypeAssertion();
        } else {
          return super.parseMaybeUnary(refExpressionErrors);
        }
      }

      parseArrow(node) {
        if (this.match(types.colon)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(
              types.colon,
            );
            if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();
            return returnType;
          });
          if (result.aborted) return;

          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }

        return super.parseArrow(node);
      }

      parseAssignableListItemTypes(param) {
        if (this.eat(types.question)) {
          if (
            param.type !== 'Identifier' &&
            !this.state.isDeclareContext &&
            !this.state.inType
          ) {
            this.raise(param.start, TSErrors.PatternIsOptional);
          }

          param.optional = true;
        }

        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }

      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case 'TSTypeCastExpression':
            return super.toAssignable(this.typeCastToParameter(node), isLHS);

          case 'TSParameterProperty':
            return super.toAssignable(node, isLHS);

          case 'ParenthesizedExpression':
            return this.toAssignableParenthesizedExpression(node, isLHS);

          case 'TSAsExpression':
          case 'TSNonNullExpression':
          case 'TSTypeAssertion':
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;

          default:
            return super.toAssignable(node, isLHS);
        }
      }

      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case 'TSAsExpression':
          case 'TSNonNullExpression':
          case 'TSTypeAssertion':
          case 'ParenthesizedExpression':
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;

          default:
            return super.toAssignable(node, isLHS);
        }
      }

      checkLVal(expr, contextDescription, ...args) {
        var _expr$extra2;

        switch (expr.type) {
          case 'TSTypeCastExpression':
            return;

          case 'TSParameterProperty':
            this.checkLVal(expr.parameter, 'parameter property', ...args);
            return;

          case 'TSAsExpression':
          case 'TSTypeAssertion':
            if (
              !args[0] &&
              contextDescription !== 'parenthesized expression' &&
              !(
                (_expr$extra2 = expr.extra) != null &&
                _expr$extra2.parenthesized
              )
            ) {
              this.raise(
                expr.start,
                ErrorMessages.InvalidLhs,
                contextDescription,
              );
              break;
            }

            this.checkLVal(
              expr.expression,
              'parenthesized expression',
              ...args,
            );
            return;

          case 'TSNonNullExpression':
            this.checkLVal(expr.expression, contextDescription, ...args);
            return;

          default:
            super.checkLVal(expr, contextDescription, ...args);
            return;
        }
      }

      parseBindingAtom() {
        switch (this.state.type) {
          case types._this:
            return this.parseIdentifier(true);

          default:
            return super.parseBindingAtom();
        }
      }

      parseMaybeDecoratorArguments(expr) {
        if (this.isRelational('<')) {
          const typeArguments = this.tsParseTypeArguments();

          if (this.match(types.parenL)) {
            const call = super.parseMaybeDecoratorArguments(expr);
            call.typeParameters = typeArguments;
            return call;
          }

          this.unexpected(this.state.start, types.parenL);
        }

        return super.parseMaybeDecoratorArguments(expr);
      }

      checkCommaAfterRest(close) {
        if (
          this.state.isDeclareContext &&
          this.match(types.comma) &&
          this.lookaheadCharCode() === close
        ) {
          this.next();
        } else {
          super.checkCommaAfterRest(close);
        }
      }

      isClassMethod() {
        return this.isRelational('<') || super.isClassMethod();
      }

      isClassProperty() {
        return (
          this.match(types.bang) ||
          this.match(types.colon) ||
          super.isClassProperty()
        );
      }

      parseMaybeDefault(...args) {
        const node = super.parseMaybeDefault(...args);

        if (
          node.type === 'AssignmentPattern' &&
          node.typeAnnotation &&
          node.right.start < node.typeAnnotation.start
        ) {
          this.raise(
            node.typeAnnotation.start,
            TSErrors.TypeAnnotationAfterAssign,
          );
        }

        return node;
      }

      getTokenFromCode(code) {
        if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types.relational, 1);
        } else {
          return super.getTokenFromCode(code);
        }
      }

      reScan_lt_gt() {
        if (this.match(types.relational)) {
          const code = this.input.charCodeAt(this.state.start);

          if (code === 60 || code === 62) {
            this.state.pos -= 1;
            this.readToken_lt_gt(code);
          }
        }
      }

      toAssignableList(exprList) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if (!expr) continue;

          switch (expr.type) {
            case 'TSTypeCastExpression':
              exprList[i] = this.typeCastToParameter(expr);
              break;

            case 'TSAsExpression':
            case 'TSTypeAssertion':
              if (!this.state.maybeInArrowParameters) {
                exprList[i] = this.typeCastToParameter(expr);
              } else {
                this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
              }

              break;
          }
        }

        return super.toAssignableList(...arguments);
      }

      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(
          node.expression,
          node.typeAnnotation.end,
          node.typeAnnotation.loc.end,
        );
        return node.expression;
      }

      shouldParseArrow() {
        return this.match(types.colon) || super.shouldParseArrow();
      }

      shouldParseAsyncArrow() {
        return this.match(types.colon) || super.shouldParseAsyncArrow();
      }

      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }

      jsxParseOpeningElementAfterName(node) {
        if (this.isRelational('<')) {
          const typeArguments = this.tsTryParseAndCatch(() =>
            this.tsParseTypeArguments(),
          );
          if (typeArguments) node.typeParameters = typeArguments;
        }

        return super.jsxParseOpeningElementAfterName(node);
      }

      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam =
          firstParam &&
          firstParam.type === 'Identifier' &&
          firstParam.name === 'this';
        return hasContextParam ? baseCount + 1 : baseCount;
      }

      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();

        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }

        return param;
      }

      tsInDeclareContext(cb) {
        const oldIsDeclareContext = this.state.isDeclareContext;
        this.state.isDeclareContext = true;

        try {
          return cb();
        } finally {
          this.state.isDeclareContext = oldIsDeclareContext;
        }
      }

      parseClass(node, ...args) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;

        try {
          return super.parseClass(node, ...args);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }

      tsParseAbstractDeclaration(node) {
        if (this.match(types._class)) {
          node.abstract = true;
          return this.parseClass(node, true, false);
        } else if (this.isContextual('interface')) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(
              node.start,
              TSErrors.NonClassMethodPropertyHasAbstractModifer,
            );
            this.next();
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, types._class);
        }
      }

      parseMethod(...args) {
        const method = super.parseMethod(...args);

        if (method.abstract) {
          const hasBody = this.hasPlugin('estree')
            ? !!method.value.body
            : !!method.body;

          if (hasBody) {
            const {key} = method;
            this.raise(
              method.start,
              TSErrors.AbstractMethodHasImplementation,
              key.type === 'Identifier'
                ? key.name
                : `[${this.input.slice(key.start, key.end)}]`,
            );
          }
        }

        return method;
      }
    };

  types.placeholder = new TokenType('%%', {
    startsExpr: true,
  });

  var placeholders = (superClass) =>
    class extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(types.placeholder)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace('Unexpected space in placeholder.');
          node.name = super.parseIdentifier(true);
          this.assertNoSpace('Unexpected space in placeholder.');
          this.expect(types.placeholder);
          return this.finishPlaceholder(node, expectedNode);
        }
      }

      finishPlaceholder(node, expectedNode) {
        const isFinished = !!(node.expectedNode && node.type === 'Placeholder');
        node.expectedNode = expectedNode;
        return isFinished ? node : this.finishNode(node, 'Placeholder');
      }

      getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          return this.finishOp(types.placeholder, 2);
        }

        return super.getTokenFromCode(...arguments);
      }

      parseExprAtom() {
        return (
          this.parsePlaceholder('Expression') ||
          super.parseExprAtom(...arguments)
        );
      }

      parseIdentifier() {
        return (
          this.parsePlaceholder('Identifier') ||
          super.parseIdentifier(...arguments)
        );
      }

      checkReservedWord(word) {
        if (word !== undefined) super.checkReservedWord(...arguments);
      }

      parseBindingAtom() {
        return (
          this.parsePlaceholder('Pattern') ||
          super.parseBindingAtom(...arguments)
        );
      }

      checkLVal(expr) {
        if (expr.type !== 'Placeholder') super.checkLVal(...arguments);
      }

      toAssignable(node) {
        if (
          node &&
          node.type === 'Placeholder' &&
          node.expectedNode === 'Expression'
        ) {
          node.expectedNode = 'Pattern';
          return node;
        }

        return super.toAssignable(...arguments);
      }

      isLet(context) {
        if (super.isLet(context)) {
          return true;
        }

        if (!this.isContextual('let')) {
          return false;
        }

        if (context) return false;
        const nextToken = this.lookahead();

        if (nextToken.type === types.placeholder) {
          return true;
        }

        return false;
      }

      verifyBreakContinue(node) {
        if (node.label && node.label.type === 'Placeholder') return;
        super.verifyBreakContinue(...arguments);
      }

      parseExpressionStatement(node, expr) {
        if (
          expr.type !== 'Placeholder' ||
          (expr.extra && expr.extra.parenthesized)
        ) {
          return super.parseExpressionStatement(...arguments);
        }

        if (this.match(types.colon)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, 'Identifier');
          this.next();
          stmt.body = this.parseStatement('label');
          return this.finishNode(stmt, 'LabeledStatement');
        }

        this.semicolon();
        node.name = expr.name;
        return this.finishPlaceholder(node, 'Statement');
      }

      parseBlock() {
        return (
          this.parsePlaceholder('BlockStatement') ||
          super.parseBlock(...arguments)
        );
      }

      parseFunctionId() {
        return (
          this.parsePlaceholder('Identifier') ||
          super.parseFunctionId(...arguments)
        );
      }

      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? 'ClassDeclaration' : 'ClassExpression';
        this.next();
        this.takeDecorators(node);
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder('Identifier');

        if (placeholder) {
          if (
            this.match(types._extends) ||
            this.match(types.placeholder) ||
            this.match(types.braceL)
          ) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, 'ClassBody');
            return this.finishNode(node, type);
          } else {
            this.unexpected(null, 'A class name is required');
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }

        this.parseClassSuper(node);
        node.body =
          this.parsePlaceholder('ClassBody') ||
          this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }

      parseExport(node) {
        const placeholder = this.parsePlaceholder('Identifier');
        if (!placeholder) return super.parseExport(...arguments);

        if (!this.isContextual('from') && !this.match(types.comma)) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.finishPlaceholder(placeholder, 'Declaration');
          return this.finishNode(node, 'ExportNamedDeclaration');
        }

        this.expectPlugin('exportDefaultFrom');
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node.specifiers = [
          this.finishNode(specifier, 'ExportDefaultSpecifier'),
        ];
        return super.parseExport(node);
      }

      isExportDefaultSpecifier() {
        if (this.match(types._default)) {
          const next = this.nextTokenStart();

          if (this.isUnparsedContextual(next, 'from')) {
            if (
              this.input.startsWith(
                types.placeholder.label,
                this.nextTokenStartSince(next + 4),
              )
            ) {
              return true;
            }
          }
        }

        return super.isExportDefaultSpecifier();
      }

      maybeParseExportDefaultSpecifier(node) {
        if (node.specifiers && node.specifiers.length > 0) {
          return true;
        }

        return super.maybeParseExportDefaultSpecifier(...arguments);
      }

      checkExport(node) {
        const {specifiers} = node;

        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter(
            (node) => node.exported.type === 'Placeholder',
          );
        }

        super.checkExport(node);
        node.specifiers = specifiers;
      }

      parseImport(node) {
        const placeholder = this.parsePlaceholder('Identifier');
        if (!placeholder) return super.parseImport(...arguments);
        node.specifiers = [];

        if (!this.isContextual('from') && !this.match(types.comma)) {
          node.source = this.finishPlaceholder(placeholder, 'StringLiteral');
          this.semicolon();
          return this.finishNode(node, 'ImportDeclaration');
        }

        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        this.finishNode(specifier, 'ImportDefaultSpecifier');
        node.specifiers.push(specifier);

        if (this.eat(types.comma)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }

        this.expectContextual('from');
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, 'ImportDeclaration');
      }

      parseImportSource() {
        return (
          this.parsePlaceholder('StringLiteral') ||
          super.parseImportSource(...arguments)
        );
      }
    };

  var v8intrinsic = (superClass) =>
    class extends superClass {
      parseV8Intrinsic() {
        if (this.match(types.modulo)) {
          const v8IntrinsicStart = this.state.start;
          const node = this.startNode();
          this.eat(types.modulo);

          if (this.match(types.name)) {
            const name = this.parseIdentifierName(this.state.start);
            const identifier = this.createIdentifier(node, name);
            identifier.type = 'V8IntrinsicIdentifier';

            if (this.match(types.parenL)) {
              return identifier;
            }
          }

          this.unexpected(v8IntrinsicStart);
        }
      }

      parseExprAtom() {
        return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
      }
    };

  function hasPlugin(plugins, name) {
    return plugins.some((plugin) => {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });
  }

  function getPluginOption(plugins, name, option) {
    const plugin = plugins.find((plugin) => {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });

    if (plugin && Array.isArray(plugin)) {
      return plugin[1][option];
    }

    return null;
  }

  const PIPELINE_PROPOSALS = ['minimal', 'smart', 'fsharp'];
  const RECORD_AND_TUPLE_SYNTAX_TYPES = ['hash', 'bar'];

  function validatePlugins(plugins) {
    if (hasPlugin(plugins, 'decorators')) {
      if (hasPlugin(plugins, 'decorators-legacy')) {
        throw new Error(
          'Cannot use the decorators and decorators-legacy plugin together',
        );
      }

      const decoratorsBeforeExport = getPluginOption(
        plugins,
        'decorators',
        'decoratorsBeforeExport',
      );

      if (decoratorsBeforeExport == null) {
        throw new Error(
          "The 'decorators' plugin requires a 'decoratorsBeforeExport' option," +
            ' whose value must be a boolean. If you are migrating from' +
            ' Babylon/Babel 6 or want to use the old decorators proposal, you' +
            " should use the 'decorators-legacy' plugin instead of 'decorators'.",
        );
      } else if (typeof decoratorsBeforeExport !== 'boolean') {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (hasPlugin(plugins, 'flow') && hasPlugin(plugins, 'typescript')) {
      throw new Error('Cannot combine flow and typescript plugins.');
    }

    if (
      hasPlugin(plugins, 'placeholders') &&
      hasPlugin(plugins, 'v8intrinsic')
    ) {
      throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
    }

    if (
      hasPlugin(plugins, 'pipelineOperator') &&
      !PIPELINE_PROPOSALS.includes(
        getPluginOption(plugins, 'pipelineOperator', 'proposal'),
      )
    ) {
      throw new Error(
        "'pipelineOperator' requires 'proposal' option whose value should be one of: " +
          PIPELINE_PROPOSALS.map((p) => `'${p}'`).join(', '),
      );
    }

    if (hasPlugin(plugins, 'moduleAttributes')) {
      if (hasPlugin(plugins, 'importAssertions')) {
        throw new Error(
          'Cannot combine importAssertions and moduleAttributes plugins.',
        );
      }

      const moduleAttributesVerionPluginOption = getPluginOption(
        plugins,
        'moduleAttributes',
        'version',
      );

      if (moduleAttributesVerionPluginOption !== 'may-2020') {
        throw new Error(
          "The 'moduleAttributes' plugin requires a 'version' option," +
            ' representing the last proposal update. Currently, the' +
            " only supported value is 'may-2020'.",
        );
      }
    }

    if (
      hasPlugin(plugins, 'recordAndTuple') &&
      !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(
        getPluginOption(plugins, 'recordAndTuple', 'syntaxType'),
      )
    ) {
      throw new Error(
        "'recordAndTuple' requires 'syntaxType' option whose value should be one of: " +
          RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(', '),
      );
    }
  }

  const mixinPlugins = {
    estree,
    jsx,
    flow,
    typescript,
    v8intrinsic,
    placeholders,
  };
  const mixinPluginNames = Object.keys(mixinPlugins);
  const defaultOptions = {
    sourceType: 'script',
    sourceFilename: undefined,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
  };

  function getOptions(opts) {
    const options = {};

    for (const key of Object.keys(defaultOptions)) {
      options[key] =
        opts && opts[key] != null ? opts[key] : defaultOptions[key];
    }

    return options;
  }

  class State {
    constructor() {
      this.strict = void 0;
      this.curLine = void 0;
      this.startLoc = void 0;
      this.endLoc = void 0;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.maybeInArrowParameters = false;
      this.inPipeline = false;
      this.inType = false;
      this.noAnonFunctionType = false;
      this.inPropertyName = false;
      this.hasFlowComment = false;
      this.isIterator = false;
      this.isDeclareContext = false;
      this.inAbstractClass = false;
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null,
      };
      this.soloAwait = false;
      this.inFSharpPipelineDirectBody = false;
      this.labels = [];
      this.decoratorStack = [[]];
      this.comments = [];
      this.trailingComments = [];
      this.leadingComments = [];
      this.commentStack = [];
      this.commentPreviousNode = null;
      this.pos = 0;
      this.lineStart = 0;
      this.type = types.eof;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.lastTokStart = 0;
      this.lastTokEnd = 0;
      this.context = [types$1.braceStatement];
      this.exprAllowed = true;
      this.containsEsc = false;
      this.strictErrors = new Map();
      this.exportedIdentifiers = [];
      this.tokensLength = 0;
    }

    init(options) {
      this.strict =
        options.strictMode === false ? false : options.sourceType === 'module';
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    }

    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    }

    clone(skipArrays) {
      const state = new State();
      const keys = Object.keys(this);

      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];
        let val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    }
  }

  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };

  const VALID_REGEX_FLAGS = new Set(['g', 'm', 's', 'i', 'y', 'u']);
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
    hex: [46, 88, 95, 120],
  };
  const allowedNumericSeparatorSiblings = {};
  allowedNumericSeparatorSiblings.bin = [48, 49];
  allowedNumericSeparatorSiblings.oct = [
    ...allowedNumericSeparatorSiblings.bin,
    50,
    51,
    52,
    53,
    54,
    55,
  ];
  allowedNumericSeparatorSiblings.dec = [
    ...allowedNumericSeparatorSiblings.oct,
    56,
    57,
  ];
  allowedNumericSeparatorSiblings.hex = [
    ...allowedNumericSeparatorSiblings.dec,
    65,
    66,
    67,
    68,
    69,
    70,
    97,
    98,
    99,
    100,
    101,
    102,
  ];

  class Token {
    constructor(state) {
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
  }

  class Tokenizer extends ParserError {
    constructor(options, input) {
      super();
      this.isLookahead = void 0;
      this.tokens = [];
      this.state = new State();
      this.state.init(options);
      this.input = input;
      this.length = input.length;
      this.isLookahead = false;
    }

    pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }

    next() {
      if (!this.isLookahead) {
        this.checkKeywordEscapes();

        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }

    eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }

    match(type) {
      return this.state.type === type;
    }

    lookahead() {
      const old = this.state;
      this.state = old.clone(true);
      this.isLookahead = true;
      this.next();
      this.isLookahead = false;
      const curr = this.state;
      this.state = old;
      return curr;
    }

    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }

    nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      const skip = skipWhiteSpace.exec(this.input);
      return pos + skip[0].length;
    }

    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }

    setStrict(strict) {
      this.state.strict = strict;

      if (strict) {
        this.state.strictErrors.forEach((message, pos) =>
          this.raise(pos, message),
        );
        this.state.strictErrors.clear();
      }
    }

    curContext() {
      return this.state.context[this.state.context.length - 1];
    }

    nextToken() {
      const curContext = this.curContext();
      if (!(curContext != null && curContext.preserveSpace)) this.skipSpace();
      this.state.start = this.state.pos;
      this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types.eof);
        return;
      }

      const override = curContext == null ? void 0 : curContext.override;

      if (override) {
        override(this);
      } else {
        this.getTokenFromCode(this.input.codePointAt(this.state.pos));
      }
    }

    pushComment(block, text, start, end, startLoc, endLoc) {
      const comment = {
        type: block ? 'CommentBlock' : 'CommentLine',
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc),
      };
      if (this.options.tokens) this.pushToken(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }

    skipBlockComment() {
      const startLoc = this.state.curPosition();
      const start = this.state.pos;
      const end = this.input.indexOf('*/', this.state.pos + 2);
      if (end === -1)
        throw this.raise(start, ErrorMessages.UnterminatedComment);
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start;
      let match;

      while (
        (match = lineBreakG.exec(this.input)) &&
        match.index < this.state.pos
      ) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }

      if (this.isLookahead) return;
      this.pushComment(
        true,
        this.input.slice(start + 2, end),
        start,
        this.state.pos,
        startLoc,
        this.state.curPosition(),
      );
    }

    skipLineComment(startSkip) {
      const start = this.state.pos;
      const startLoc = this.state.curPosition();
      let ch = this.input.charCodeAt((this.state.pos += startSkip));

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      this.pushComment(
        false,
        this.input.slice(start + startSkip, this.state.pos),
        start,
        this.state.pos,
        startLoc,
        this.state.curPosition(),
      );
    }

    skipSpace() {
      loop: while (this.state.pos < this.length) {
        const ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;

              case 47:
                this.skipLineComment(2);
                break;

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else {
              break loop;
            }
        }
      }
    }

    finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      const prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) this.updateContext(prevType);
    }

    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      const nextPos = this.state.pos + 1;
      const next = this.input.charCodeAt(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(
          this.state.pos,
          ErrorMessages.UnexpectedDigitAfterHash,
        );
      }

      if (next === 123 || (next === 91 && this.hasPlugin('recordAndTuple'))) {
        this.expectPlugin('recordAndTuple');

        if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'hash') {
          throw this.raise(
            this.state.pos,
            next === 123
              ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType
              : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType,
          );
        }

        if (next === 123) {
          this.finishToken(types.braceHashL);
        } else {
          this.finishToken(types.bracketHashL);
        }

        this.state.pos += 2;
      } else {
        this.finishOp(types.hash, 1);
      }
    }

    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types.dot);
      }
    }

    readToken_slash() {
      if (this.state.exprAllowed && !this.state.inType) {
        ++this.state.pos;
        this.readRegexp();
        return;
      }

      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.slash, 1);
      }
    }

    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      const start = this.state.pos;
      this.state.pos += 1;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      const value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types.interpreterDirective, value);
      return true;
    }

    readToken_mult_modulo(code) {
      let type = code === 42 ? types.star : types.modulo;
      let width = 1;
      let next = this.input.charCodeAt(this.state.pos + 1);
      const exprAllowed = this.state.exprAllowed;

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types.exponent;
      }

      if (next === 61 && !exprAllowed) {
        width++;
        type = types.assign;
      }

      this.finishOp(type, width);
    }

    readToken_pipe_amp(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types.pipeline, 2);
          return;
        }

        if (this.hasPlugin('recordAndTuple') && next === 125) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
            throw this.raise(
              this.state.pos,
              ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType,
            );
          }

          this.finishOp(types.braceBarR, 2);
          return;
        }

        if (this.hasPlugin('recordAndTuple') && next === 93) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
            throw this.raise(
              this.state.pos,
              ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType,
            );
          }

          this.finishOp(types.bracketBarR, 2);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
    }

    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.bitwiseXOR, 1);
      }
    }

    readToken_plus_min(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (
          next === 45 &&
          !this.inModule &&
          this.input.charCodeAt(this.state.pos + 2) === 62 &&
          (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())
        ) {
          this.skipLineComment(3);
          this.skipSpace();
          this.nextToken();
          return;
        }

        this.finishOp(types.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.plusMin, 1);
      }
    }

    readToken_lt_gt(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      let size = 1;

      if (next === code) {
        size =
          code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62
            ? 3
            : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types.assign, size + 1);
          return;
        }

        this.finishOp(types.bitShift, size);
        return;
      }

      if (
        next === 33 &&
        code === 60 &&
        !this.inModule &&
        this.input.charCodeAt(this.state.pos + 2) === 45 &&
        this.input.charCodeAt(this.state.pos + 3) === 45
      ) {
        this.skipLineComment(4);
        this.skipSpace();
        this.nextToken();
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types.relational, size);
    }

    readToken_eq_excl(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(
          types.equality,
          this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2,
        );
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types.arrow);
        return;
      }

      this.finishOp(code === 61 ? types.eq : types.bang, 1);
    }

    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      const next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(types.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types.question);
      }
    }

    getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types.comma);
          return;

        case 91:
          if (
            this.hasPlugin('recordAndTuple') &&
            this.input.charCodeAt(this.state.pos + 1) === 124
          ) {
            if (
              this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
            ) {
              throw this.raise(
                this.state.pos,
                ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType,
              );
            }

            this.finishToken(types.bracketBarL);
            this.state.pos += 2;
          } else {
            ++this.state.pos;
            this.finishToken(types.bracketL);
          }

          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types.bracketR);
          return;

        case 123:
          if (
            this.hasPlugin('recordAndTuple') &&
            this.input.charCodeAt(this.state.pos + 1) === 124
          ) {
            if (
              this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
            ) {
              throw this.raise(
                this.state.pos,
                ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType,
              );
            }

            this.finishToken(types.braceBarL);
            this.state.pos += 2;
          } else {
            ++this.state.pos;
            this.finishToken(types.braceL);
          }

          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types.braceR);
          return;

        case 58:
          if (
            this.hasPlugin('functionBind') &&
            this.input.charCodeAt(this.state.pos + 1) === 58
          ) {
            this.finishOp(types.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types.backQuote);
          return;

        case 48: {
          const next = this.input.charCodeAt(this.state.pos + 1);

          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }

          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }

          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord();
            return;
          }
      }

      throw this.raise(
        this.state.pos,
        ErrorMessages.InvalidOrUnexpectedToken,
        String.fromCodePoint(code),
      );
    }

    finishOp(type, size) {
      const str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }

    readRegexp() {
      const start = this.state.pos;
      let escaped, inClass;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        const ch = this.input.charAt(this.state.pos);

        if (lineBreak.test(ch)) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === '[') {
            inClass = true;
          } else if (ch === ']' && inClass) {
            inClass = false;
          } else if (ch === '/' && !inClass) {
            break;
          }

          escaped = ch === '\\';
        }

        ++this.state.pos;
      }

      const content = this.input.slice(start, this.state.pos);
      ++this.state.pos;
      let mods = '';

      while (this.state.pos < this.length) {
        const char = this.input[this.state.pos];
        const charCode = this.input.codePointAt(this.state.pos);

        if (VALID_REGEX_FLAGS.has(char)) {
          if (mods.indexOf(char) > -1) {
            this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);
          }
        } else if (isIdentifierChar(charCode) || charCode === 92) {
          this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);
        } else {
          break;
        }

        ++this.state.pos;
        mods += char;
      }

      this.finishToken(types.regexp, {
        pattern: content,
        flags: mods,
      });
    }

    readInt(radix, len, forceLen, allowNumSeparator = true) {
      const start = this.state.pos;
      const forbiddenSiblings =
        radix === 16
          ? forbiddenNumericSeparatorSiblings.hex
          : forbiddenNumericSeparatorSiblings.decBinOct;
      const allowedSiblings =
        radix === 16
          ? allowedNumericSeparatorSiblings.hex
          : radix === 10
          ? allowedNumericSeparatorSiblings.dec
          : radix === 8
          ? allowedNumericSeparatorSiblings.oct
          : allowedNumericSeparatorSiblings.bin;
      let invalid = false;
      let total = 0;

      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code = this.input.charCodeAt(this.state.pos);
        let val;

        if (code === 95) {
          const prev = this.input.charCodeAt(this.state.pos - 1);
          const next = this.input.charCodeAt(this.state.pos + 1);

          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(
              this.state.pos,
              ErrorMessages.UnexpectedNumericSeparator,
            );
          } else if (
            forbiddenSiblings.indexOf(prev) > -1 ||
            forbiddenSiblings.indexOf(next) > -1 ||
            Number.isNaN(next)
          ) {
            this.raise(
              this.state.pos,
              ErrorMessages.UnexpectedNumericSeparator,
            );
          }

          if (!allowNumSeparator) {
            this.raise(
              this.state.pos,
              ErrorMessages.NumericSeparatorInEscapeSequence,
            );
          }

          ++this.state.pos;
          continue;
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(
              this.state.start + i + 2,
              ErrorMessages.InvalidDigit,
              radix,
            );
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (
        this.state.pos === start ||
        (len != null && this.state.pos - start !== len) ||
        invalid
      ) {
        return null;
      }

      return total;
    }

    readRadixNumber(radix) {
      const start = this.state.pos;
      let isBigInt = false;
      this.state.pos += 2;
      const val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
      }

      const next = this.input.charCodeAt(this.state.pos);

      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(start, ErrorMessages.InvalidDecimal);
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      if (isBigInt) {
        const str = this.input
          .slice(start, this.state.pos)
          .replace(/[_n]/g, '');
        this.finishToken(types.bigint, str);
        return;
      }

      this.finishToken(types.num, val);
    }

    readNumber(startsWithDot) {
      const start = this.state.pos;
      let isFloat = false;
      let isBigInt = false;
      let isDecimal = false;
      let hasExponent = false;
      let isOctal = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, ErrorMessages.InvalidNumber);
      }

      const hasLeadingZero =
        this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);

        if (!this.state.strict) {
          const underscorePos = integer.indexOf('_');

          if (underscorePos > 0) {
            this.raise(
              underscorePos + start,
              ErrorMessages.ZeroDigitNumericSeparator,
            );
          }
        }

        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }

      let next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) {
          this.raise(start, ErrorMessages.InvalidOrMissingExponent);
        }

        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidBigIntLiteral);
        }

        ++this.state.pos;
        isBigInt = true;
      }

      if (next === 109) {
        this.expectPlugin('decimal', this.state.pos);

        if (hasExponent || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidDecimal);
        }

        ++this.state.pos;
        isDecimal = true;
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, '');

      if (isBigInt) {
        this.finishToken(types.bigint, str);
        return;
      }

      if (isDecimal) {
        this.finishToken(types.decimal, str);
        return;
      }

      const val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types.num, val);
    }

    readCodePoint(throwOnInvalid) {
      const ch = this.input.charCodeAt(this.state.pos);
      let code;

      if (ch === 123) {
        const codePos = ++this.state.pos;
        code = this.readHexChar(
          this.input.indexOf('}', this.state.pos) - this.state.pos,
          true,
          throwOnInvalid,
        );
        ++this.state.pos;

        if (code !== null && code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, ErrorMessages.InvalidCodePoint);
          } else {
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    }

    readString(quote) {
      let out = '',
        chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }

        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types.string, out);
    }

    readTmplToken() {
      let out = '',
        chunkStart = this.state.pos,
        containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(
            this.state.start,
            ErrorMessages.UnterminatedTemplate,
          );
        }

        const ch = this.input.charCodeAt(this.state.pos);

        if (
          ch === 96 ||
          (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
        ) {
          if (
            this.state.pos === this.state.start &&
            this.match(types.template)
          ) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          const escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += '\n';
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    }

    recordStrictModeErrors(pos, message) {
      if (this.state.strict && !this.state.strictErrors.has(pos)) {
        this.raise(pos, message);
      } else {
        this.state.strictErrors.set(pos, message);
      }
    }

    readEscapedChar(inTemplate) {
      const throwOnInvalid = !inTemplate;
      const ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return '\n';

        case 114:
          return '\r';

        case 120: {
          const code = this.readHexChar(2, false, throwOnInvalid);
          return code === null ? null : String.fromCharCode(code);
        }

        case 117: {
          const code = this.readCodePoint(throwOnInvalid);
          return code === null ? null : String.fromCodePoint(code);
        }

        case 116:
          return '\t';

        case 98:
          return '\b';

        case 118:
          return '\u000b';

        case 102:
          return '\f';

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return '';

        case 56:
        case 57:
          if (inTemplate) {
            return null;
          } else {
            this.recordStrictModeErrors(
              this.state.pos - 1,
              ErrorMessages.StrictNumericEscape,
            );
          }

        default:
          if (ch >= 48 && ch <= 55) {
            const codePos = this.state.pos - 1;
            const match = this.input
              .substr(this.state.pos - 1, 3)
              .match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            const next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== '0' || next === 56 || next === 57) {
              if (inTemplate) {
                return null;
              } else {
                this.recordStrictModeErrors(
                  codePos,
                  ErrorMessages.StrictNumericEscape,
                );
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    }

    readHexChar(len, forceLen, throwOnInvalid) {
      const codePos = this.state.pos;
      const n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
        } else {
          this.state.pos = codePos - 1;
        }
      }

      return n;
    }

    readWord1() {
      let word = '';
      this.state.containsEsc = false;
      const start = this.state.pos;
      let chunkStart = this.state.pos;

      while (this.state.pos < this.length) {
        const ch = this.input.codePointAt(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (this.state.isIterator && ch === 64) {
          ++this.state.pos;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.pos;
          const identifierCheck =
            this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
            continue;
          }

          ++this.state.pos;
          const esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    }

    isIterator(word) {
      return word === '@@iterator' || word === '@@asyncIterator';
    }

    readWord() {
      const word = this.readWord1();
      const type = keywords.get(word) || types.name;

      if (
        this.state.isIterator &&
        (!this.isIterator(word) || !this.state.inType)
      ) {
        this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);
      }

      this.finishToken(type, word);
    }

    checkKeywordEscapes() {
      const kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(
          this.state.start,
          ErrorMessages.InvalidEscapedReservedWord,
          kw,
        );
      }
    }

    braceIsBlock(prevType) {
      const parent = this.curContext();

      if (
        parent === types$1.functionExpression ||
        parent === types$1.functionStatement
      ) {
        return true;
      }

      if (
        prevType === types.colon &&
        (parent === types$1.braceStatement ||
          parent === types$1.braceExpression)
      ) {
        return !parent.isExpr;
      }

      if (
        prevType === types._return ||
        (prevType === types.name && this.state.exprAllowed)
      ) {
        return this.hasPrecedingLineBreak();
      }

      if (
        prevType === types._else ||
        prevType === types.semi ||
        prevType === types.eof ||
        prevType === types.parenR ||
        prevType === types.arrow
      ) {
        return true;
      }

      if (prevType === types.braceL) {
        return parent === types$1.braceStatement;
      }

      if (
        prevType === types._var ||
        prevType === types._const ||
        prevType === types.name
      ) {
        return false;
      }

      if (prevType === types.relational) {
        return true;
      }

      return !this.state.exprAllowed;
    }

    updateContext(prevType) {
      const type = this.state.type;
      let update;

      if (
        type.keyword &&
        (prevType === types.dot || prevType === types.questionDot)
      ) {
        this.state.exprAllowed = false;
      } else if ((update = type.updateContext)) {
        update.call(this, prevType);
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    }
  }

  class ClassScope {
    constructor() {
      this.privateNames = new Set();
      this.loneAccessors = new Map();
      this.undefinedPrivateNames = new Map();
    }
  }

  class ClassScopeHandler {
    constructor(raise) {
      this.stack = [];
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
    }

    current() {
      return this.stack[this.stack.length - 1];
    }

    enter() {
      this.stack.push(new ClassScope());
    }

    exit() {
      const oldClassScope = this.stack.pop();
      const current = this.current();

      for (const [name, pos] of Array.from(
        oldClassScope.undefinedPrivateNames,
      )) {
        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, pos);
          }
        } else {
          this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
      }
    }

    declarePrivateName(name, elementType, pos) {
      const classScope = this.current();
      let redefined = classScope.privateNames.has(name);

      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        const accessor = redefined && classScope.loneAccessors.get(name);

        if (accessor) {
          const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) classScope.loneAccessors.delete(name);
        } else if (!redefined) {
          classScope.loneAccessors.set(name, elementType);
        }
      }

      if (redefined) {
        this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
      }

      classScope.privateNames.add(name);
      classScope.undefinedPrivateNames.delete(name);
    }

    usePrivateName(name, pos) {
      let classScope;

      for (classScope of this.stack) {
        if (classScope.privateNames.has(name)) return;
      }

      if (classScope) {
        classScope.undefinedPrivateNames.set(name, pos);
      } else {
        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    }
  }

  const kExpression = 0,
    kMaybeArrowParameterDeclaration = 1,
    kMaybeAsyncArrowParameterDeclaration = 2,
    kParameterDeclaration = 3;

  class ExpressionScope {
    constructor(type = kExpression) {
      this.type = void 0;
      this.type = type;
    }

    canBeArrowParameterDeclaration() {
      return (
        this.type === kMaybeAsyncArrowParameterDeclaration ||
        this.type === kMaybeArrowParameterDeclaration
      );
    }

    isCertainlyParameterDeclaration() {
      return this.type === kParameterDeclaration;
    }
  }

  class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type) {
      super(type);
      this.errors = new Map();
    }

    recordDeclarationError(pos, message) {
      this.errors.set(pos, message);
    }

    clearDeclarationError(pos) {
      this.errors.delete(pos);
    }

    iterateErrors(iterator) {
      this.errors.forEach(iterator);
    }
  }

  class ExpressionScopeHandler {
    constructor(raise) {
      this.stack = [new ExpressionScope()];
      this.raise = raise;
    }

    enter(scope) {
      this.stack.push(scope);
    }

    exit() {
      this.stack.pop();
    }

    recordParameterInitializerError(pos, message) {
      const {stack} = this;
      let i = stack.length - 1;
      let scope = stack[i];

      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(pos, message);
        } else {
          return;
        }

        scope = stack[--i];
      }

      this.raise(pos, message);
    }

    recordParenthesizedIdentifierError(pos, message) {
      const {stack} = this;
      const scope = stack[stack.length - 1];

      if (scope.isCertainlyParameterDeclaration()) {
        this.raise(pos, message);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(pos, message);
      } else {
        return;
      }
    }

    recordAsyncArrowParametersError(pos, message) {
      const {stack} = this;
      let i = stack.length - 1;
      let scope = stack[i];

      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
          scope.recordDeclarationError(pos, message);
        }

        scope = stack[--i];
      }
    }

    validateAsPattern() {
      const {stack} = this;
      const currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration()) return;
      currentScope.iterateErrors((message, pos) => {
        this.raise(pos, message);
        let i = stack.length - 2;
        let scope = stack[i];

        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(pos);
          scope = stack[--i];
        }
      });
    }
  }

  function newParameterDeclarationScope() {
    return new ExpressionScope(kParameterDeclaration);
  }

  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
  }

  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
  }

  function newExpressionScope() {
    return new ExpressionScope();
  }

  class UtilParser extends Tokenizer {
    addExtra(node, key, val) {
      if (!node) return;
      const extra = (node.extra = node.extra || {});
      extra[key] = val;
    }

    isRelational(op) {
      return this.match(types.relational) && this.state.value === op;
    }

    expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types.relational);
      }
    }

    isContextual(name) {
      return (
        this.match(types.name) &&
        this.state.value === name &&
        !this.state.containsEsc
      );
    }

    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;
      return (
        this.input.slice(nameStart, nameEnd) === name &&
        (nameEnd === this.input.length ||
          !isIdentifierChar(this.input.charCodeAt(nameEnd)))
      );
    }

    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }

    eatContextual(name) {
      return this.isContextual(name) && this.eat(types.name);
    }

    expectContextual(name, message) {
      if (!this.eatContextual(name)) this.unexpected(null, message);
    }

    canInsertSemicolon() {
      return (
        this.match(types.eof) ||
        this.match(types.braceR) ||
        this.hasPrecedingLineBreak()
      );
    }

    hasPrecedingLineBreak() {
      return lineBreak.test(
        this.input.slice(this.state.lastTokEnd, this.state.start),
      );
    }

    hasFollowingLineBreak() {
      return lineBreak.test(
        this.input.slice(this.state.end, this.nextTokenStart()),
      );
    }

    isLineTerminator() {
      return this.eat(types.semi) || this.canInsertSemicolon();
    }

    semicolon(allowAsi = true) {
      if (allowAsi ? this.isLineTerminator() : this.eat(types.semi)) return;
      this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
    }

    expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }

    assertNoSpace(message = 'Unexpected space.') {
      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, message);
      }
    }

    unexpected(pos, messageOrType = 'Unexpected token') {
      if (typeof messageOrType !== 'string') {
        messageOrType = `Unexpected token, expected "${messageOrType.label}"`;
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    }

    expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(
          pos != null ? pos : this.state.start,
          {
            missingPlugin: [name],
          },
          `This experimental syntax requires enabling the parser plugin: '${name}'`,
        );
      }

      return true;
    }

    expectOnePlugin(names, pos) {
      if (!names.some((n) => this.hasPlugin(n))) {
        throw this.raiseWithData(
          pos != null ? pos : this.state.start,
          {
            missingPlugin: names,
          },
          `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(
            ', ',
          )}'`,
        );
      }
    }

    tryParse(fn, oldState = this.state.clone()) {
      const abortSignal = {
        node: null,
      };

      try {
        const node = fn((node = null) => {
          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          this.state = oldState;
          return {
            node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState,
          };
        }

        return {
          node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null,
        };
      } catch (error) {
        const failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error,
            thrown: true,
            aborted: false,
            failState,
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState,
          };
        }

        throw error;
      }
    }

    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      const {shorthandAssign, doubleProto} = refExpressionErrors;
      if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;

      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }

      if (doubleProto >= 0) {
        this.raise(doubleProto, ErrorMessages.DuplicateProto);
      }
    }

    isLiteralPropertyName() {
      return (
        this.match(types.name) ||
        !!this.state.type.keyword ||
        this.match(types.string) ||
        this.match(types.num) ||
        this.match(types.bigint) ||
        this.match(types.decimal)
      );
    }

    isPrivateName(node) {
      return node.type === 'PrivateName';
    }

    getPrivateNameSV(node) {
      return node.id.name;
    }

    hasPropertyAsPrivateName(node) {
      return (
        (node.type === 'MemberExpression' ||
          node.type === 'OptionalMemberExpression') &&
        this.isPrivateName(node.property)
      );
    }

    isOptionalChain(node) {
      return (
        node.type === 'OptionalMemberExpression' ||
        node.type === 'OptionalCallExpression'
      );
    }

    isObjectProperty(node) {
      return node.type === 'ObjectProperty';
    }

    isObjectMethod(node) {
      return node.type === 'ObjectMethod';
    }

    initializeScopes(inModule = this.options.sourceType === 'module') {
      const oldLabels = this.state.labels;
      this.state.labels = [];
      const oldExportedIdentifiers = this.state.exportedIdentifiers;
      this.state.exportedIdentifiers = [];
      const oldInModule = this.inModule;
      this.inModule = inModule;
      const oldScope = this.scope;
      const ScopeHandler = this.getScopeHandler();
      this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
      const oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      const oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this.raise.bind(this));
      const oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
      return () => {
        this.state.labels = oldLabels;
        this.state.exportedIdentifiers = oldExportedIdentifiers;
        this.inModule = oldInModule;
        this.scope = oldScope;
        this.prodParam = oldProdParam;
        this.classScope = oldClassScope;
        this.expressionScope = oldExpressionScope;
      };
    }

    enterInitialScopes() {
      let paramFlags = PARAM;

      if (this.hasPlugin('topLevelAwait') && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
    }
  }

  class ExpressionErrors {
    constructor() {
      this.shorthandAssign = -1;
      this.doubleProto = -1;
    }
  }

  class Node {
    constructor(parser, pos, loc) {
      this.type = void 0;
      this.start = void 0;
      this.end = void 0;
      this.loc = void 0;
      this.range = void 0;
      this.leadingComments = void 0;
      this.trailingComments = void 0;
      this.innerComments = void 0;
      this.extra = void 0;
      this.type = '';
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser != null && parser.options.ranges) this.range = [pos, 0];
      if (parser != null && parser.filename)
        this.loc.filename = parser.filename;
    }

    __clone() {
      const newNode = new Node();
      const keys = Object.keys(this);

      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];

        if (
          key !== 'leadingComments' &&
          key !== 'trailingComments' &&
          key !== 'innerComments'
        ) {
          newNode[key] = this[key];
        }
      }

      return newNode;
    }
  }

  class NodeUtils extends UtilParser {
    startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }

    startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }

    startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }

    finishNode(node, type) {
      return this.finishNodeAt(
        node,
        type,
        this.state.lastTokEnd,
        this.state.lastTokEndLoc,
      );
    }

    finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      this.processComment(node);
      return node;
    }

    resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    }

    resetEndLocation(
      node,
      end = this.state.lastTokEnd,
      endLoc = this.state.lastTokEndLoc,
    ) {
      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    }

    resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }
  }

  const unwrapParenthesizedExpression = (node) => {
    return node.type === 'ParenthesizedExpression'
      ? unwrapParenthesizedExpression(node.expression)
      : node;
  };

  class LValParser extends NodeUtils {
    toAssignable(node, isLHS = false) {
      var _node$extra, _node$extra3;

      let parenthesized = undefined;

      if (
        node.type === 'ParenthesizedExpression' ||
        ((_node$extra = node.extra) != null && _node$extra.parenthesized)
      ) {
        parenthesized = unwrapParenthesizedExpression(node);

        if (isLHS) {
          if (parenthesized.type === 'Identifier') {
            this.expressionScope.recordParenthesizedIdentifierError(
              node.start,
              ErrorMessages.InvalidParenthesizedAssignment,
            );
          } else if (parenthesized.type !== 'MemberExpression') {
            this.raise(
              node.start,
              ErrorMessages.InvalidParenthesizedAssignment,
            );
          }
        } else {
          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
        }
      }

      switch (node.type) {
        case 'Identifier':
        case 'ObjectPattern':
        case 'ArrayPattern':
        case 'AssignmentPattern':
          break;

        case 'ObjectExpression':
          node.type = 'ObjectPattern';

          for (
            let i = 0, length = node.properties.length, last = length - 1;
            i < length;
            i++
          ) {
            var _node$extra2;

            const prop = node.properties[i];
            const isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

            if (
              isLast &&
              prop.type === 'RestElement' &&
              (_node$extra2 = node.extra) != null &&
              _node$extra2.trailingComma
            ) {
              this.raiseRestNotLast(node.extra.trailingComma);
            }
          }

          break;

        case 'ObjectProperty':
          this.toAssignable(node.value, isLHS);
          break;

        case 'SpreadElement': {
          this.checkToRestConversion(node);
          node.type = 'RestElement';
          const arg = node.argument;
          this.toAssignable(arg, isLHS);
          break;
        }

        case 'ArrayExpression':
          node.type = 'ArrayPattern';
          this.toAssignableList(
            node.elements,
            (_node$extra3 = node.extra) == null
              ? void 0
              : _node$extra3.trailingComma,
            isLHS,
          );
          break;

        case 'AssignmentExpression':
          if (node.operator !== '=') {
            this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
          }

          node.type = 'AssignmentPattern';
          delete node.operator;
          this.toAssignable(node.left, isLHS);
          break;

        case 'ParenthesizedExpression':
          this.toAssignable(parenthesized, isLHS);
          break;
      }

      return node;
    }

    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === 'ObjectMethod') {
        const error =
          prop.kind === 'get' || prop.kind === 'set'
            ? ErrorMessages.PatternHasAccessor
            : ErrorMessages.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else if (prop.type === 'SpreadElement' && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop, isLHS);
      }
    }

    toAssignableList(exprList, trailingCommaPos, isLHS) {
      let end = exprList.length;

      if (end) {
        const last = exprList[end - 1];

        if ((last == null ? void 0 : last.type) === 'RestElement') {
          --end;
        } else if ((last == null ? void 0 : last.type) === 'SpreadElement') {
          last.type = 'RestElement';
          let arg = last.argument;
          this.toAssignable(arg, isLHS);
          arg = unwrapParenthesizedExpression(arg);

          if (
            arg.type !== 'Identifier' &&
            arg.type !== 'MemberExpression' &&
            arg.type !== 'ArrayPattern' &&
            arg.type !== 'ObjectPattern'
          ) {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (let i = 0; i < end; i++) {
        const elt = exprList[i];

        if (elt) {
          this.toAssignable(elt, isLHS);

          if (elt.type === 'RestElement') {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    }

    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }

    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);

      for (const expr of exprList) {
        if ((expr == null ? void 0 : expr.type) === 'ArrayExpression') {
          this.toReferencedListDeep(expr.elements);
        }
      }
    }

    parseSpread(refExpressionErrors, refNeedsArrowPos) {
      const node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(
        refExpressionErrors,
        undefined,
        refNeedsArrowPos,
      );
      return this.finishNode(node, 'SpreadElement');
    }

    parseRestBinding() {
      const node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, 'RestElement');
    }

    parseBindingAtom() {
      switch (this.state.type) {
        case types.bracketL: {
          const node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types.bracketR, 93, true);
          return this.finishNode(node, 'ArrayPattern');
        }

        case types.braceL:
          return this.parseObjectLike(types.braceR, true);
      }

      return this.parseIdentifier();
    }

    parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      const elts = [];
      let first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }

        if (allowEmpty && this.match(types.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          const decorators = [];

          if (this.match(types.at) && this.hasPlugin('decorators')) {
            this.raise(
              this.state.start,
              ErrorMessages.UnsupportedParameterDecorator,
            );
          }

          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    }

    parseAssignableListItem(allowModifiers, decorators) {
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }

    parseAssignableListItemTypes(param) {
      return param;
    }

    parseMaybeDefault(startPos, startLoc, left) {
      var _startLoc, _startPos, _left;

      startLoc =
        (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
      startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(types.eq)) return left;
      const node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, 'AssignmentPattern');
    }

    checkLVal(
      expr,
      contextDescription,
      bindingType = BIND_NONE,
      checkClashes,
      disallowLetBinding,
      strictModeChanged = false,
    ) {
      switch (expr.type) {
        case 'Identifier': {
          const {name} = expr;

          if (
            this.state.strict &&
            (strictModeChanged
              ? isStrictBindReservedWord(name, this.inModule)
              : isStrictBindOnlyReservedWord(name))
          ) {
            this.raise(
              expr.start,
              bindingType === BIND_NONE
                ? ErrorMessages.StrictEvalArguments
                : ErrorMessages.StrictEvalArgumentsBinding,
              name,
            );
          }

          if (checkClashes) {
            if (checkClashes.has(name)) {
              this.raise(expr.start, ErrorMessages.ParamDupe);
            } else {
              checkClashes.add(name);
            }
          }

          if (disallowLetBinding && name === 'let') {
            this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
          }

          if (!(bindingType & BIND_NONE)) {
            this.scope.declareName(name, bindingType, expr.start);
          }

          break;
        }

        case 'MemberExpression':
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
          }

          break;

        case 'ObjectPattern':
          for (let prop of expr.properties) {
            if (this.isObjectProperty(prop)) prop = prop.value;
            else if (this.isObjectMethod(prop)) continue;
            this.checkLVal(
              prop,
              'object destructuring pattern',
              bindingType,
              checkClashes,
              disallowLetBinding,
            );
          }

          break;

        case 'ArrayPattern':
          for (const elem of expr.elements) {
            if (elem) {
              this.checkLVal(
                elem,
                'array destructuring pattern',
                bindingType,
                checkClashes,
                disallowLetBinding,
              );
            }
          }

          break;

        case 'AssignmentPattern':
          this.checkLVal(
            expr.left,
            'assignment pattern',
            bindingType,
            checkClashes,
          );
          break;

        case 'RestElement':
          this.checkLVal(
            expr.argument,
            'rest element',
            bindingType,
            checkClashes,
          );
          break;

        case 'ParenthesizedExpression':
          this.checkLVal(
            expr.expression,
            'parenthesized expression',
            bindingType,
            checkClashes,
          );
          break;

        default: {
          this.raise(
            expr.start,
            bindingType === BIND_NONE
              ? ErrorMessages.InvalidLhs
              : ErrorMessages.InvalidLhsBinding,
            contextDescription,
          );
        }
      }
    }

    checkToRestConversion(node) {
      if (
        node.argument.type !== 'Identifier' &&
        node.argument.type !== 'MemberExpression'
      ) {
        this.raise(
          node.argument.start,
          ErrorMessages.InvalidRestAssignmentPattern,
        );
      }
    }

    checkCommaAfterRest(close) {
      if (this.match(types.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    }

    raiseRestNotLast(pos) {
      throw this.raise(pos, ErrorMessages.ElementAfterRest);
    }

    raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, ErrorMessages.RestTrailingComma);
    }
  }

  class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (
        prop.type === 'SpreadElement' ||
        this.isObjectMethod(prop) ||
        prop.computed ||
        prop.shorthand
      ) {
        return;
      }

      const key = prop.key;
      const name = key.type === 'Identifier' ? key.name : key.value;

      if (name === '__proto__') {
        if (isRecord) {
          this.raise(key.start, ErrorMessages.RecordNoProto);
          return;
        }

        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            }
          } else {
            this.raise(key.start, ErrorMessages.DuplicateProto);
          }
        }

        protoRef.used = true;
      }
    }

    shouldExitDescending(expr, potentialArrowAt) {
      return (
        expr.type === 'ArrowFunctionExpression' &&
        expr.start === potentialArrowAt
      );
    }

    getExpression() {
      let paramFlags = PARAM;

      if (this.hasPlugin('topLevelAwait') && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      this.nextToken();
      const expr = this.parseExpression();

      if (!this.match(types.eof)) {
        this.unexpected();
      }

      expr.comments = this.state.comments;
      expr.errors = this.state.errors;

      if (this.options.tokens) {
        expr.tokens = this.tokens;
      }

      return expr;
    }

    parseExpression(disallowIn, refExpressionErrors) {
      if (disallowIn) {
        return this.disallowInAnd(() =>
          this.parseExpressionBase(refExpressionErrors),
        );
      }

      return this.allowInAnd(() =>
        this.parseExpressionBase(refExpressionErrors),
      );
    }

    parseExpressionBase(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const expr = this.parseMaybeAssign(refExpressionErrors);

      if (this.match(types.comma)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, 'SequenceExpression');
      }

      return expr;
    }

    parseMaybeAssignDisallowIn(
      refExpressionErrors,
      afterLeftParse,
      refNeedsArrowPos,
    ) {
      return this.disallowInAnd(() =>
        this.parseMaybeAssign(
          refExpressionErrors,
          afterLeftParse,
          refNeedsArrowPos,
        ),
      );
    }

    parseMaybeAssignAllowIn(
      refExpressionErrors,
      afterLeftParse,
      refNeedsArrowPos,
    ) {
      return this.allowInAnd(() =>
        this.parseMaybeAssign(
          refExpressionErrors,
          afterLeftParse,
          refNeedsArrowPos,
        ),
      );
    }

    parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;

      if (this.isContextual('yield')) {
        if (this.prodParam.hasYield) {
          this.state.exprAllowed = true;
          let left = this.parseYield();

          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }

          return left;
        }
      }

      let ownExpressionErrors;

      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }

      if (this.match(types.parenL) || this.match(types.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      let left = this.parseMaybeConditional(
        refExpressionErrors,
        refNeedsArrowPos,
      );

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        const node = this.startNodeAt(startPos, startLoc);
        const operator = this.state.value;
        node.operator = operator;

        if (this.match(types.eq)) {
          node.left = this.toAssignable(left, true);
          refExpressionErrors.doubleProto = -1;
        } else {
          node.left = left;
        }

        if (refExpressionErrors.shorthandAssign >= node.left.start) {
          refExpressionErrors.shorthandAssign = -1;
        }

        this.checkLVal(left, 'assignment expression');
        this.next();
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, 'AssignmentExpression');
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      return left;
    }

    parseMaybeConditional(refExpressionErrors, refNeedsArrowPos) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprOps(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);
    }

    parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
      if (this.eat(types.question)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, 'ConditionalExpression');
      }

      return expr;
    }

    parseExprOps(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseMaybeUnary(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1);
    }

    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      let prec = this.state.type.binop;

      if (prec != null && (this.prodParam.hasIn || !this.match(types._in))) {
        if (prec > minPrec) {
          const op = this.state.type;

          if (op === types.pipeline) {
            this.expectPlugin('pipelineOperator');

            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }

            this.state.inPipeline = true;
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          }

          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;
          const logical = op === types.logicalOR || op === types.logicalAND;
          const coalesce = op === types.nullishCoalescing;

          if (coalesce) {
            prec = types.logicalAND.binop;
          }

          this.next();

          if (
            op === types.pipeline &&
            this.getPluginOption('pipelineOperator', 'proposal') === 'minimal'
          ) {
            if (
              this.match(types.name) &&
              this.state.value === 'await' &&
              this.prodParam.hasAwait
            ) {
              throw this.raise(
                this.state.start,
                ErrorMessages.UnexpectedAwaitAfterPipelineBody,
              );
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec);
          this.finishNode(
            node,
            logical || coalesce ? 'LogicalExpression' : 'BinaryExpression',
          );
          const nextOp = this.state.type;

          if (
            (coalesce &&
              (nextOp === types.logicalOR || nextOp === types.logicalAND)) ||
            (logical && nextOp === types.nullishCoalescing)
          ) {
            throw this.raise(
              this.state.start,
              ErrorMessages.MixingCoalesceWithLogical,
            );
          }

          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
      }

      return left;
    }

    parseExprOpRightExpr(op, prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;

      switch (op) {
        case types.pipeline:
          switch (this.getPluginOption('pipelineOperator', 'proposal')) {
            case 'smart':
              return this.withTopicPermittingContext(() => {
                return this.parseSmartPipelineBody(
                  this.parseExprOpBaseRightExpr(op, prec),
                  startPos,
                  startLoc,
                );
              });

            case 'fsharp':
              return this.withSoloAwaitPermittingContext(() => {
                return this.parseFSharpPipelineBody(prec);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }

    parseExprOpBaseRightExpr(op, prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      return this.parseExprOp(
        this.parseMaybeUnary(),
        startPos,
        startLoc,
        op.rightAssociative ? prec - 1 : prec,
      );
    }

    checkExponentialAfterUnary(node) {
      if (this.match(types.exponent)) {
        this.raise(
          node.argument.start,
          ErrorMessages.UnexpectedTokenUnaryExponentiation,
        );
      }
    }

    parseMaybeUnary(refExpressionErrors, sawUnary) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const isAwait = this.isContextual('await');

      if (isAwait && this.isAwaitAllowed()) {
        this.next();
        const expr = this.parseAwait(startPos, startLoc);
        if (!sawUnary) this.checkExponentialAfterUnary(expr);
        return expr;
      }

      if (
        this.isContextual('module') &&
        this.lookaheadCharCode() === 123 &&
        !this.hasFollowingLineBreak()
      ) {
        return this.parseModuleExpression();
      }

      const update = this.match(types.incDec);
      const node = this.startNode();

      if (this.state.type.prefix) {
        node.operator = this.state.value;
        node.prefix = true;

        if (this.match(types._throw)) {
          this.expectPlugin('throwExpressions');
        }

        const isDelete = this.match(types._delete);
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);

        if (this.state.strict && isDelete) {
          const arg = node.argument;

          if (arg.type === 'Identifier') {
            this.raise(node.start, ErrorMessages.StrictDelete);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(node.start, ErrorMessages.DeletePrivateField);
          }
        }

        if (!update) {
          if (!sawUnary) this.checkExponentialAfterUnary(node);
          return this.finishNode(node, 'UnaryExpression');
        }
      }

      const expr = this.parseUpdate(node, update, refExpressionErrors);

      if (isAwait) {
        const startsExpr = this.hasPlugin('v8intrinsic')
          ? this.state.type.startsExpr
          : this.state.type.startsExpr && !this.match(types.modulo);

        if (startsExpr && !this.isAmbiguousAwait()) {
          this.raiseOverwrite(
            startPos,
            this.hasPlugin('topLevelAwait')
              ? ErrorMessages.AwaitNotInAsyncContext
              : ErrorMessages.AwaitNotInAsyncFunction,
          );
          return this.parseAwait(startPos, startLoc);
        }
      }

      return expr;
    }

    parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        this.checkLVal(node.argument, 'prefix operation');
        return this.finishNode(node, 'UpdateExpression');
      }

      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        const node = this.startNodeAt(startPos, startLoc);
        node.operator = this.state.value;
        node.prefix = false;
        node.argument = expr;
        this.checkLVal(expr, 'postfix operation');
        this.next();
        expr = this.finishNode(node, 'UpdateExpression');
      }

      return expr;
    }

    parseExprSubscripts(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprAtom(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    }

    parseSubscripts(base, startPos, startLoc, noCalls) {
      const state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false,
      };

      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);

      return base;
    }

    parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types.doubleColon)) {
        return this.parseBind(base, startPos, startLoc, noCalls, state);
      } else if (this.match(types.backQuote)) {
        return this.parseTaggedTemplateExpression(
          base,
          startPos,
          startLoc,
          state,
        );
      }

      let optional = false;

      if (this.match(types.questionDot)) {
        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        state.optionalChainMember = optional = true;
        this.next();
      }

      if (!noCalls && this.match(types.parenL)) {
        return this.parseCoverCallAndAsyncArrowHead(
          base,
          startPos,
          startLoc,
          state,
          optional,
        );
      } else if (
        optional ||
        this.match(types.bracketL) ||
        this.eat(types.dot)
      ) {
        return this.parseMember(base, startPos, startLoc, state, optional);
      } else {
        state.stop = true;
        return base;
      }
    }

    parseMember(base, startPos, startLoc, state, optional) {
      const node = this.startNodeAt(startPos, startLoc);
      const computed = this.eat(types.bracketL);
      node.object = base;
      node.computed = computed;
      const property = computed
        ? this.parseExpression()
        : this.parseMaybePrivateName(true);

      if (this.isPrivateName(property)) {
        if (node.object.type === 'Super') {
          this.raise(startPos, ErrorMessages.SuperPrivateField);
        }

        this.classScope.usePrivateName(
          this.getPrivateNameSV(property),
          property.start,
        );
      }

      node.property = property;

      if (computed) {
        this.expect(types.bracketR);
      }

      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, 'OptionalMemberExpression');
      } else {
        return this.finishNode(node, 'MemberExpression');
      }
    }

    parseBind(base, startPos, startLoc, noCalls, state) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(
        this.finishNode(node, 'BindExpression'),
        startPos,
        startLoc,
        noCalls,
      );
    }

    parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      this.next();
      let node = this.startNodeAt(startPos, startLoc);
      node.callee = base;

      if (state.maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
      }

      if (state.optionalChainMember) {
        node.optional = optional;
      }

      if (optional) {
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      } else {
        node.arguments = this.parseCallExpressionArguments(
          types.parenR,
          state.maybeAsyncArrow,
          base.type === 'Import',
          base.type !== 'Super',
          node,
        );
      }

      this.finishCallExpression(node, state.optionalChainMember);

      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        node = this.parseAsyncArrowFromCallExpression(
          this.startNodeAt(startPos, startLoc),
          node,
        );
      } else {
        if (state.maybeAsyncArrow) {
          this.expressionScope.exit();
        }

        this.toReferencedArguments(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }

    toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }

    parseTaggedTemplateExpression(base, startPos, startLoc, state) {
      const node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);

      if (state.optionalChainMember) {
        this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
      }

      return this.finishNode(node, 'TaggedTemplateExpression');
    }

    atPossibleAsyncArrow(base) {
      return (
        base.type === 'Identifier' &&
        base.name === 'async' &&
        this.state.lastTokEnd === base.end &&
        !this.canInsertSemicolon() &&
        base.end - base.start === 5 &&
        base.start === this.state.potentialArrowAt
      );
    }

    finishCallExpression(node, optional) {
      if (node.callee.type === 'Import') {
        if (node.arguments.length === 2) {
          if (!this.hasPlugin('moduleAttributes')) {
            this.expectPlugin('importAssertions');
          }
        }

        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(
            node.start,
            ErrorMessages.ImportCallArity,
            this.hasPlugin('importAssertions') ||
              this.hasPlugin('moduleAttributes')
              ? 'one or two arguments'
              : 'one argument',
          );
        } else {
          for (const arg of node.arguments) {
            if (arg.type === 'SpreadElement') {
              this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
            }
          }
        }
      }

      return this.finishNode(
        node,
        optional ? 'OptionalCallExpression' : 'CallExpression',
      );
    }

    parseCallExpressionArguments(
      close,
      possibleAsyncArrow,
      dynamicImport,
      allowPlaceholder,
      nodeForExtra,
    ) {
      const elts = [];
      let first = true;
      const oldInFSharpPipelineDirectBody = this.state
        .inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (
              dynamicImport &&
              !this.hasPlugin('importAssertions') &&
              !this.hasPlugin('moduleAttributes')
            ) {
              this.raise(
                this.state.lastTokStart,
                ErrorMessages.ImportCallArgumentTrailingComma,
              );
            }

            if (nodeForExtra) {
              this.addExtra(
                nodeForExtra,
                'trailingComma',
                this.state.lastTokStart,
              );
            }

            this.next();
            break;
          }
        }

        elts.push(
          this.parseExprListItem(
            false,
            possibleAsyncArrow ? new ExpressionErrors() : undefined,
            possibleAsyncArrow
              ? {
                  start: 0,
                }
              : undefined,
            allowPlaceholder,
          ),
        );
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }

    shouldParseAsyncArrow() {
      return this.match(types.arrow) && !this.canInsertSemicolon();
    }

    parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.expect(types.arrow);
      this.parseArrowExpression(
        node,
        call.arguments,
        true,
        (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma,
      );
      return node;
    }

    parseNoCallExpr() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(
        this.parseExprAtom(),
        startPos,
        startLoc,
        true,
      );
    }

    parseExprAtom(refExpressionErrors) {
      if (this.state.type === types.slash) this.readRegexp();
      const canBeArrow = this.state.potentialArrowAt === this.state.start;
      let node;

      switch (this.state.type) {
        case types._super:
          return this.parseSuper();

        case types._import:
          node = this.startNode();
          this.next();

          if (this.match(types.dot)) {
            return this.parseImportMetaProperty(node);
          }

          if (!this.match(types.parenL)) {
            this.raise(
              this.state.lastTokStart,
              ErrorMessages.UnsupportedImport,
            );
          }

          return this.finishNode(node, 'Import');

        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, 'ThisExpression');

        case types.name: {
          const containsEsc = this.state.containsEsc;
          const id = this.parseIdentifier();

          if (
            !containsEsc &&
            id.name === 'async' &&
            !this.canInsertSemicolon()
          ) {
            if (this.match(types._function)) {
              const last = this.state.context.length - 1;

              if (this.state.context[last] !== types$1.functionStatement) {
                throw new Error('Internal error');
              }

              this.state.context[last] = types$1.functionExpression;
              this.next();
              return this.parseFunction(
                this.startNodeAtNode(id),
                undefined,
                true,
              );
            } else if (this.match(types.name)) {
              return this.parseAsyncArrowUnaryFunction(id);
            }
          }

          if (
            canBeArrow &&
            this.match(types.arrow) &&
            !this.canInsertSemicolon()
          ) {
            this.next();
            return this.parseArrowExpression(
              this.startNodeAtNode(id),
              [id],
              false,
            );
          }

          return id;
        }

        case types._do: {
          return this.parseDo();
        }

        case types.regexp: {
          const value = this.state.value;
          node = this.parseLiteral(value.value, 'RegExpLiteral');
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        }

        case types.num:
          return this.parseLiteral(this.state.value, 'NumericLiteral');

        case types.bigint:
          return this.parseLiteral(this.state.value, 'BigIntLiteral');

        case types.decimal:
          return this.parseLiteral(this.state.value, 'DecimalLiteral');

        case types.string:
          return this.parseLiteral(this.state.value, 'StringLiteral');

        case types._null:
          node = this.startNode();
          this.next();
          return this.finishNode(node, 'NullLiteral');

        case types._true:
        case types._false:
          return this.parseBooleanLiteral();

        case types.parenL:
          return this.parseParenAndDistinguishExpression(canBeArrow);

        case types.bracketBarL:
        case types.bracketHashL: {
          return this.parseArrayLike(
            this.state.type === types.bracketBarL
              ? types.bracketBarR
              : types.bracketR,
            false,
            true,
            refExpressionErrors,
          );
        }

        case types.bracketL: {
          return this.parseArrayLike(
            types.bracketR,
            true,
            false,
            refExpressionErrors,
          );
        }

        case types.braceBarL:
        case types.braceHashL: {
          return this.parseObjectLike(
            this.state.type === types.braceBarL
              ? types.braceBarR
              : types.braceR,
            false,
            true,
            refExpressionErrors,
          );
        }

        case types.braceL: {
          return this.parseObjectLike(
            types.braceR,
            false,
            false,
            refExpressionErrors,
          );
        }

        case types._function:
          return this.parseFunctionOrFunctionSent();

        case types.at:
          this.parseDecorators();

        case types._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types._new:
          return this.parseNewOrNewTarget();

        case types.backQuote:
          return this.parseTemplate(false);

        case types.doubleColon: {
          node = this.startNode();
          this.next();
          node.object = null;
          const callee = (node.callee = this.parseNoCallExpr());

          if (callee.type === 'MemberExpression') {
            return this.finishNode(node, 'BindExpression');
          } else {
            throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
          }
        }

        case types.hash: {
          if (this.state.inPipeline) {
            node = this.startNode();

            if (
              this.getPluginOption('pipelineOperator', 'proposal') !== 'smart'
            ) {
              this.raise(
                node.start,
                ErrorMessages.PrimaryTopicRequiresSmartPipeline,
              );
            }

            this.next();

            if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
              this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);
            }

            this.registerTopicReference();
            return this.finishNode(node, 'PipelinePrimaryTopicReference');
          }

          const nextCh = this.input.codePointAt(this.state.end);

          if (isIdentifierStart(nextCh) || nextCh === 92) {
            const start = this.state.start;
            node = this.parseMaybePrivateName(true);

            if (this.match(types._in)) {
              this.expectPlugin('privateIn');
              this.classScope.usePrivateName(
                this.getPrivateNameSV(node),
                node.start,
              );
            } else if (this.hasPlugin('privateIn')) {
              this.raise(
                this.state.start,
                ErrorMessages.PrivateInExpectedIn,
                this.getPrivateNameSV(node),
              );
            } else {
              throw this.unexpected(start);
            }

            return node;
          }
        }

        case types.relational: {
          if (this.state.value === '<') {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());

            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(['jsx', 'flow', 'typescript']);
            }
          }
        }

        default:
          throw this.unexpected();
      }
    }

    parseAsyncArrowUnaryFunction(id) {
      const node = this.startNodeAtNode(id);
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      const params = [this.parseIdentifier()];
      this.prodParam.exit();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
      }

      this.expect(types.arrow);
      this.parseArrowExpression(node, params, true);
      return node;
    }

    parseDo() {
      this.expectPlugin('doExpressions');
      const node = this.startNode();
      this.next();
      const oldLabels = this.state.labels;
      this.state.labels = [];
      node.body = this.parseBlock();
      this.state.labels = oldLabels;
      return this.finishNode(node, 'DoExpression');
    }

    parseSuper() {
      const node = this.startNode();
      this.next();

      if (
        this.match(types.parenL) &&
        !this.scope.allowDirectSuper &&
        !this.options.allowSuperOutsideMethod
      ) {
        this.raise(node.start, ErrorMessages.SuperNotAllowed);
      } else if (
        !this.scope.allowSuper &&
        !this.options.allowSuperOutsideMethod
      ) {
        this.raise(node.start, ErrorMessages.UnexpectedSuper);
      }

      if (
        !this.match(types.parenL) &&
        !this.match(types.bracketL) &&
        !this.match(types.dot)
      ) {
        this.raise(node.start, ErrorMessages.UnsupportedSuper);
      }

      return this.finishNode(node, 'Super');
    }

    parseBooleanLiteral() {
      const node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, 'BooleanLiteral');
    }

    parseMaybePrivateName(isPrivateNameAllowed) {
      const isPrivate = this.match(types.hash);

      if (isPrivate) {
        this.expectOnePlugin(['classPrivateProperties', 'classPrivateMethods']);

        if (!isPrivateNameAllowed) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);
        }

        const node = this.startNode();
        this.next();
        this.assertNoSpace('Unexpected space between # and identifier');
        node.id = this.parseIdentifier(true);
        return this.finishNode(node, 'PrivateName');
      } else {
        return this.parseIdentifier(true);
      }
    }

    parseFunctionOrFunctionSent() {
      const node = this.startNode();
      this.next();

      if (this.prodParam.hasYield && this.match(types.dot)) {
        const meta = this.createIdentifier(
          this.startNodeAtNode(node),
          'function',
        );
        this.next();
        return this.parseMetaProperty(node, meta, 'sent');
      }

      return this.parseFunction(node);
    }

    parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === 'function' && propertyName === 'sent') {
        if (this.isContextual(propertyName)) {
          this.expectPlugin('functionSent');
        } else if (!this.hasPlugin('functionSent')) {
          this.unexpected();
        }
      }

      const containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(
          node.property.start,
          ErrorMessages.UnsupportedMetaProperty,
          meta.name,
          propertyName,
        );
      }

      return this.finishNode(node, 'MetaProperty');
    }

    parseImportMetaProperty(node) {
      const id = this.createIdentifier(this.startNodeAtNode(node), 'import');
      this.next();

      if (this.isContextual('meta')) {
        if (!this.inModule) {
          this.raiseWithData(
            id.start,
            {
              code: 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
            },
            ErrorMessages.ImportMetaOutsideModule,
          );
        }

        this.sawUnambiguousESM = true;
      }

      return this.parseMetaProperty(node, id, 'meta');
    }

    parseLiteral(value, type, startPos, startLoc) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      const node = this.startNodeAt(startPos, startLoc);
      this.addExtra(node, 'rawValue', value);
      this.addExtra(node, 'raw', this.input.slice(startPos, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }

    parseParenAndDistinguishExpression(canBeArrow) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldInFSharpPipelineDirectBody = this.state
        .inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      const innerStartPos = this.state.start;
      const innerStartLoc = this.state.startLoc;
      const exprList = [];
      const refExpressionErrors = new ExpressionErrors();
      const refNeedsArrowPos = {
        start: 0,
      };
      let first = true;
      let spreadStart;
      let optionalCommaStart;

      while (!this.match(types.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma, refNeedsArrowPos.start || null);

          if (this.match(types.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types.ellipsis)) {
          const spreadNodeStartPos = this.state.start;
          const spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(
            this.parseParenItem(
              this.parseRestBinding(),
              spreadNodeStartPos,
              spreadNodeStartLoc,
            ),
          );
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(
            this.parseMaybeAssignAllowIn(
              refExpressionErrors,
              this.parseParenItem,
              refNeedsArrowPos,
            ),
          );
        }
      }

      const innerEndPos = this.state.lastTokEnd;
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(types.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startPos, startLoc);

      if (
        canBeArrow &&
        this.shouldParseArrow() &&
        (arrowNode = this.parseArrow(arrowNode))
      ) {
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      this.expressionScope.exit();

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);
      this.checkExpressionErrors(refExpressionErrors, true);
      if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, 'SequenceExpression', innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, 'parenthesized', true);
        this.addExtra(val, 'parenStart', startPos);
        return val;
      }

      const parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, 'ParenthesizedExpression');
      return parenExpression;
    }

    shouldParseArrow() {
      return !this.canInsertSemicolon();
    }

    parseArrow(node) {
      if (this.eat(types.arrow)) {
        return node;
      }
    }

    parseParenItem(node, startPos, startLoc) {
      return node;
    }

    parseNewOrNewTarget() {
      const node = this.startNode();
      this.next();

      if (this.match(types.dot)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), 'new');
        this.next();
        const metaProp = this.parseMetaProperty(node, meta, 'target');

        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          let error = ErrorMessages.UnexpectedNewTarget;

          if (this.hasPlugin('classProperties')) {
            error += ' or class properties';
          }

          this.raise(metaProp.start, error);
        }

        return metaProp;
      }

      return this.parseNew(node);
    }

    parseNew(node) {
      node.callee = this.parseNoCallExpr();

      if (node.callee.type === 'Import') {
        this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
      } else if (this.isOptionalChain(node.callee)) {
        this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
      } else if (this.eat(types.questionDot)) {
        this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
      }

      this.parseNewArguments(node);
      return this.finishNode(node, 'NewExpression');
    }

    parseNewArguments(node) {
      if (this.eat(types.parenL)) {
        const args = this.parseExprList(types.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    }

    parseTemplateElement(isTagged) {
      const elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(
            this.state.start + 1,
            ErrorMessages.InvalidEscapeSequenceTemplate,
          );
        }
      }

      elem.value = {
        raw: this.input
          .slice(this.state.start, this.state.end)
          .replace(/\r\n?/g, '\n'),
        cooked: this.state.value,
      };
      this.next();
      elem.tail = this.match(types.backQuote);
      return this.finishNode(elem, 'TemplateElement');
    }

    parseTemplate(isTagged) {
      const node = this.startNode();
      this.next();
      node.expressions = [];
      let curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseTemplateSubstitution());
        this.expect(types.braceR);
        node.quasis.push((curElt = this.parseTemplateElement(isTagged)));
      }

      this.next();
      return this.finishNode(node, 'TemplateLiteral');
    }

    parseTemplateSubstitution() {
      return this.parseExpression();
    }

    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin('recordAndTuple');
      }

      const oldInFSharpPipelineDirectBody = this.state
        .inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const propHash = Object.create(null);
      let first = true;
      const node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            this.addExtra(node, 'trailingComma', this.state.lastTokStart);
            break;
          }
        }

        const prop = this.parsePropertyDefinition(
          isPattern,
          refExpressionErrors,
        );

        if (!isPattern) {
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }

        if (
          isRecord &&
          !this.isObjectProperty(prop) &&
          prop.type !== 'SpreadElement'
        ) {
          this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
        }

        if (prop.shorthand) {
          this.addExtra(prop, 'shorthand', true);
        }

        node.properties.push(prop);
      }

      this.state.exprAllowed = false;
      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type = 'ObjectExpression';

      if (isPattern) {
        type = 'ObjectPattern';
      } else if (isRecord) {
        type = 'RecordExpression';
      }

      return this.finishNode(node, type);
    }

    maybeAsyncOrAccessorProp(prop) {
      return (
        !prop.computed &&
        prop.key.type === 'Identifier' &&
        (this.isLiteralPropertyName() ||
          this.match(types.bracketL) ||
          this.match(types.star))
      );
    }

    parsePropertyDefinition(isPattern, refExpressionErrors) {
      let decorators = [];

      if (this.match(types.at)) {
        if (this.hasPlugin('decorators')) {
          this.raise(
            this.state.start,
            ErrorMessages.UnsupportedPropertyDecorator,
          );
        }

        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      const prop = this.startNode();
      let isGenerator = false;
      let isAsync = false;
      let isAccessor = false;
      let startPos;
      let startLoc;

      if (this.match(types.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, 'RestElement');
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types.star);
      }

      const containsEsc = this.state.containsEsc;
      const key = this.parsePropertyName(prop, false);

      if (
        !isPattern &&
        !isGenerator &&
        !containsEsc &&
        this.maybeAsyncOrAccessorProp(prop)
      ) {
        const keyName = key.name;

        if (keyName === 'async' && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          isGenerator = this.eat(types.star);
          this.parsePropertyName(prop, false);
        }

        if (keyName === 'get' || keyName === 'set') {
          isAccessor = true;
          prop.kind = keyName;

          if (this.match(types.star)) {
            isGenerator = true;
            this.raise(
              this.state.pos,
              ErrorMessages.AccessorIsGenerator,
              keyName,
            );
            this.next();
          }

          this.parsePropertyName(prop, false);
        }
      }

      this.parseObjPropValue(
        prop,
        startPos,
        startLoc,
        isGenerator,
        isAsync,
        isPattern,
        isAccessor,
        refExpressionErrors,
      );
      return prop;
    }

    getGetterSetterExpectedParamCount(method) {
      return method.kind === 'get' ? 0 : 1;
    }

    getObjectOrClassMethodParams(method) {
      return method.params;
    }

    checkGetterSetterParams(method) {
      var _params;

      const paramCount = this.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      const start = method.start;

      if (params.length !== paramCount) {
        if (method.kind === 'get') {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }

      if (
        method.kind === 'set' &&
        ((_params = params[params.length - 1]) == null
          ? void 0
          : _params.type) === 'RestElement'
      ) {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }

    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        this.parseMethod(
          prop,
          isGenerator,
          false,
          false,
          false,
          'ObjectMethod',
        );
        this.checkGetterSetterParams(prop);
        return prop;
      }

      if (isAsync || isGenerator || this.match(types.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = 'method';
        prop.method = true;
        return this.parseMethod(
          prop,
          isGenerator,
          isAsync,
          false,
          false,
          'ObjectMethod',
        );
      }
    }

    parseObjectProperty(
      prop,
      startPos,
      startLoc,
      isPattern,
      refExpressionErrors,
    ) {
      prop.shorthand = false;

      if (this.eat(types.colon)) {
        prop.value = isPattern
          ? this.parseMaybeDefault(this.state.start, this.state.startLoc)
          : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, 'ObjectProperty');
      }

      if (!prop.computed && prop.key.type === 'Identifier') {
        this.checkReservedWord(prop.key.name, prop.key.start, true, false);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(
            startPos,
            startLoc,
            prop.key.__clone(),
          );
        } else if (this.match(types.eq) && refExpressionErrors) {
          if (refExpressionErrors.shorthandAssign === -1) {
            refExpressionErrors.shorthandAssign = this.state.start;
          }

          prop.value = this.parseMaybeDefault(
            startPos,
            startLoc,
            prop.key.__clone(),
          );
        } else {
          prop.value = prop.key.__clone();
        }

        prop.shorthand = true;
        return this.finishNode(prop, 'ObjectProperty');
      }
    }

    parseObjPropValue(
      prop,
      startPos,
      startLoc,
      isGenerator,
      isAsync,
      isPattern,
      isAccessor,
      refExpressionErrors,
    ) {
      const node =
        this.parseObjectMethod(
          prop,
          isGenerator,
          isAsync,
          isPattern,
          isAccessor,
        ) ||
        this.parseObjectProperty(
          prop,
          startPos,
          startLoc,
          isPattern,
          refExpressionErrors,
        );
      if (!node) this.unexpected();
      return node;
    }

    parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(types.bracketR);
      } else {
        const oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        prop.key =
          this.match(types.num) ||
          this.match(types.string) ||
          this.match(types.bigint) ||
          this.match(types.decimal)
            ? this.parseExprAtom()
            : this.parseMaybePrivateName(isPrivateNameAllowed);

        if (!this.isPrivateName(prop.key)) {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    }

    initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    }

    parseMethod(
      node,
      isGenerator,
      isAsync,
      isConstructor,
      allowDirectSuper,
      type,
      inClassScope = false,
    ) {
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      const allowModifiers = isConstructor;
      this.scope.enter(
        SCOPE_FUNCTION |
          SCOPE_SUPER |
          (inClassScope ? SCOPE_CLASS : 0) |
          (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0),
      );
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return node;
    }

    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin('recordAndTuple');
      }

      const oldInFSharpPipelineDirectBody = this.state
        .inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const node = this.startNode();
      this.next();
      node.elements = this.parseExprList(
        close,
        !isTuple,
        refExpressionErrors,
        node,
      );
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(
        node,
        isTuple ? 'TupleExpression' : 'ArrayExpression',
      );
    }

    parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      let flags = functionFlags(isAsync, false);

      if (!this.match(types.bracketL) && this.prodParam.hasIn) {
        flags |= PARAM_IN;
      }

      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;

      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaPos);
      }

      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, 'ArrowFunctionExpression');
    }

    setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos, false);
    }

    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    }

    parseFunctionBody(node, allowExpression, isMethod = false) {
      const isExpression = allowExpression && !this.match(types.braceL);
      this.expressionScope.enter(newExpressionScope());

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        const oldStrict = this.state.strict;
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
          const nonSimple = !this.isSimpleParamList(node.params);

          if (hasStrictModeDirective && nonSimple) {
            const errorPos =
              (node.kind === 'method' || node.kind === 'constructor') &&
              !!node.key
                ? node.key.end
                : node.start;
            this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
          }

          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(
            node,
            !this.state.strict && !allowExpression && !isMethod && !nonSimple,
            allowExpression,
            strictModeChanged,
          );

          if (this.state.strict && node.id) {
            this.checkLVal(
              node.id,
              'function name',
              BIND_OUTSIDE,
              undefined,
              undefined,
              strictModeChanged,
            );
          }
        });
        this.prodParam.exit();
        this.expressionScope.exit();
        this.state.labels = oldLabels;
      }
    }

    isSimpleParamList(params) {
      for (let i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== 'Identifier') return false;
      }

      return true;
    }

    checkParams(
      node,
      allowDuplicates,
      isArrowFunction,
      strictModeChanged = true,
    ) {
      const checkClashes = new Set();

      for (const param of node.params) {
        this.checkLVal(
          param,
          'function parameter list',
          BIND_VAR,
          allowDuplicates ? null : checkClashes,
          undefined,
          strictModeChanged,
        );
      }
    }

    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(
                nodeForExtra,
                'trailingComma',
                this.state.lastTokStart,
              );
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }

      return elts;
    }

    parseExprListItem(
      allowEmpty,
      refExpressionErrors,
      refNeedsArrowPos,
      allowPlaceholder,
    ) {
      let elt;

      if (this.match(types.comma)) {
        if (!allowEmpty) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ',');
        }

        elt = null;
      } else if (this.match(types.ellipsis)) {
        const spreadNodeStartPos = this.state.start;
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(
          this.parseSpread(refExpressionErrors, refNeedsArrowPos),
          spreadNodeStartPos,
          spreadNodeStartLoc,
        );
      } else if (this.match(types.question)) {
        this.expectPlugin('partialApplication');

        if (!allowPlaceholder) {
          this.raise(
            this.state.start,
            ErrorMessages.UnexpectedArgumentPlaceholder,
          );
        }

        const node = this.startNode();
        this.next();
        elt = this.finishNode(node, 'ArgumentPlaceholder');
      } else {
        elt = this.parseMaybeAssignAllowIn(
          refExpressionErrors,
          this.parseParenItem,
          refNeedsArrowPos,
        );
      }

      return elt;
    }

    parseIdentifier(liberal) {
      const node = this.startNode();
      const name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }

    createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, 'Identifier');
    }

    parseIdentifierName(pos, liberal) {
      let name;
      const {start, type} = this.state;

      if (type === types.name) {
        name = this.state.value;
      } else if (type.keyword) {
        name = type.keyword;
        const curContext = this.curContext();

        if (
          (type === types._class || type === types._function) &&
          (curContext === types$1.functionStatement ||
            curContext === types$1.functionExpression)
        ) {
          this.state.context.pop();
        }
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types.name;
      } else {
        this.checkReservedWord(name, start, !!type.keyword, false);
      }

      this.next();
      return name;
    }

    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (this.prodParam.hasYield && word === 'yield') {
        this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
        return;
      }

      if (word === 'await') {
        if (this.prodParam.hasAwait) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
          return;
        } else if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction) {
          this.raise(
            startLoc,
            ErrorMessages.AwaitBindingIdentifierInStaticBlock,
          );
          return;
        } else {
          this.expressionScope.recordAsyncArrowParametersError(
            startLoc,
            ErrorMessages.AwaitBindingIdentifier,
          );
        }
      }

      if (
        this.scope.inClass &&
        !this.scope.inNonArrowFunction &&
        word === 'arguments'
      ) {
        this.raise(startLoc, ErrorMessages.ArgumentsInClass);
        return;
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
        return;
      }

      const reservedTest = !this.state.strict
        ? isReservedWord
        : isBinding
        ? isStrictBindReservedWord
        : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
      }
    }

    isAwaitAllowed() {
      if (this.prodParam.hasAwait) return true;

      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }

      return false;
    }

    parseAwait(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      this.expressionScope.recordParameterInitializerError(
        node.start,
        ErrorMessages.AwaitExpressionFormalParameter,
      );

      if (this.eat(types.star)) {
        this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.isAmbiguousAwait()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary(null, true);
      }

      return this.finishNode(node, 'AwaitExpression');
    }

    isAmbiguousAwait() {
      return (
        this.hasPrecedingLineBreak() ||
        this.match(types.plusMin) ||
        this.match(types.parenL) ||
        this.match(types.bracketL) ||
        this.match(types.backQuote) ||
        this.match(types.regexp) ||
        this.match(types.slash) ||
        (this.hasPlugin('v8intrinsic') && this.match(types.modulo))
      );
    }

    parseYield() {
      const node = this.startNode();
      this.expressionScope.recordParameterInitializerError(
        node.start,
        ErrorMessages.YieldInParameter,
      );
      this.next();

      if (
        this.match(types.semi) ||
        (!this.match(types.star) && !this.state.type.startsExpr) ||
        this.hasPrecedingLineBreak()
      ) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign();
      }

      return this.finishNode(node, 'YieldExpression');
    }

    checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption('pipelineOperator', 'proposal') === 'smart') {
        if (left.type === 'SequenceExpression') {
          this.raise(
            leftStartPos,
            ErrorMessages.PipelineHeadSequenceExpression,
          );
        }
      }
    }

    parseSmartPipelineBody(childExpression, startPos, startLoc) {
      this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);
      return this.parseSmartPipelineBodyInStyle(
        childExpression,
        startPos,
        startLoc,
      );
    }

    checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {
      if (this.match(types.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
      } else if (childExpression.type === 'SequenceExpression') {
        this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
      }
    }

    parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {
      const bodyNode = this.startNodeAt(startPos, startLoc);
      const isSimpleReference = this.isSimpleReference(childExpression);

      if (isSimpleReference) {
        bodyNode.callee = childExpression;
      } else {
        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
          this.raise(startPos, ErrorMessages.PipelineTopicUnused);
        }

        bodyNode.expression = childExpression;
      }

      return this.finishNode(
        bodyNode,
        isSimpleReference ? 'PipelineBareFunction' : 'PipelineTopicExpression',
      );
    }

    isSimpleReference(expression) {
      switch (expression.type) {
        case 'MemberExpression':
          return (
            !expression.computed && this.isSimpleReference(expression.object)
          );

        case 'Identifier':
          return true;

        default:
          return false;
      }
    }

    withTopicPermittingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null,
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }

    withTopicForbiddingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null,
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }

    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }

    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToSet = PARAM_IN & ~flags;

      if (prodParamToSet) {
        this.prodParam.enter(flags | PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }

    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToClear = PARAM_IN & flags;

      if (prodParamToClear) {
        this.prodParam.enter(flags & ~PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }

    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }

    primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }

    topicReferenceWasUsedInCurrentTopicContext() {
      return (
        this.state.topicContext.maxTopicIndex != null &&
        this.state.topicContext.maxTopicIndex >= 0
      );
    }

    parseFSharpPipelineBody(prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state
        .inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const ret = this.parseExprOp(
        this.parseMaybeUnary(),
        startPos,
        startLoc,
        prec,
      );
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }

    parseModuleExpression() {
      this.expectPlugin('moduleBlocks');
      const node = this.startNode();
      this.next();
      this.eat(types.braceL);
      const revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      const program = this.startNode();

      try {
        node.body = this.parseProgram(program, types.braceR, 'module');
      } finally {
        revertScopes();
      }

      this.eat(types.braceR);
      return this.finishNode(node, 'ModuleExpression');
    }
  }

  const loopLabel = {
      kind: 'loop',
    },
    switchLabel = {
      kind: 'switch',
    };
  const FUNC_NO_FLAGS = 0b000,
    FUNC_STATEMENT = 0b001,
    FUNC_HANGING_STATEMENT = 0b010,
    FUNC_NULLABLE_ID = 0b100;
  const loneSurrogate = /[\uD800-\uDFFF]/u;

  class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
      file.program = this.parseProgram(program);
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = this.tokens;
      return this.finishNode(file, 'File');
    }

    parseProgram(
      program,
      end = types.eof,
      sourceType = this.options.sourceType,
    ) {
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);

      if (
        this.inModule &&
        !this.options.allowUndeclaredExports &&
        this.scope.undefinedExports.size > 0
      ) {
        for (const [name] of Array.from(this.scope.undefinedExports)) {
          const pos = this.scope.undefinedExports.get(name);
          this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
        }
      }

      return this.finishNode(program, 'Program');
    }

    stmtToDirective(stmt) {
      const expr = stmt.expression;
      const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      const directive = this.startNodeAt(stmt.start, stmt.loc.start);
      const raw = this.input.slice(expr.start, expr.end);
      const val = (directiveLiteral.value = raw.slice(1, -1));
      this.addExtra(directiveLiteral, 'raw', raw);
      this.addExtra(directiveLiteral, 'rawValue', val);
      directive.value = this.finishNodeAt(
        directiveLiteral,
        'DirectiveLiteral',
        expr.end,
        expr.loc.end,
      );
      return this.finishNodeAt(directive, 'Directive', stmt.end, stmt.loc.end);
    }

    parseInterpreterDirective() {
      if (!this.match(types.interpreterDirective)) {
        return null;
      }

      const node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, 'InterpreterDirective');
    }

    isLet(context) {
      if (!this.isContextual('let')) {
        return false;
      }

      return this.isLetKeyword(context);
    }

    isLetKeyword(context) {
      const next = this.nextTokenStart();
      const nextCh = this.input.charCodeAt(next);
      if (nextCh === 91) return true;
      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        let pos = next + 1;

        while (isIdentifierChar(this.input.charCodeAt(pos))) {
          ++pos;
        }

        const ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return true;
      }

      return false;
    }

    parseStatement(context, topLevel) {
      if (this.match(types.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    }

    parseStatementContent(context, topLevel) {
      let starttype = this.state.type;
      const node = this.startNode();
      let kind;

      if (this.isLet(context)) {
        starttype = types._var;
        kind = 'let';
      }

      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types._debugger:
          return this.parseDebuggerStatement(node);

        case types._do:
          return this.parseDoStatement(node);

        case types._for:
          return this.parseForStatement(node);

        case types._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, ErrorMessages.StrictFunction);
            } else if (context !== 'if' && context !== 'label') {
              this.raise(this.state.start, ErrorMessages.SloppyFunction);
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types._if:
          return this.parseIfStatement(node);

        case types._return:
          return this.parseReturnStatement(node);

        case types._switch:
          return this.parseSwitchStatement(node);

        case types._throw:
          return this.parseThrowStatement(node);

        case types._try:
          return this.parseTryStatement(node);

        case types._const:
        case types._var:
          kind = kind || this.state.value;

          if (context && kind !== 'var') {
            this.raise(
              this.state.start,
              ErrorMessages.UnexpectedLexicalDeclaration,
            );
          }

          return this.parseVarStatement(node, kind);

        case types._while:
          return this.parseWhileStatement(node);

        case types._with:
          return this.parseWithStatement(node);

        case types.braceL:
          return this.parseBlock();

        case types.semi:
          return this.parseEmptyStatement(node);

        case types._import: {
          const nextTokenCharCode = this.lookaheadCharCode();

          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }
        }

        case types._export: {
          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
          }

          this.next();
          let result;

          if (starttype === types._import) {
            result = this.parseImport(node);

            if (
              result.type === 'ImportDeclaration' &&
              (!result.importKind || result.importKind === 'value')
            ) {
              this.sawUnambiguousESM = true;
            }
          } else {
            result = this.parseExport(node);

            if (
              (result.type === 'ExportNamedDeclaration' &&
                (!result.exportKind || result.exportKind === 'value')) ||
              (result.type === 'ExportAllDeclaration' &&
                (!result.exportKind || result.exportKind === 'value')) ||
              result.type === 'ExportDefaultDeclaration'
            ) {
              this.sawUnambiguousESM = true;
            }
          }

          this.assertModuleNodeAllowed(node);
          return result;
        }

        default: {
          if (this.isAsyncFunction()) {
            if (context) {
              this.raise(
                this.state.start,
                ErrorMessages.AsyncFunctionInSingleStatementContext,
              );
            }

            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
        }
      }

      const maybeName = this.state.value;
      const expr = this.parseExpression();

      if (
        starttype === types.name &&
        expr.type === 'Identifier' &&
        this.eat(types.colon)
      ) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    }

    assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raiseWithData(
          node.start,
          {
            code: 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
          },
          ErrorMessages.ImportOutsideModule,
        );
      }
    }

    takeDecorators(node) {
      const decorators = this.state.decoratorStack[
        this.state.decoratorStack.length - 1
      ];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    }

    canHaveLeadingDecorator() {
      return this.match(types._class);
    }

    parseDecorators(allowExport) {
      const currentContextDecorators = this.state.decoratorStack[
        this.state.decoratorStack.length - 1
      ];

      while (this.match(types.at)) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (
          this.hasPlugin('decorators') &&
          !this.getPluginOption('decorators', 'decoratorsBeforeExport')
        ) {
          this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(
          this.state.start,
          ErrorMessages.UnexpectedLeadingDecorator,
        );
      }
    }

    parseDecorator() {
      this.expectOnePlugin(['decorators-legacy', 'decorators']);
      const node = this.startNode();
      this.next();

      if (this.hasPlugin('decorators')) {
        this.state.decoratorStack.push([]);
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let expr;

        if (this.eat(types.parenL)) {
          expr = this.parseExpression();
          this.expect(types.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types.dot)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.object = expr;
            node.property = this.parseIdentifier(true);
            node.computed = false;
            expr = this.finishNode(node, 'MemberExpression');
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, 'Decorator');
    }

    parseMaybeDecoratorArguments(expr) {
      if (this.eat(types.parenL)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, 'CallExpression');
      }

      return expr;
    }

    parseBreakContinueStatement(node, keyword) {
      const isBreak = keyword === 'break';
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(
        node,
        isBreak ? 'BreakStatement' : 'ContinueStatement',
      );
    }

    verifyBreakContinue(node, keyword) {
      const isBreak = keyword === 'break';
      let i;

      for (i = 0; i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === 'loop')) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
      }
    }

    parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, 'DebuggerStatement');
    }

    parseHeaderExpression() {
      this.expect(types.parenL);
      const val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    }

    parseDoStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(() =>
        this.parseStatement('do'),
      );
      this.state.labels.pop();
      this.expect(types._while);
      node.test = this.parseHeaderExpression();
      this.eat(types.semi);
      return this.finishNode(node, 'DoWhileStatement');
    }

    parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      let awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual('await')) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types.parenL);

      if (this.match(types.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      const startsWithLet = this.isContextual('let');
      const isLet = startsWithLet && this.isLetKeyword();

      if (this.match(types._var) || this.match(types._const) || isLet) {
        const init = this.startNode();
        const kind = isLet ? 'let' : this.state.value;
        this.next();
        this.parseVar(init, true, kind);
        this.finishNode(init, 'VariableDeclaration');

        if (
          (this.match(types._in) || this.isContextual('of')) &&
          init.declarations.length === 1
        ) {
          return this.parseForIn(node, init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, init);
      }

      const refExpressionErrors = new ExpressionErrors();
      const init = this.parseExpression(true, refExpressionErrors);
      const isForOf = this.isContextual('of');

      if (isForOf || this.match(types._in)) {
        if (isForOf && startsWithLet) {
          this.raise(init.start, ErrorMessages.ForOfLet);
        }

        this.toAssignable(init, true);
        const description = isForOf ? 'for-of statement' : 'for-in statement';
        this.checkLVal(init, description);
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }

    parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(
        node,
        FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT),
        isAsync,
      );
    }

    parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement('if');
      node.alternate = this.eat(types._else) ? this.parseStatement('if') : null;
      return this.finishNode(node, 'IfStatement');
    }

    parseReturnStatement(node) {
      if (
        !this.prodParam.hasReturn &&
        !this.options.allowReturnOutsideFunction
      ) {
        this.raise(this.state.start, ErrorMessages.IllegalReturn);
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, 'ReturnStatement');
    }

    parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      const cases = (node.cases = []);
      this.expect(types.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      let cur;

      for (let sawDefault; !this.match(types.braceR); ) {
        if (this.match(types._case) || this.match(types._default)) {
          const isCase = this.match(types._case);
          if (cur) this.finishNode(cur, 'SwitchCase');
          cases.push((cur = this.startNode()));
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(
                this.state.lastTokStart,
                ErrorMessages.MultipleDefaultsInSwitch,
              );
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, 'SwitchCase');
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, 'SwitchStatement');
    }

    parseThrowStatement(node) {
      this.next();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, 'ThrowStatement');
    }

    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      const simple = param.type === 'Identifier';
      this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(param, 'catch clause', BIND_LEXICAL);
      return param;
    }

    parseTryStatement(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types._catch)) {
        const clause = this.startNode();
        this.next();

        if (this.match(types.parenL)) {
          this.expect(types.parenL);
          clause.param = this.parseCatchClauseParam();
          this.expect(types.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withTopicForbiddingContext(() =>
          this.parseBlock(false, false),
        );
        this.scope.exit();
        node.handler = this.finishNode(clause, 'CatchClause');
      }

      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, ErrorMessages.NoCatchOrFinally);
      }

      return this.finishNode(node, 'TryStatement');
    }

    parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, 'VariableDeclaration');
    }

    parseWhileStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(() =>
        this.parseStatement('while'),
      );
      this.state.labels.pop();
      return this.finishNode(node, 'WhileStatement');
    }

    parseWithStatement(node) {
      if (this.state.strict) {
        this.raise(this.state.start, ErrorMessages.StrictWith);
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withTopicForbiddingContext(() =>
        this.parseStatement('with'),
      );
      return this.finishNode(node, 'WithStatement');
    }

    parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, 'EmptyStatement');
    }

    parseLabeledStatement(node, maybeName, expr, context) {
      for (const label of this.state.labels) {
        if (label.name === maybeName) {
          this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
        }
      }

      const kind = this.state.type.isLoop
        ? 'loop'
        : this.match(types._switch)
        ? 'switch'
        : null;

      for (let i = this.state.labels.length - 1; i >= 0; i--) {
        const label = this.state.labels[i];

        if (label.statementStart === node.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start,
      });
      node.body = this.parseStatement(
        context
          ? context.indexOf('label') === -1
            ? context + 'label'
            : context
          : 'label',
      );
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, 'LabeledStatement');
    }

    parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, 'ExpressionStatement');
    }

    parseBlock(
      allowDirectives = false,
      createNewLexicalScope = true,
      afterBlockParse,
    ) {
      const node = this.startNode();

      if (allowDirectives) {
        this.state.strictErrors.clear();
      }

      this.expect(types.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(
        node,
        allowDirectives,
        false,
        types.braceR,
        afterBlockParse,
      );

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, 'BlockStatement');
    }

    isValidDirective(stmt) {
      return (
        stmt.type === 'ExpressionStatement' &&
        stmt.expression.type === 'StringLiteral' &&
        !stmt.expression.extra.parenthesized
      );
    }

    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      const body = (node.body = []);
      const directives = (node.directives = []);
      this.parseBlockOrModuleBlockBody(
        body,
        allowDirectives ? directives : undefined,
        topLevel,
        end,
        afterBlockParse,
      );
    }

    parseBlockOrModuleBlockBody(
      body,
      directives,
      topLevel,
      end,
      afterBlockParse,
    ) {
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = false;
      let parsedNonDirective = false;

      while (!this.match(end)) {
        const stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            const directive = this.stmtToDirective(stmt);
            directives.push(directive);

            if (
              !hasStrictModeDirective &&
              directive.value.value === 'use strict'
            ) {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }

            continue;
          }

          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }

        body.push(stmt);
      }

      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }

      if (!oldStrict) {
        this.setStrict(false);
      }

      this.next();
    }

    parseFor(node, init) {
      node.init = init;
      this.semicolon(false);
      node.test = this.match(types.semi) ? null : this.parseExpression();
      this.semicolon(false);
      node.update = this.match(types.parenR) ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(() =>
        this.parseStatement('for'),
      );
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, 'ForStatement');
    }

    parseForIn(node, init, awaitAt) {
      const isForIn = this.match(types._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node.await = awaitAt > -1;
      }

      if (
        init.type === 'VariableDeclaration' &&
        init.declarations[0].init != null &&
        (!isForIn ||
          this.state.strict ||
          init.kind !== 'var' ||
          init.declarations[0].id.type !== 'Identifier')
      ) {
        this.raise(
          init.start,
          ErrorMessages.ForInOfLoopInitializer,
          isForIn ? 'for-in' : 'for-of',
        );
      } else if (init.type === 'AssignmentPattern') {
        this.raise(init.start, ErrorMessages.InvalidLhs, 'for-loop');
      }

      node.left = init;
      node.right = isForIn
        ? this.parseExpression()
        : this.parseMaybeAssignAllowIn();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(() =>
        this.parseStatement('for'),
      );
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(
        node,
        isForIn ? 'ForInStatement' : 'ForOfStatement',
      );
    }

    parseVar(node, isFor, kind) {
      const declarations = (node.declarations = []);
      const isTypescript = this.hasPlugin('typescript');
      node.kind = kind;

      for (;;) {
        const decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types.eq)) {
          decl.init = isFor
            ? this.parseMaybeAssignDisallowIn()
            : this.parseMaybeAssignAllowIn();
        } else {
          if (
            kind === 'const' &&
            !(this.match(types._in) || this.isContextual('of'))
          ) {
            if (!isTypescript) {
              this.raise(
                this.state.lastTokEnd,
                ErrorMessages.DeclarationMissingInitializer,
                'Const declarations',
              );
            }
          } else if (
            decl.id.type !== 'Identifier' &&
            !(isFor && (this.match(types._in) || this.isContextual('of')))
          ) {
            this.raise(
              this.state.lastTokEnd,
              ErrorMessages.DeclarationMissingInitializer,
              'Complex binding patterns',
            );
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, 'VariableDeclarator'));
        if (!this.eat(types.comma)) break;
      }

      return node;
    }

    parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(
        decl.id,
        'variable declaration',
        kind === 'var' ? BIND_VAR : BIND_LEXICAL,
        undefined,
        kind !== 'var',
      );
    }

    parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
      const isStatement = statement & FUNC_STATEMENT;
      const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types.star) && isHangingStatement) {
        this.raise(
          this.state.start,
          ErrorMessages.GeneratorInSingleStatementContext,
        );
      }

      node.generator = this.eat(types.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node, false);
      this.withTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(
          node,
          isStatement ? 'FunctionDeclaration' : 'FunctionExpression',
        );
      });
      this.prodParam.exit();
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }

    parseFunctionId(requireId) {
      return requireId || this.match(types.name)
        ? this.parseIdentifier()
        : null;
    }

    parseFunctionParams(node, allowModifiers) {
      this.expect(types.parenL);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(
        types.parenR,
        41,
        false,
        allowModifiers,
      );
      this.expressionScope.exit();
    }

    registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(
        node.id.name,
        this.state.strict || node.generator || node.async
          ? this.scope.treatFunctionsAsVar
            ? BIND_VAR
            : BIND_LEXICAL
          : BIND_FUNCTION,
        node.id.start,
      );
    }

    parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      const oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(
        node,
        isStatement ? 'ClassDeclaration' : 'ClassExpression',
      );
    }

    isClassProperty() {
      return (
        this.match(types.eq) ||
        this.match(types.semi) ||
        this.match(types.braceR)
      );
    }

    isClassMethod() {
      return this.match(types.parenL);
    }

    isNonstaticConstructor(method) {
      return (
        !method.computed &&
        !method.static &&
        (method.key.name === 'constructor' ||
          method.key.value === 'constructor')
      );
    }

    parseClassBody(constructorAllowsSuper, oldStrict) {
      this.classScope.enter();
      const state = {
        constructorAllowsSuper,
        hadConstructor: false,
      };
      let decorators = [];
      const classBody = this.startNode();
      classBody.body = [];
      this.expect(types.braceL);
      this.withTopicForbiddingContext(() => {
        while (!this.match(types.braceR)) {
          if (this.eat(types.semi)) {
            if (decorators.length > 0) {
              throw this.raise(
                this.state.lastTokEnd,
                ErrorMessages.DecoratorSemicolon,
              );
            }

            continue;
          }

          if (this.match(types.at)) {
            decorators.push(this.parseDecorator());
            continue;
          }

          const member = this.startNode();

          if (decorators.length) {
            member.decorators = decorators;
            this.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }

          this.parseClassMember(classBody, member, state);

          if (
            member.kind === 'constructor' &&
            member.decorators &&
            member.decorators.length > 0
          ) {
            this.raise(member.start, ErrorMessages.DecoratorConstructor);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();

      if (decorators.length) {
        throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
      }

      this.classScope.exit();
      return this.finishNode(classBody, 'ClassBody');
    }

    parseClassMemberFromModifier(classBody, member) {
      const key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        const method = member;
        method.kind = 'method';
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        const prop = member;
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }

      return false;
    }

    parseClassMember(classBody, member, state) {
      const isStatic = this.isContextual('static');

      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        if (this.eat(types.braceL)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }

    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const publicMethod = member;
      const privateMethod = member;
      const publicProp = member;
      const privateProp = member;
      const method = publicMethod;
      const publicMember = publicMethod;
      member.static = isStatic;

      if (this.eat(types.star)) {
        method.kind = 'method';
        this.parseClassElementName(method);

        if (this.isPrivateName(method.key)) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(
            publicMethod.key.start,
            ErrorMessages.ConstructorIsGenerator,
          );
        }

        this.pushClassMethod(
          classBody,
          publicMethod,
          true,
          false,
          false,
          false,
        );
        return;
      }

      const containsEsc = this.state.containsEsc;
      const key = this.parseClassElementName(member);
      const isPrivate = this.isPrivateName(key);
      const isSimple = key.type === 'Identifier';
      const maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = 'method';

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = 'constructor';

          if (state.hadConstructor && !this.hasPlugin('typescript')) {
            this.raise(key.start, ErrorMessages.DuplicateConstructor);
          }

          state.hadConstructor = true;
          allowsDirectSuper = state.constructorAllowsSuper;
        }

        this.pushClassMethod(
          classBody,
          publicMethod,
          false,
          false,
          isConstructor,
          allowsDirectSuper,
        );
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (
        isSimple &&
        key.name === 'async' &&
        !containsEsc &&
        !this.isLineTerminator()
      ) {
        const isGenerator = this.eat(types.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = 'method';
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (this.isPrivateName(method.key)) {
          this.pushClassPrivateMethod(
            classBody,
            privateMethod,
            isGenerator,
            true,
          );
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(
              publicMethod.key.start,
              ErrorMessages.ConstructorIsAsync,
            );
          }

          this.pushClassMethod(
            classBody,
            publicMethod,
            isGenerator,
            true,
            false,
            false,
          );
        }
      } else if (
        isSimple &&
        (key.name === 'get' || key.name === 'set') &&
        !containsEsc &&
        !(this.match(types.star) && this.isLineTerminator())
      ) {
        method.kind = key.name;
        this.parseClassElementName(publicMethod);

        if (this.isPrivateName(method.key)) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(
              publicMethod.key.start,
              ErrorMessages.ConstructorIsAccessor,
            );
          }

          this.pushClassMethod(
            classBody,
            publicMethod,
            false,
            false,
            false,
            false,
          );
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }

    parseClassElementName(member) {
      const key = this.parsePropertyName(member, true);

      if (
        !member.computed &&
        member.static &&
        (key.name === 'prototype' || key.value === 'prototype')
      ) {
        this.raise(key.start, ErrorMessages.StaticPrototype);
      }

      if (
        this.isPrivateName(key) &&
        this.getPrivateNameSV(key) === 'constructor'
      ) {
        this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);
      }

      return key;
    }

    parseClassStaticBlock(classBody, member) {
      var _member$decorators;

      this.expectPlugin('classStaticBlock', member.start);
      this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(PARAM);
      const body = (member.body = []);
      this.parseBlockOrModuleBlockBody(body, undefined, false, types.braceR);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, 'StaticBlock'));

      if (
        (_member$decorators = member.decorators) != null &&
        _member$decorators.length
      ) {
        this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
      }
    }

    pushClassProperty(classBody, prop) {
      if (
        !prop.computed &&
        (prop.key.name === 'constructor' || prop.key.value === 'constructor')
      ) {
        this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
      }

      classBody.body.push(this.parseClassProperty(prop));
    }

    pushClassPrivateProperty(classBody, prop) {
      this.expectPlugin('classPrivateProperties', prop.key.start);
      const node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(
        this.getPrivateNameSV(node.key),
        CLASS_ELEMENT_OTHER,
        node.key.start,
      );
    }

    pushClassMethod(
      classBody,
      method,
      isGenerator,
      isAsync,
      isConstructor,
      allowsDirectSuper,
    ) {
      classBody.body.push(
        this.parseMethod(
          method,
          isGenerator,
          isAsync,
          isConstructor,
          allowsDirectSuper,
          'ClassMethod',
          true,
        ),
      );
    }

    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      this.expectPlugin('classPrivateMethods', method.key.start);
      const node = this.parseMethod(
        method,
        isGenerator,
        isAsync,
        false,
        false,
        'ClassPrivateMethod',
        true,
      );
      classBody.body.push(node);
      const kind =
        node.kind === 'get'
          ? node.static
            ? CLASS_ELEMENT_STATIC_GETTER
            : CLASS_ELEMENT_INSTANCE_GETTER
          : node.kind === 'set'
          ? node.static
            ? CLASS_ELEMENT_STATIC_SETTER
            : CLASS_ELEMENT_INSTANCE_SETTER
          : CLASS_ELEMENT_OTHER;
      this.classScope.declarePrivateName(
        this.getPrivateNameSV(node.key),
        kind,
        node.key.start,
      );
    }

    parsePostMemberNameModifiers(methodOrProp) {}

    parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, 'ClassPrivateProperty');
    }

    parseClassProperty(node) {
      if (!node.typeAnnotation || this.match(types.eq)) {
        this.expectPlugin('classProperties');
      }

      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, 'ClassProperty');
    }

    parseInitializer(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(PARAM);
      node.value = this.eat(types.eq) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    }

    parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
      if (this.match(types.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, 'class name', bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, ErrorMessages.MissingClassName);
        }
      }
    }

    parseClassSuper(node) {
      node.superClass = this.eat(types._extends)
        ? this.parseExprSubscripts()
        : null;
    }

    parseExport(node) {
      const hasDefault = this.maybeParseExportDefaultSpecifier(node);
      const parseAfterDefault = !hasDefault || this.eat(types.comma);
      const hasStar = parseAfterDefault && this.eatExportStar(node);
      const hasNamespace =
        hasStar && this.maybeParseExportNamespaceSpecifier(node);
      const parseAfterNamespace =
        parseAfterDefault && (!hasNamespace || this.eat(types.comma));
      const isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, 'ExportAllDeclaration');
      }

      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (
        (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) ||
        (hasNamespace && parseAfterNamespace && !hasSpecifiers)
      ) {
        throw this.unexpected(null, types.braceL);
      }

      let hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, 'ExportNamedDeclaration');
      }

      if (this.eat(types._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, 'ExportDefaultDeclaration');
      }

      throw this.unexpected(null, types.braceL);
    }

    eatExportStar(node) {
      return this.eat(types.star);
    }

    maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin('exportDefaultFrom');
        const specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [
          this.finishNode(specifier, 'ExportDefaultSpecifier'),
        ];
        return true;
      }

      return false;
    }

    maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual('as')) {
        if (!node.specifiers) node.specifiers = [];
        const specifier = this.startNodeAt(
          this.state.lastTokStart,
          this.state.lastTokStartLoc,
        );
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(
          this.finishNode(specifier, 'ExportNamespaceSpecifier'),
        );
        return true;
      }

      return false;
    }

    maybeParseExportNamedSpecifiers(node) {
      if (this.match(types.braceL)) {
        if (!node.specifiers) node.specifiers = [];
        node.specifiers.push(...this.parseExportSpecifiers());
        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    }

    maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    }

    isAsyncFunction() {
      if (!this.isContextual('async')) return false;
      const next = this.nextTokenStart();
      return (
        !lineBreak.test(this.input.slice(this.state.pos, next)) &&
        this.isUnparsedContextual(next, 'function')
      );
    }

    parseExportDefaultExpression() {
      const expr = this.startNode();
      const isAsync = this.isAsyncFunction();

      if (this.match(types._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(
          expr,
          FUNC_STATEMENT | FUNC_NULLABLE_ID,
          isAsync,
        );
      } else if (this.match(types._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types.at)) {
        if (
          this.hasPlugin('decorators') &&
          this.getPluginOption('decorators', 'decoratorsBeforeExport')
        ) {
          this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (
        this.match(types._const) ||
        this.match(types._var) ||
        this.isLet()
      ) {
        throw this.raise(
          this.state.start,
          ErrorMessages.UnsupportedDefaultExport,
        );
      } else {
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
    }

    parseExportDeclaration(node) {
      return this.parseStatement(null);
    }

    isExportDefaultSpecifier() {
      if (this.match(types.name)) {
        const value = this.state.value;

        if ((value === 'async' && !this.state.containsEsc) || value === 'let') {
          return false;
        }

        if (
          (value === 'type' || value === 'interface') &&
          !this.state.containsEsc
        ) {
          const l = this.lookahead();

          if (
            (l.type === types.name && l.value !== 'from') ||
            l.type === types.braceL
          ) {
            this.expectOnePlugin(['flow', 'typescript']);
            return false;
          }
        }
      } else if (!this.match(types._default)) {
        return false;
      }

      const next = this.nextTokenStart();
      const hasFrom = this.isUnparsedContextual(next, 'from');

      if (
        this.input.charCodeAt(next) === 44 ||
        (this.match(types.name) && hasFrom)
      ) {
        return true;
      }

      if (this.match(types._default) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(
          this.nextTokenStartSince(next + 4),
        );
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }

      return false;
    }

    parseExportFrom(node, expect) {
      if (this.eatContextual('from')) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        const assertions = this.maybeParseImportAssertions();

        if (assertions) {
          node.assertions = assertions;
        }
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    }

    shouldParseExportDeclaration() {
      if (this.match(types.at)) {
        this.expectOnePlugin(['decorators', 'decorators-legacy']);

        if (this.hasPlugin('decorators')) {
          if (this.getPluginOption('decorators', 'decoratorsBeforeExport')) {
            this.unexpected(
              this.state.start,
              ErrorMessages.DecoratorBeforeExport,
            );
          } else {
            return true;
          }
        }
      }

      return (
        this.state.type.keyword === 'var' ||
        this.state.type.keyword === 'const' ||
        this.state.type.keyword === 'function' ||
        this.state.type.keyword === 'class' ||
        this.isLet() ||
        this.isAsyncFunction()
      );
    }

    checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, 'default');

          if (this.hasPlugin('exportDefaultFrom')) {
            var _declaration$extra;

            const declaration = node.declaration;

            if (
              declaration.type === 'Identifier' &&
              declaration.name === 'from' &&
              declaration.end - declaration.start === 4 &&
              !(
                (_declaration$extra = declaration.extra) != null &&
                _declaration$extra.parenthesized
              )
            ) {
              this.raise(
                declaration.start,
                ErrorMessages.ExportDefaultFromAsIdentifier,
              );
            }
          }
        } else if (node.specifiers && node.specifiers.length) {
          for (const specifier of node.specifiers) {
            const {exported} = specifier;
            const exportedName =
              exported.type === 'Identifier' ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportedName);

            if (!isFrom && specifier.local) {
              const {local} = specifier;

              if (local.type === 'StringLiteral') {
                this.raise(
                  specifier.start,
                  ErrorMessages.ExportBindingIsString,
                  local.value,
                  exportedName,
                );
              } else {
                this.checkReservedWord(local.name, local.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node.declaration) {
          if (
            node.declaration.type === 'FunctionDeclaration' ||
            node.declaration.type === 'ClassDeclaration'
          ) {
            const id = node.declaration.id;
            if (!id) throw new Error('Assertion failure');
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === 'VariableDeclaration') {
            for (const declaration of node.declaration.declarations) {
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }

      const currentContextDecorators = this.state.decoratorStack[
        this.state.decoratorStack.length - 1
      ];

      if (currentContextDecorators.length) {
        throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
      }
    }

    checkDeclaration(node) {
      if (node.type === 'Identifier') {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === 'ObjectPattern') {
        for (const prop of node.properties) {
          this.checkDeclaration(prop);
        }
      } else if (node.type === 'ArrayPattern') {
        for (const elem of node.elements) {
          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === 'ObjectProperty') {
        this.checkDeclaration(node.value);
      } else if (node.type === 'RestElement') {
        this.checkDeclaration(node.argument);
      } else if (node.type === 'AssignmentPattern') {
        this.checkDeclaration(node.left);
      }
    }

    checkDuplicateExports(node, name) {
      if (this.state.exportedIdentifiers.indexOf(name) > -1) {
        this.raise(
          node.start,
          name === 'default'
            ? ErrorMessages.DuplicateDefaultExport
            : ErrorMessages.DuplicateExport,
          name,
        );
      }

      this.state.exportedIdentifiers.push(name);
    }

    parseExportSpecifiers() {
      const nodes = [];
      let first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        const node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual('as')
          ? this.parseModuleExportName()
          : node.local.__clone();
        nodes.push(this.finishNode(node, 'ExportSpecifier'));
      }

      return nodes;
    }

    parseModuleExportName() {
      if (this.match(types.string)) {
        this.expectPlugin('moduleStringNames');
        const result = this.parseLiteral(this.state.value, 'StringLiteral');
        const surrogate = result.value.match(loneSurrogate);

        if (surrogate) {
          this.raise(
            result.start,
            ErrorMessages.ModuleExportNameHasLoneSurrogate,
            surrogate[0].charCodeAt(0).toString(16),
          );
        }

        return result;
      }

      return this.parseIdentifier(true);
    }

    parseImport(node) {
      node.specifiers = [];

      if (!this.match(types.string)) {
        const hasDefault = this.maybeParseDefaultImportSpecifier(node);
        const parseNext = !hasDefault || this.eat(types.comma);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual('from');
      }

      node.source = this.parseImportSource();
      const assertions = this.maybeParseImportAssertions();

      if (assertions) {
        node.assertions = assertions;
      } else {
        const attributes = this.maybeParseModuleAttributes();

        if (attributes) {
          node.attributes = attributes;
        }
      }

      this.semicolon();
      return this.finishNode(node, 'ImportDeclaration');
    }

    parseImportSource() {
      if (!this.match(types.string)) this.unexpected();
      return this.parseExprAtom();
    }

    shouldParseDefaultImport(node) {
      return this.match(types.name);
    }

    parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, type));
    }

    parseAssertEntries() {
      const attrs = [];
      const attrNames = new Set();

      do {
        if (this.match(types.braceR)) {
          break;
        }

        const node = this.startNode();
        const keyName = this.state.value;

        if (this.match(types.string)) {
          node.key = this.parseLiteral(keyName, 'StringLiteral');
        } else {
          node.key = this.parseIdentifier(true);
        }

        this.expect(types.colon);

        if (keyName !== 'type') {
          this.raise(
            node.key.start,
            ErrorMessages.ModuleAttributeDifferentFromType,
            keyName,
          );
        }

        if (attrNames.has(keyName)) {
          this.raise(
            node.key.start,
            ErrorMessages.ModuleAttributesWithDuplicateKeys,
            keyName,
          );
        }

        attrNames.add(keyName);

        if (!this.match(types.string)) {
          throw this.unexpected(
            this.state.start,
            ErrorMessages.ModuleAttributeInvalidValue,
          );
        }

        node.value = this.parseLiteral(this.state.value, 'StringLiteral');
        this.finishNode(node, 'ImportAttribute');
        attrs.push(node);
      } while (this.eat(types.comma));

      return attrs;
    }

    maybeParseModuleAttributes() {
      if (this.match(types._with) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin('moduleAttributes');
        this.next();
      } else {
        if (this.hasPlugin('moduleAttributes')) return [];
        return null;
      }

      const attrs = [];
      const attributes = new Set();

      do {
        const node = this.startNode();
        node.key = this.parseIdentifier(true);

        if (node.key.name !== 'type') {
          this.raise(
            node.key.start,
            ErrorMessages.ModuleAttributeDifferentFromType,
            node.key.name,
          );
        }

        if (attributes.has(node.key.name)) {
          this.raise(
            node.key.start,
            ErrorMessages.ModuleAttributesWithDuplicateKeys,
            node.key.name,
          );
        }

        attributes.add(node.key.name);
        this.expect(types.colon);

        if (!this.match(types.string)) {
          throw this.unexpected(
            this.state.start,
            ErrorMessages.ModuleAttributeInvalidValue,
          );
        }

        node.value = this.parseLiteral(this.state.value, 'StringLiteral');
        this.finishNode(node, 'ImportAttribute');
        attrs.push(node);
      } while (this.eat(types.comma));

      return attrs;
    }

    maybeParseImportAssertions() {
      if (this.isContextual('assert') && !this.hasPrecedingLineBreak()) {
        this.expectPlugin('importAssertions');
        this.next();
      } else {
        if (this.hasPlugin('importAssertions')) return [];
        return null;
      }

      this.eat(types.braceL);
      const attrs = this.parseAssertEntries();
      this.eat(types.braceR);
      return attrs;
    }

    maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(
          node,
          this.startNode(),
          'ImportDefaultSpecifier',
          'default import specifier',
        );
        return true;
      }

      return false;
    }

    maybeParseStarImportSpecifier(node) {
      if (this.match(types.star)) {
        const specifier = this.startNode();
        this.next();
        this.expectContextual('as');
        this.parseImportSpecifierLocal(
          node,
          specifier,
          'ImportNamespaceSpecifier',
          'import namespace specifier',
        );
        return true;
      }

      return false;
    }

    parseNamedImportSpecifiers(node) {
      let first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types.colon)) {
            throw this.raise(
              this.state.start,
              ErrorMessages.DestructureNamedImport,
            );
          }

          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    }

    parseImportSpecifier(node) {
      const specifier = this.startNode();
      specifier.imported = this.parseModuleExportName();

      if (this.eatContextual('as')) {
        specifier.local = this.parseIdentifier();
      } else {
        const {imported} = specifier;

        if (imported.type === 'StringLiteral') {
          throw this.raise(
            specifier.start,
            ErrorMessages.ImportBindingIsString,
            imported.value,
          );
        }

        this.checkReservedWord(imported.name, specifier.start, true, true);
        specifier.local = imported.__clone();
      }

      this.checkLVal(specifier.local, 'import specifier', BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, 'ImportSpecifier'));
    }
  }

  class Parser extends StatementParser {
    constructor(options, input) {
      options = getOptions(options);
      super(options, input);
      this.options = options;
      this.initializeScopes();
      this.plugins = pluginsMap(this.options.plugins);
      this.filename = options.sourceFilename;
    }

    getScopeHandler() {
      return ScopeHandler;
    }

    parse() {
      this.enterInitialScopes();
      const file = this.startNode();
      const program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }
  }

  function pluginsMap(plugins) {
    const pluginMap = new Map();

    for (const plugin of plugins) {
      const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
      if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }

    return pluginMap;
  }

  function parse(input, options) {
    var _options;

    if (
      ((_options = options) == null ? void 0 : _options.sourceType) ===
      'unambiguous'
    ) {
      options = Object.assign({}, options);

      try {
        options.sourceType = 'module';
        const parser = getParser(options, input);
        const ast = parser.parse();

        if (parser.sawUnambiguousESM) {
          return ast;
        }

        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = 'script';
            return getParser(options, input).parse();
          } catch (_unused) {}
        } else {
          ast.program.sourceType = 'script';
        }

        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = 'script';
          return getParser(options, input).parse();
        } catch (_unused2) {}

        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  }

  function parseExpression(input, options) {
    const parser = getParser(options, input);

    if (parser.options.strictMode) {
      parser.state.strict = true;
    }

    return parser.getExpression();
  }

  function getParser(options, input) {
    let cls = Parser;

    if (options != null && options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }

    return new cls(options, input);
  }

  const parserClassCache = {};

  function getParserClass(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter((name) =>
      hasPlugin(pluginsFromOptions, name),
    );
    const key = pluginList.join('/');
    let cls = parserClassCache[key];

    if (!cls) {
      cls = Parser;

      for (const plugin of pluginList) {
        cls = mixinPlugins[plugin](cls);
      }

      parserClassCache[key] = cls;
    }

    return cls;
  }

  var parse_1 = parse;
  var parseExpression_1 = parseExpression;
  var tokTypes = types;
  var lib = /*#__PURE__*/ Object.defineProperty(
    {
      parse: parse_1,
      parseExpression: parseExpression_1,
      tokTypes: tokTypes,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var commonjsGlobal =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : typeof self !== 'undefined'
      ? self
      : {};

  function getDefaultExportFromCjs(x) {
    return x &&
      x.__esModule &&
      Object.prototype.hasOwnProperty.call(x, 'default')
      ? x['default']
      : x;
  }

  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var a = Object.defineProperty({}, '__esModule', {value: true});
    Object.keys(n).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(
        a,
        k,
        d.get
          ? d
          : {
              enumerable: true,
              get: function () {
                return n[k];
              },
            },
      );
    });
    return a;
  }

  function createCommonjsModule(fn) {
    var module = {exports: {}};
    return fn(module, module.exports), module.exports;
  }

  var global$1 =
    typeof global !== 'undefined'
      ? global
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : {};

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js
  function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
  }

  function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
  }

  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;

  if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
  }

  if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      //normal enviroments in sane situations
      return setTimeout(fun, 0);
    } // if setTimeout wasn't available but was latter defined

    if (
      (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
      setTimeout
    ) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }

  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      //normal enviroments in sane situations
      return clearTimeout(marker);
    } // if clearTimeout wasn't available but was latter defined

    if (
      (cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &&
      clearTimeout
    ) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
        return cachedClearTimeout.call(this, marker);
      }
    }
  }

  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }

    draining = false;

    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }

    if (queue.length) {
      drainQueue();
    }
  }

  function drainQueue() {
    if (draining) {
      return;
    }

    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;

    while (len) {
      currentQueue = queue;
      queue = [];

      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }

      queueIndex = -1;
      len = queue.length;
    }

    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }

  function nextTick(fun) {
    var args = new Array(arguments.length - 1);

    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }

    queue.push(new Item(fun, args));

    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  } // v8 likes predictible objects

  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }

  Item.prototype.run = function () {
    this.fun.apply(null, this.array);
  };

  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues

  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;

  function binding(name) {
    throw new Error('process.binding is not supported');
  }

  function cwd() {
    return '/';
  }

  function chdir(dir) {
    throw new Error('process.chdir is not supported');
  }

  function umask() {
    return 0;
  } // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js

  var performance = global$1.performance || {};

  var performanceNow =
    performance.now ||
    performance.mozNow ||
    performance.msNow ||
    performance.oNow ||
    performance.webkitNow ||
    function () {
      return new Date().getTime();
    }; // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime

  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime % 1) * 1e9);

    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];

      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }

    return [seconds, nanoseconds];
  }

  var startTime = new Date();

  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var browser$1 = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime,
  };

  var _default = shallowEqual;

  function shallowEqual(actual, expected) {
    const keys = Object.keys(expected);

    for (const key of keys) {
      if (actual[key] !== expected[key]) {
        return false;
      }
    }

    return true;
  }

  var shallowEqual_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var isArrayExpression_1 = isArrayExpression;
  var isAssignmentExpression_1 = isAssignmentExpression;
  var isBinaryExpression_1 = isBinaryExpression;
  var isInterpreterDirective_1 = isInterpreterDirective;
  var isDirective_1 = isDirective;
  var isDirectiveLiteral_1 = isDirectiveLiteral;
  var isBlockStatement_1 = isBlockStatement;
  var isBreakStatement_1 = isBreakStatement;
  var isCallExpression_1 = isCallExpression;
  var isCatchClause_1 = isCatchClause;
  var isConditionalExpression_1 = isConditionalExpression;
  var isContinueStatement_1 = isContinueStatement;
  var isDebuggerStatement_1 = isDebuggerStatement;
  var isDoWhileStatement_1 = isDoWhileStatement;
  var isEmptyStatement_1 = isEmptyStatement;
  var isExpressionStatement_1 = isExpressionStatement;
  var isFile_1 = isFile;
  var isForInStatement_1 = isForInStatement;
  var isForStatement_1 = isForStatement;
  var isFunctionDeclaration_1 = isFunctionDeclaration;
  var isFunctionExpression_1 = isFunctionExpression;
  var isIdentifier_1 = isIdentifier;
  var isIfStatement_1 = isIfStatement;
  var isLabeledStatement_1 = isLabeledStatement;
  var isStringLiteral_1 = isStringLiteral;
  var isNumericLiteral_1 = isNumericLiteral;
  var isNullLiteral_1 = isNullLiteral;
  var isBooleanLiteral_1 = isBooleanLiteral;
  var isRegExpLiteral_1 = isRegExpLiteral;
  var isLogicalExpression_1 = isLogicalExpression;
  var isMemberExpression_1 = isMemberExpression;
  var isNewExpression_1 = isNewExpression;
  var isProgram_1 = isProgram;
  var isObjectExpression_1 = isObjectExpression;
  var isObjectMethod_1 = isObjectMethod;
  var isObjectProperty_1 = isObjectProperty;
  var isRestElement_1 = isRestElement;
  var isReturnStatement_1 = isReturnStatement;
  var isSequenceExpression_1 = isSequenceExpression;
  var isParenthesizedExpression_1 = isParenthesizedExpression;
  var isSwitchCase_1 = isSwitchCase;
  var isSwitchStatement_1 = isSwitchStatement;
  var isThisExpression_1 = isThisExpression;
  var isThrowStatement_1 = isThrowStatement;
  var isTryStatement_1 = isTryStatement;
  var isUnaryExpression_1 = isUnaryExpression;
  var isUpdateExpression_1 = isUpdateExpression;
  var isVariableDeclaration_1 = isVariableDeclaration;
  var isVariableDeclarator_1 = isVariableDeclarator;
  var isWhileStatement_1 = isWhileStatement;
  var isWithStatement_1 = isWithStatement;
  var isAssignmentPattern_1 = isAssignmentPattern;
  var isArrayPattern_1 = isArrayPattern;
  var isArrowFunctionExpression_1 = isArrowFunctionExpression;
  var isClassBody_1 = isClassBody;
  var isClassExpression_1 = isClassExpression;
  var isClassDeclaration_1 = isClassDeclaration;
  var isExportAllDeclaration_1 = isExportAllDeclaration;
  var isExportDefaultDeclaration_1 = isExportDefaultDeclaration;
  var isExportNamedDeclaration_1 = isExportNamedDeclaration;
  var isExportSpecifier_1 = isExportSpecifier;
  var isForOfStatement_1 = isForOfStatement;
  var isImportDeclaration_1 = isImportDeclaration;
  var isImportDefaultSpecifier_1 = isImportDefaultSpecifier;
  var isImportNamespaceSpecifier_1 = isImportNamespaceSpecifier;
  var isImportSpecifier_1 = isImportSpecifier;
  var isMetaProperty_1 = isMetaProperty;
  var isClassMethod_1 = isClassMethod;
  var isObjectPattern_1 = isObjectPattern;
  var isSpreadElement_1 = isSpreadElement;
  var isSuper_1 = isSuper;
  var isTaggedTemplateExpression_1 = isTaggedTemplateExpression;
  var isTemplateElement_1 = isTemplateElement;
  var isTemplateLiteral_1 = isTemplateLiteral;
  var isYieldExpression_1 = isYieldExpression;
  var isAwaitExpression_1 = isAwaitExpression;
  var isImport_1 = isImport;
  var isBigIntLiteral_1 = isBigIntLiteral;
  var isExportNamespaceSpecifier_1 = isExportNamespaceSpecifier;
  var isOptionalMemberExpression_1 = isOptionalMemberExpression;
  var isOptionalCallExpression_1 = isOptionalCallExpression;
  var isAnyTypeAnnotation_1 = isAnyTypeAnnotation;
  var isArrayTypeAnnotation_1 = isArrayTypeAnnotation;
  var isBooleanTypeAnnotation_1 = isBooleanTypeAnnotation;
  var isBooleanLiteralTypeAnnotation_1 = isBooleanLiteralTypeAnnotation;
  var isNullLiteralTypeAnnotation_1 = isNullLiteralTypeAnnotation;
  var isClassImplements_1 = isClassImplements;
  var isDeclareClass_1 = isDeclareClass;
  var isDeclareFunction_1 = isDeclareFunction;
  var isDeclareInterface_1 = isDeclareInterface;
  var isDeclareModule_1 = isDeclareModule;
  var isDeclareModuleExports_1 = isDeclareModuleExports;
  var isDeclareTypeAlias_1 = isDeclareTypeAlias;
  var isDeclareOpaqueType_1 = isDeclareOpaqueType;
  var isDeclareVariable_1 = isDeclareVariable;
  var isDeclareExportDeclaration_1 = isDeclareExportDeclaration;
  var isDeclareExportAllDeclaration_1 = isDeclareExportAllDeclaration;
  var isDeclaredPredicate_1 = isDeclaredPredicate;
  var isExistsTypeAnnotation_1 = isExistsTypeAnnotation;
  var isFunctionTypeAnnotation_1 = isFunctionTypeAnnotation;
  var isFunctionTypeParam_1 = isFunctionTypeParam;
  var isGenericTypeAnnotation_1 = isGenericTypeAnnotation;
  var isInferredPredicate_1 = isInferredPredicate;
  var isInterfaceExtends_1 = isInterfaceExtends;
  var isInterfaceDeclaration_1 = isInterfaceDeclaration;
  var isInterfaceTypeAnnotation_1 = isInterfaceTypeAnnotation;
  var isIntersectionTypeAnnotation_1 = isIntersectionTypeAnnotation;
  var isMixedTypeAnnotation_1 = isMixedTypeAnnotation;
  var isEmptyTypeAnnotation_1 = isEmptyTypeAnnotation;
  var isNullableTypeAnnotation_1 = isNullableTypeAnnotation;
  var isNumberLiteralTypeAnnotation_1 = isNumberLiteralTypeAnnotation;
  var isNumberTypeAnnotation_1 = isNumberTypeAnnotation;
  var isObjectTypeAnnotation_1 = isObjectTypeAnnotation;
  var isObjectTypeInternalSlot_1 = isObjectTypeInternalSlot;
  var isObjectTypeCallProperty_1 = isObjectTypeCallProperty;
  var isObjectTypeIndexer_1 = isObjectTypeIndexer;
  var isObjectTypeProperty_1 = isObjectTypeProperty;
  var isObjectTypeSpreadProperty_1 = isObjectTypeSpreadProperty;
  var isOpaqueType_1 = isOpaqueType;
  var isQualifiedTypeIdentifier_1 = isQualifiedTypeIdentifier;
  var isStringLiteralTypeAnnotation_1 = isStringLiteralTypeAnnotation;
  var isStringTypeAnnotation_1 = isStringTypeAnnotation;
  var isSymbolTypeAnnotation_1 = isSymbolTypeAnnotation;
  var isThisTypeAnnotation_1 = isThisTypeAnnotation;
  var isTupleTypeAnnotation_1 = isTupleTypeAnnotation;
  var isTypeofTypeAnnotation_1 = isTypeofTypeAnnotation;
  var isTypeAlias_1 = isTypeAlias;
  var isTypeAnnotation_1 = isTypeAnnotation;
  var isTypeCastExpression_1 = isTypeCastExpression;
  var isTypeParameter_1 = isTypeParameter;
  var isTypeParameterDeclaration_1 = isTypeParameterDeclaration;
  var isTypeParameterInstantiation_1 = isTypeParameterInstantiation;
  var isUnionTypeAnnotation_1 = isUnionTypeAnnotation;
  var isVariance_1 = isVariance;
  var isVoidTypeAnnotation_1 = isVoidTypeAnnotation;
  var isEnumDeclaration_1 = isEnumDeclaration;
  var isEnumBooleanBody_1 = isEnumBooleanBody;
  var isEnumNumberBody_1 = isEnumNumberBody;
  var isEnumStringBody_1 = isEnumStringBody;
  var isEnumSymbolBody_1 = isEnumSymbolBody;
  var isEnumBooleanMember_1 = isEnumBooleanMember;
  var isEnumNumberMember_1 = isEnumNumberMember;
  var isEnumStringMember_1 = isEnumStringMember;
  var isEnumDefaultedMember_1 = isEnumDefaultedMember;
  var isJSXAttribute_1 = isJSXAttribute;
  var isJSXClosingElement_1 = isJSXClosingElement;
  var isJSXElement_1 = isJSXElement;
  var isJSXEmptyExpression_1 = isJSXEmptyExpression;
  var isJSXExpressionContainer_1 = isJSXExpressionContainer;
  var isJSXSpreadChild_1 = isJSXSpreadChild;
  var isJSXIdentifier_1 = isJSXIdentifier;
  var isJSXMemberExpression_1 = isJSXMemberExpression;
  var isJSXNamespacedName_1 = isJSXNamespacedName;
  var isJSXOpeningElement_1 = isJSXOpeningElement;
  var isJSXSpreadAttribute_1 = isJSXSpreadAttribute;
  var isJSXText_1 = isJSXText;
  var isJSXFragment_1 = isJSXFragment;
  var isJSXOpeningFragment_1 = isJSXOpeningFragment;
  var isJSXClosingFragment_1 = isJSXClosingFragment;
  var isNoop_1 = isNoop;
  var isPlaceholder_1 = isPlaceholder;
  var isV8IntrinsicIdentifier_1 = isV8IntrinsicIdentifier;
  var isArgumentPlaceholder_1 = isArgumentPlaceholder;
  var isBindExpression_1 = isBindExpression;
  var isClassProperty_1 = isClassProperty;
  var isPipelineTopicExpression_1 = isPipelineTopicExpression;
  var isPipelineBareFunction_1 = isPipelineBareFunction;
  var isPipelinePrimaryTopicReference_1 = isPipelinePrimaryTopicReference;
  var isClassPrivateProperty_1 = isClassPrivateProperty;
  var isClassPrivateMethod_1 = isClassPrivateMethod;
  var isImportAttribute_1 = isImportAttribute;
  var isDecorator_1 = isDecorator;
  var isDoExpression_1 = isDoExpression;
  var isExportDefaultSpecifier_1 = isExportDefaultSpecifier;
  var isPrivateName_1 = isPrivateName;
  var isRecordExpression_1 = isRecordExpression;
  var isTupleExpression_1 = isTupleExpression;
  var isDecimalLiteral_1 = isDecimalLiteral;
  var isStaticBlock_1 = isStaticBlock;
  var isModuleExpression_1 = isModuleExpression;
  var isTSParameterProperty_1 = isTSParameterProperty;
  var isTSDeclareFunction_1 = isTSDeclareFunction;
  var isTSDeclareMethod_1 = isTSDeclareMethod;
  var isTSQualifiedName_1 = isTSQualifiedName;
  var isTSCallSignatureDeclaration_1 = isTSCallSignatureDeclaration;
  var isTSConstructSignatureDeclaration_1 = isTSConstructSignatureDeclaration;
  var isTSPropertySignature_1 = isTSPropertySignature;
  var isTSMethodSignature_1 = isTSMethodSignature;
  var isTSIndexSignature_1 = isTSIndexSignature;
  var isTSAnyKeyword_1 = isTSAnyKeyword;
  var isTSBooleanKeyword_1 = isTSBooleanKeyword;
  var isTSBigIntKeyword_1 = isTSBigIntKeyword;
  var isTSIntrinsicKeyword_1 = isTSIntrinsicKeyword;
  var isTSNeverKeyword_1 = isTSNeverKeyword;
  var isTSNullKeyword_1 = isTSNullKeyword;
  var isTSNumberKeyword_1 = isTSNumberKeyword;
  var isTSObjectKeyword_1 = isTSObjectKeyword;
  var isTSStringKeyword_1 = isTSStringKeyword;
  var isTSSymbolKeyword_1 = isTSSymbolKeyword;
  var isTSUndefinedKeyword_1 = isTSUndefinedKeyword;
  var isTSUnknownKeyword_1 = isTSUnknownKeyword;
  var isTSVoidKeyword_1 = isTSVoidKeyword;
  var isTSThisType_1 = isTSThisType;
  var isTSFunctionType_1 = isTSFunctionType;
  var isTSConstructorType_1 = isTSConstructorType;
  var isTSTypeReference_1 = isTSTypeReference;
  var isTSTypePredicate_1 = isTSTypePredicate;
  var isTSTypeQuery_1 = isTSTypeQuery;
  var isTSTypeLiteral_1 = isTSTypeLiteral;
  var isTSArrayType_1 = isTSArrayType;
  var isTSTupleType_1 = isTSTupleType;
  var isTSOptionalType_1 = isTSOptionalType;
  var isTSRestType_1 = isTSRestType;
  var isTSNamedTupleMember_1 = isTSNamedTupleMember;
  var isTSUnionType_1 = isTSUnionType;
  var isTSIntersectionType_1 = isTSIntersectionType;
  var isTSConditionalType_1 = isTSConditionalType;
  var isTSInferType_1 = isTSInferType;
  var isTSParenthesizedType_1 = isTSParenthesizedType;
  var isTSTypeOperator_1 = isTSTypeOperator;
  var isTSIndexedAccessType_1 = isTSIndexedAccessType;
  var isTSMappedType_1 = isTSMappedType;
  var isTSLiteralType_1 = isTSLiteralType;
  var isTSExpressionWithTypeArguments_1 = isTSExpressionWithTypeArguments;
  var isTSInterfaceDeclaration_1 = isTSInterfaceDeclaration;
  var isTSInterfaceBody_1 = isTSInterfaceBody;
  var isTSTypeAliasDeclaration_1 = isTSTypeAliasDeclaration;
  var isTSAsExpression_1 = isTSAsExpression;
  var isTSTypeAssertion_1 = isTSTypeAssertion;
  var isTSEnumDeclaration_1 = isTSEnumDeclaration;
  var isTSEnumMember_1 = isTSEnumMember;
  var isTSModuleDeclaration_1 = isTSModuleDeclaration;
  var isTSModuleBlock_1 = isTSModuleBlock;
  var isTSImportType_1 = isTSImportType;
  var isTSImportEqualsDeclaration_1 = isTSImportEqualsDeclaration;
  var isTSExternalModuleReference_1 = isTSExternalModuleReference;
  var isTSNonNullExpression_1 = isTSNonNullExpression;
  var isTSExportAssignment_1 = isTSExportAssignment;
  var isTSNamespaceExportDeclaration_1 = isTSNamespaceExportDeclaration;
  var isTSTypeAnnotation_1 = isTSTypeAnnotation;
  var isTSTypeParameterInstantiation_1 = isTSTypeParameterInstantiation;
  var isTSTypeParameterDeclaration_1 = isTSTypeParameterDeclaration;
  var isTSTypeParameter_1 = isTSTypeParameter;
  var isExpression_1 = isExpression;
  var isBinary_1 = isBinary;
  var isScopable_1 = isScopable;
  var isBlockParent_1 = isBlockParent;
  var isBlock_1 = isBlock;
  var isStatement_1 = isStatement;
  var isTerminatorless_1 = isTerminatorless;
  var isCompletionStatement_1 = isCompletionStatement;
  var isConditional_1 = isConditional;
  var isLoop_1 = isLoop$1;
  var isWhile_1 = isWhile;
  var isExpressionWrapper_1 = isExpressionWrapper;
  var isFor_1 = isFor;
  var isForXStatement_1 = isForXStatement;
  var isFunction_1 = isFunction;
  var isFunctionParent_1 = isFunctionParent;
  var isPureish_1 = isPureish;
  var isDeclaration_1 = isDeclaration;
  var isPatternLike_1 = isPatternLike;
  var isLVal_1 = isLVal;
  var isTSEntityName_1 = isTSEntityName;
  var isLiteral_1 = isLiteral;
  var isImmutable_1 = isImmutable;
  var isUserWhitespacable_1 = isUserWhitespacable;
  var isMethod_1 = isMethod;
  var isObjectMember_1 = isObjectMember;
  var isProperty_1 = isProperty;
  var isUnaryLike_1 = isUnaryLike;
  var isPattern_1 = isPattern;
  var isClass_1 = isClass;
  var isModuleDeclaration_1 = isModuleDeclaration;
  var isExportDeclaration_1 = isExportDeclaration;
  var isModuleSpecifier_1 = isModuleSpecifier;
  var isFlow_1 = isFlow;
  var isFlowType_1 = isFlowType;
  var isFlowBaseAnnotation_1 = isFlowBaseAnnotation;
  var isFlowDeclaration_1 = isFlowDeclaration;
  var isFlowPredicate_1 = isFlowPredicate;
  var isEnumBody_1 = isEnumBody;
  var isEnumMember_1 = isEnumMember;
  var isJSX_1 = isJSX;
  var isPrivate_1 = isPrivate;
  var isTSTypeElement_1 = isTSTypeElement;
  var isTSType_1 = isTSType;
  var isTSBaseType_1 = isTSBaseType;
  var isNumberLiteral_1 = isNumberLiteral;
  var isRegexLiteral_1 = isRegexLiteral;
  var isRestProperty_1 = isRestProperty;
  var isSpreadProperty_1 = isSpreadProperty;

  var _shallowEqual = _interopRequireDefault(shallowEqual_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function isArrayExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ArrayExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isAssignmentExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'AssignmentExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBinaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'BinaryExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isInterpreterDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'InterpreterDirective') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Directive') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DirectiveLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBlockStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'BlockStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBreakStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'BreakStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'CallExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isCatchClause(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'CatchClause') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isConditionalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ConditionalExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isContinueStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ContinueStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDebuggerStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DebuggerStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDoWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DoWhileStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEmptyStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EmptyStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExpressionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ExpressionStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'File') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isForInStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ForInStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isForStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ForStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'FunctionDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'FunctionExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Identifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isIfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'IfStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isLabeledStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'LabeledStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isStringLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'StringLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNumericLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'NumericLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNullLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'NullLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBooleanLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'BooleanLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isRegExpLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'RegExpLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isLogicalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'LogicalExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'MemberExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNewExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'NewExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isProgram(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Program') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectMethod') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isRestElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'RestElement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isReturnStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ReturnStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isSequenceExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'SequenceExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ParenthesizedExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isSwitchCase(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'SwitchCase') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isSwitchStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'SwitchStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isThisExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ThisExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isThrowStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ThrowStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTryStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TryStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isUnaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'UnaryExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isUpdateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'UpdateExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isVariableDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'VariableDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isVariableDeclarator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'VariableDeclarator') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'WhileStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isWithStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'WithStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isAssignmentPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'AssignmentPattern') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isArrayPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ArrayPattern') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ArrowFunctionExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClassBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ClassBody') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClassExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ClassExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClassDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ClassDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ExportAllDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ExportDefaultDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ExportNamedDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ExportSpecifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isForOfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ForOfStatement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isImportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ImportDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ImportDefaultSpecifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ImportNamespaceSpecifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isImportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ImportSpecifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isMetaProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'MetaProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClassMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ClassMethod') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectPattern') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isSpreadElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'SpreadElement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isSuper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Super') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TaggedTemplateExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTemplateElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TemplateElement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTemplateLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TemplateLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isYieldExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'YieldExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isAwaitExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'AwaitExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isImport(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Import') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBigIntLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'BigIntLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ExportNamespaceSpecifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'OptionalMemberExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'OptionalCallExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'AnyTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ArrayTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'BooleanTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'BooleanLiteralTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'NullLiteralTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClassImplements(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ClassImplements') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareClass') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareFunction') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareInterface(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareInterface') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareModule(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareModule') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareModuleExports') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareTypeAlias') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareOpaqueType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareVariable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareVariable') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareExportDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclareExportAllDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DeclaredPredicate') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ExistsTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'FunctionTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'FunctionTypeParam') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'GenericTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isInferredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'InferredPredicate') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isInterfaceExtends(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'InterfaceExtends') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'InterfaceDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'InterfaceTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'IntersectionTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'MixedTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EmptyTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'NullableTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'NumberLiteralTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'NumberTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectTypeInternalSlot') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectTypeCallProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectTypeIndexer') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectTypeProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ObjectTypeSpreadProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'OpaqueType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'QualifiedTypeIdentifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'StringLiteralTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'StringTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'SymbolTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ThisTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TupleTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TypeofTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TypeAlias') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeCastExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TypeCastExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TypeParameter') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TypeParameterDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TypeParameterInstantiation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'UnionTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isVariance(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Variance') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'VoidTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumBooleanBody') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumNumberBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumNumberBody') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumStringBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumStringBody') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumSymbolBody') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumBooleanMember') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumNumberMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumNumberMember') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumStringMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumStringMember') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'EnumDefaultedMember') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXAttribute') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXClosingElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXClosingElement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXElement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXEmptyExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXExpressionContainer') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXSpreadChild') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXIdentifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXMemberExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXNamespacedName') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXOpeningElement') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXSpreadAttribute') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXText(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXText') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXFragment') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXOpeningFragment') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'JSXClosingFragment') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Noop') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Placeholder') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'V8IntrinsicIdentifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ArgumentPlaceholder') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBindExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'BindExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClassProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ClassProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'PipelineTopicExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'PipelineBareFunction') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'PipelinePrimaryTopicReference') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ClassPrivateProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ClassPrivateMethod') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isImportAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ImportAttribute') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDecorator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'Decorator') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDoExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DoExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ExportDefaultSpecifier') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPrivateName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'PrivateName') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isRecordExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'RecordExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTupleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TupleExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDecimalLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'DecimalLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isStaticBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'StaticBlock') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isModuleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'ModuleExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSParameterProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSParameterProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSDeclareFunction') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSDeclareMethod') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSQualifiedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSQualifiedName') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSCallSignatureDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSConstructSignatureDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSPropertySignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSPropertySignature') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSMethodSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSMethodSignature') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSIndexSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSIndexSignature') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSAnyKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSBooleanKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSBigIntKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSIntrinsicKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSNeverKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNullKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSNullKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSNumberKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSObjectKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSStringKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSStringKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSSymbolKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSUndefinedKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSUnknownKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSVoidKeyword') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSThisType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSThisType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSFunctionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSFunctionType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSConstructorType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSConstructorType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeReference') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypePredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypePredicate') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeQuery(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeQuery') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSArrayType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSArrayType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTupleType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTupleType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSOptionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSOptionalType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSRestType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSRestType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSNamedTupleMember') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSUnionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSUnionType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSIntersectionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSIntersectionType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSConditionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSConditionalType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSInferType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSInferType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSParenthesizedType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeOperator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeOperator') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSIndexedAccessType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSMappedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSMappedType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSLiteralType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSLiteralType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSExpressionWithTypeArguments') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSInterfaceDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSInterfaceBody') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeAliasDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSAsExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSAsExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeAssertion') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSEnumDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSEnumMember') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSModuleDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSModuleBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSModuleBlock') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSImportType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSImportType') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSImportEqualsDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSExternalModuleReference') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSNonNullExpression') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSExportAssignment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSExportAssignment') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSNamespaceExportDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeAnnotation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeParameterInstantiation') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeParameterDeclaration') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'TSTypeParameter') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ArrayExpression' === nodeType ||
      'AssignmentExpression' === nodeType ||
      'BinaryExpression' === nodeType ||
      'CallExpression' === nodeType ||
      'ConditionalExpression' === nodeType ||
      'FunctionExpression' === nodeType ||
      'Identifier' === nodeType ||
      'StringLiteral' === nodeType ||
      'NumericLiteral' === nodeType ||
      'NullLiteral' === nodeType ||
      'BooleanLiteral' === nodeType ||
      'RegExpLiteral' === nodeType ||
      'LogicalExpression' === nodeType ||
      'MemberExpression' === nodeType ||
      'NewExpression' === nodeType ||
      'ObjectExpression' === nodeType ||
      'SequenceExpression' === nodeType ||
      'ParenthesizedExpression' === nodeType ||
      'ThisExpression' === nodeType ||
      'UnaryExpression' === nodeType ||
      'UpdateExpression' === nodeType ||
      'ArrowFunctionExpression' === nodeType ||
      'ClassExpression' === nodeType ||
      'MetaProperty' === nodeType ||
      'Super' === nodeType ||
      'TaggedTemplateExpression' === nodeType ||
      'TemplateLiteral' === nodeType ||
      'YieldExpression' === nodeType ||
      'AwaitExpression' === nodeType ||
      'Import' === nodeType ||
      'BigIntLiteral' === nodeType ||
      'OptionalMemberExpression' === nodeType ||
      'OptionalCallExpression' === nodeType ||
      'TypeCastExpression' === nodeType ||
      'JSXElement' === nodeType ||
      'JSXFragment' === nodeType ||
      'BindExpression' === nodeType ||
      'PipelinePrimaryTopicReference' === nodeType ||
      'DoExpression' === nodeType ||
      'RecordExpression' === nodeType ||
      'TupleExpression' === nodeType ||
      'DecimalLiteral' === nodeType ||
      'ModuleExpression' === nodeType ||
      'TSAsExpression' === nodeType ||
      'TSTypeAssertion' === nodeType ||
      'TSNonNullExpression' === nodeType ||
      (nodeType === 'Placeholder' &&
        ('Expression' === node.expectedNode ||
          'Identifier' === node.expectedNode ||
          'StringLiteral' === node.expectedNode))
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBinary(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ('BinaryExpression' === nodeType || 'LogicalExpression' === nodeType) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isScopable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'BlockStatement' === nodeType ||
      'CatchClause' === nodeType ||
      'DoWhileStatement' === nodeType ||
      'ForInStatement' === nodeType ||
      'ForStatement' === nodeType ||
      'FunctionDeclaration' === nodeType ||
      'FunctionExpression' === nodeType ||
      'Program' === nodeType ||
      'ObjectMethod' === nodeType ||
      'SwitchStatement' === nodeType ||
      'WhileStatement' === nodeType ||
      'ArrowFunctionExpression' === nodeType ||
      'ClassExpression' === nodeType ||
      'ClassDeclaration' === nodeType ||
      'ForOfStatement' === nodeType ||
      'ClassMethod' === nodeType ||
      'ClassPrivateMethod' === nodeType ||
      'StaticBlock' === nodeType ||
      'TSModuleBlock' === nodeType ||
      (nodeType === 'Placeholder' && 'BlockStatement' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBlockParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'BlockStatement' === nodeType ||
      'CatchClause' === nodeType ||
      'DoWhileStatement' === nodeType ||
      'ForInStatement' === nodeType ||
      'ForStatement' === nodeType ||
      'FunctionDeclaration' === nodeType ||
      'FunctionExpression' === nodeType ||
      'Program' === nodeType ||
      'ObjectMethod' === nodeType ||
      'SwitchStatement' === nodeType ||
      'WhileStatement' === nodeType ||
      'ArrowFunctionExpression' === nodeType ||
      'ForOfStatement' === nodeType ||
      'ClassMethod' === nodeType ||
      'ClassPrivateMethod' === nodeType ||
      'StaticBlock' === nodeType ||
      'TSModuleBlock' === nodeType ||
      (nodeType === 'Placeholder' && 'BlockStatement' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'BlockStatement' === nodeType ||
      'Program' === nodeType ||
      'TSModuleBlock' === nodeType ||
      (nodeType === 'Placeholder' && 'BlockStatement' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'BlockStatement' === nodeType ||
      'BreakStatement' === nodeType ||
      'ContinueStatement' === nodeType ||
      'DebuggerStatement' === nodeType ||
      'DoWhileStatement' === nodeType ||
      'EmptyStatement' === nodeType ||
      'ExpressionStatement' === nodeType ||
      'ForInStatement' === nodeType ||
      'ForStatement' === nodeType ||
      'FunctionDeclaration' === nodeType ||
      'IfStatement' === nodeType ||
      'LabeledStatement' === nodeType ||
      'ReturnStatement' === nodeType ||
      'SwitchStatement' === nodeType ||
      'ThrowStatement' === nodeType ||
      'TryStatement' === nodeType ||
      'VariableDeclaration' === nodeType ||
      'WhileStatement' === nodeType ||
      'WithStatement' === nodeType ||
      'ClassDeclaration' === nodeType ||
      'ExportAllDeclaration' === nodeType ||
      'ExportDefaultDeclaration' === nodeType ||
      'ExportNamedDeclaration' === nodeType ||
      'ForOfStatement' === nodeType ||
      'ImportDeclaration' === nodeType ||
      'DeclareClass' === nodeType ||
      'DeclareFunction' === nodeType ||
      'DeclareInterface' === nodeType ||
      'DeclareModule' === nodeType ||
      'DeclareModuleExports' === nodeType ||
      'DeclareTypeAlias' === nodeType ||
      'DeclareOpaqueType' === nodeType ||
      'DeclareVariable' === nodeType ||
      'DeclareExportDeclaration' === nodeType ||
      'DeclareExportAllDeclaration' === nodeType ||
      'InterfaceDeclaration' === nodeType ||
      'OpaqueType' === nodeType ||
      'TypeAlias' === nodeType ||
      'EnumDeclaration' === nodeType ||
      'TSDeclareFunction' === nodeType ||
      'TSInterfaceDeclaration' === nodeType ||
      'TSTypeAliasDeclaration' === nodeType ||
      'TSEnumDeclaration' === nodeType ||
      'TSModuleDeclaration' === nodeType ||
      'TSImportEqualsDeclaration' === nodeType ||
      'TSExportAssignment' === nodeType ||
      'TSNamespaceExportDeclaration' === nodeType ||
      (nodeType === 'Placeholder' &&
        ('Statement' === node.expectedNode ||
          'Declaration' === node.expectedNode ||
          'BlockStatement' === node.expectedNode))
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTerminatorless(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'BreakStatement' === nodeType ||
      'ContinueStatement' === nodeType ||
      'ReturnStatement' === nodeType ||
      'ThrowStatement' === nodeType ||
      'YieldExpression' === nodeType ||
      'AwaitExpression' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isCompletionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'BreakStatement' === nodeType ||
      'ContinueStatement' === nodeType ||
      'ReturnStatement' === nodeType ||
      'ThrowStatement' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isConditional(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ('ConditionalExpression' === nodeType || 'IfStatement' === nodeType) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isLoop$1(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'DoWhileStatement' === nodeType ||
      'ForInStatement' === nodeType ||
      'ForStatement' === nodeType ||
      'WhileStatement' === nodeType ||
      'ForOfStatement' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isWhile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ('DoWhileStatement' === nodeType || 'WhileStatement' === nodeType) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExpressionWrapper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ExpressionStatement' === nodeType ||
      'ParenthesizedExpression' === nodeType ||
      'TypeCastExpression' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFor(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ForInStatement' === nodeType ||
      'ForStatement' === nodeType ||
      'ForOfStatement' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isForXStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ('ForInStatement' === nodeType || 'ForOfStatement' === nodeType) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'FunctionDeclaration' === nodeType ||
      'FunctionExpression' === nodeType ||
      'ObjectMethod' === nodeType ||
      'ArrowFunctionExpression' === nodeType ||
      'ClassMethod' === nodeType ||
      'ClassPrivateMethod' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'FunctionDeclaration' === nodeType ||
      'FunctionExpression' === nodeType ||
      'ObjectMethod' === nodeType ||
      'ArrowFunctionExpression' === nodeType ||
      'ClassMethod' === nodeType ||
      'ClassPrivateMethod' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPureish(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'FunctionDeclaration' === nodeType ||
      'FunctionExpression' === nodeType ||
      'StringLiteral' === nodeType ||
      'NumericLiteral' === nodeType ||
      'NullLiteral' === nodeType ||
      'BooleanLiteral' === nodeType ||
      'RegExpLiteral' === nodeType ||
      'ArrowFunctionExpression' === nodeType ||
      'BigIntLiteral' === nodeType ||
      'DecimalLiteral' === nodeType ||
      (nodeType === 'Placeholder' && 'StringLiteral' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'FunctionDeclaration' === nodeType ||
      'VariableDeclaration' === nodeType ||
      'ClassDeclaration' === nodeType ||
      'ExportAllDeclaration' === nodeType ||
      'ExportDefaultDeclaration' === nodeType ||
      'ExportNamedDeclaration' === nodeType ||
      'ImportDeclaration' === nodeType ||
      'DeclareClass' === nodeType ||
      'DeclareFunction' === nodeType ||
      'DeclareInterface' === nodeType ||
      'DeclareModule' === nodeType ||
      'DeclareModuleExports' === nodeType ||
      'DeclareTypeAlias' === nodeType ||
      'DeclareOpaqueType' === nodeType ||
      'DeclareVariable' === nodeType ||
      'DeclareExportDeclaration' === nodeType ||
      'DeclareExportAllDeclaration' === nodeType ||
      'InterfaceDeclaration' === nodeType ||
      'OpaqueType' === nodeType ||
      'TypeAlias' === nodeType ||
      'EnumDeclaration' === nodeType ||
      'TSDeclareFunction' === nodeType ||
      'TSInterfaceDeclaration' === nodeType ||
      'TSTypeAliasDeclaration' === nodeType ||
      'TSEnumDeclaration' === nodeType ||
      'TSModuleDeclaration' === nodeType ||
      (nodeType === 'Placeholder' && 'Declaration' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPatternLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'Identifier' === nodeType ||
      'RestElement' === nodeType ||
      'AssignmentPattern' === nodeType ||
      'ArrayPattern' === nodeType ||
      'ObjectPattern' === nodeType ||
      (nodeType === 'Placeholder' &&
        ('Pattern' === node.expectedNode || 'Identifier' === node.expectedNode))
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isLVal(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'Identifier' === nodeType ||
      'MemberExpression' === nodeType ||
      'RestElement' === nodeType ||
      'AssignmentPattern' === nodeType ||
      'ArrayPattern' === nodeType ||
      'ObjectPattern' === nodeType ||
      'TSParameterProperty' === nodeType ||
      (nodeType === 'Placeholder' &&
        ('Pattern' === node.expectedNode || 'Identifier' === node.expectedNode))
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSEntityName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'Identifier' === nodeType ||
      'TSQualifiedName' === nodeType ||
      (nodeType === 'Placeholder' && 'Identifier' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'StringLiteral' === nodeType ||
      'NumericLiteral' === nodeType ||
      'NullLiteral' === nodeType ||
      'BooleanLiteral' === nodeType ||
      'RegExpLiteral' === nodeType ||
      'TemplateLiteral' === nodeType ||
      'BigIntLiteral' === nodeType ||
      'DecimalLiteral' === nodeType ||
      (nodeType === 'Placeholder' && 'StringLiteral' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isImmutable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'StringLiteral' === nodeType ||
      'NumericLiteral' === nodeType ||
      'NullLiteral' === nodeType ||
      'BooleanLiteral' === nodeType ||
      'BigIntLiteral' === nodeType ||
      'JSXAttribute' === nodeType ||
      'JSXClosingElement' === nodeType ||
      'JSXElement' === nodeType ||
      'JSXExpressionContainer' === nodeType ||
      'JSXSpreadChild' === nodeType ||
      'JSXOpeningElement' === nodeType ||
      'JSXText' === nodeType ||
      'JSXFragment' === nodeType ||
      'JSXOpeningFragment' === nodeType ||
      'JSXClosingFragment' === nodeType ||
      'DecimalLiteral' === nodeType ||
      (nodeType === 'Placeholder' && 'StringLiteral' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isUserWhitespacable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ObjectMethod' === nodeType ||
      'ObjectProperty' === nodeType ||
      'ObjectTypeInternalSlot' === nodeType ||
      'ObjectTypeCallProperty' === nodeType ||
      'ObjectTypeIndexer' === nodeType ||
      'ObjectTypeProperty' === nodeType ||
      'ObjectTypeSpreadProperty' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ObjectMethod' === nodeType ||
      'ClassMethod' === nodeType ||
      'ClassPrivateMethod' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ('ObjectMethod' === nodeType || 'ObjectProperty' === nodeType) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ObjectProperty' === nodeType ||
      'ClassProperty' === nodeType ||
      'ClassPrivateProperty' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isUnaryLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ('UnaryExpression' === nodeType || 'SpreadElement' === nodeType) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'AssignmentPattern' === nodeType ||
      'ArrayPattern' === nodeType ||
      'ObjectPattern' === nodeType ||
      (nodeType === 'Placeholder' && 'Pattern' === node.expectedNode)
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ('ClassExpression' === nodeType || 'ClassDeclaration' === nodeType) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ExportAllDeclaration' === nodeType ||
      'ExportDefaultDeclaration' === nodeType ||
      'ExportNamedDeclaration' === nodeType ||
      'ImportDeclaration' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ExportAllDeclaration' === nodeType ||
      'ExportDefaultDeclaration' === nodeType ||
      'ExportNamedDeclaration' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isModuleSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ExportSpecifier' === nodeType ||
      'ImportDefaultSpecifier' === nodeType ||
      'ImportNamespaceSpecifier' === nodeType ||
      'ImportSpecifier' === nodeType ||
      'ExportNamespaceSpecifier' === nodeType ||
      'ExportDefaultSpecifier' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFlow(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'AnyTypeAnnotation' === nodeType ||
      'ArrayTypeAnnotation' === nodeType ||
      'BooleanTypeAnnotation' === nodeType ||
      'BooleanLiteralTypeAnnotation' === nodeType ||
      'NullLiteralTypeAnnotation' === nodeType ||
      'ClassImplements' === nodeType ||
      'DeclareClass' === nodeType ||
      'DeclareFunction' === nodeType ||
      'DeclareInterface' === nodeType ||
      'DeclareModule' === nodeType ||
      'DeclareModuleExports' === nodeType ||
      'DeclareTypeAlias' === nodeType ||
      'DeclareOpaqueType' === nodeType ||
      'DeclareVariable' === nodeType ||
      'DeclareExportDeclaration' === nodeType ||
      'DeclareExportAllDeclaration' === nodeType ||
      'DeclaredPredicate' === nodeType ||
      'ExistsTypeAnnotation' === nodeType ||
      'FunctionTypeAnnotation' === nodeType ||
      'FunctionTypeParam' === nodeType ||
      'GenericTypeAnnotation' === nodeType ||
      'InferredPredicate' === nodeType ||
      'InterfaceExtends' === nodeType ||
      'InterfaceDeclaration' === nodeType ||
      'InterfaceTypeAnnotation' === nodeType ||
      'IntersectionTypeAnnotation' === nodeType ||
      'MixedTypeAnnotation' === nodeType ||
      'EmptyTypeAnnotation' === nodeType ||
      'NullableTypeAnnotation' === nodeType ||
      'NumberLiteralTypeAnnotation' === nodeType ||
      'NumberTypeAnnotation' === nodeType ||
      'ObjectTypeAnnotation' === nodeType ||
      'ObjectTypeInternalSlot' === nodeType ||
      'ObjectTypeCallProperty' === nodeType ||
      'ObjectTypeIndexer' === nodeType ||
      'ObjectTypeProperty' === nodeType ||
      'ObjectTypeSpreadProperty' === nodeType ||
      'OpaqueType' === nodeType ||
      'QualifiedTypeIdentifier' === nodeType ||
      'StringLiteralTypeAnnotation' === nodeType ||
      'StringTypeAnnotation' === nodeType ||
      'SymbolTypeAnnotation' === nodeType ||
      'ThisTypeAnnotation' === nodeType ||
      'TupleTypeAnnotation' === nodeType ||
      'TypeofTypeAnnotation' === nodeType ||
      'TypeAlias' === nodeType ||
      'TypeAnnotation' === nodeType ||
      'TypeCastExpression' === nodeType ||
      'TypeParameter' === nodeType ||
      'TypeParameterDeclaration' === nodeType ||
      'TypeParameterInstantiation' === nodeType ||
      'UnionTypeAnnotation' === nodeType ||
      'Variance' === nodeType ||
      'VoidTypeAnnotation' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFlowType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'AnyTypeAnnotation' === nodeType ||
      'ArrayTypeAnnotation' === nodeType ||
      'BooleanTypeAnnotation' === nodeType ||
      'BooleanLiteralTypeAnnotation' === nodeType ||
      'NullLiteralTypeAnnotation' === nodeType ||
      'ExistsTypeAnnotation' === nodeType ||
      'FunctionTypeAnnotation' === nodeType ||
      'GenericTypeAnnotation' === nodeType ||
      'InterfaceTypeAnnotation' === nodeType ||
      'IntersectionTypeAnnotation' === nodeType ||
      'MixedTypeAnnotation' === nodeType ||
      'EmptyTypeAnnotation' === nodeType ||
      'NullableTypeAnnotation' === nodeType ||
      'NumberLiteralTypeAnnotation' === nodeType ||
      'NumberTypeAnnotation' === nodeType ||
      'ObjectTypeAnnotation' === nodeType ||
      'StringLiteralTypeAnnotation' === nodeType ||
      'StringTypeAnnotation' === nodeType ||
      'SymbolTypeAnnotation' === nodeType ||
      'ThisTypeAnnotation' === nodeType ||
      'TupleTypeAnnotation' === nodeType ||
      'TypeofTypeAnnotation' === nodeType ||
      'UnionTypeAnnotation' === nodeType ||
      'VoidTypeAnnotation' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'AnyTypeAnnotation' === nodeType ||
      'BooleanTypeAnnotation' === nodeType ||
      'NullLiteralTypeAnnotation' === nodeType ||
      'MixedTypeAnnotation' === nodeType ||
      'EmptyTypeAnnotation' === nodeType ||
      'NumberTypeAnnotation' === nodeType ||
      'StringTypeAnnotation' === nodeType ||
      'SymbolTypeAnnotation' === nodeType ||
      'ThisTypeAnnotation' === nodeType ||
      'VoidTypeAnnotation' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFlowDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'DeclareClass' === nodeType ||
      'DeclareFunction' === nodeType ||
      'DeclareInterface' === nodeType ||
      'DeclareModule' === nodeType ||
      'DeclareModuleExports' === nodeType ||
      'DeclareTypeAlias' === nodeType ||
      'DeclareOpaqueType' === nodeType ||
      'DeclareVariable' === nodeType ||
      'DeclareExportDeclaration' === nodeType ||
      'DeclareExportAllDeclaration' === nodeType ||
      'InterfaceDeclaration' === nodeType ||
      'OpaqueType' === nodeType ||
      'TypeAlias' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isFlowPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ('DeclaredPredicate' === nodeType || 'InferredPredicate' === nodeType) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'EnumBooleanBody' === nodeType ||
      'EnumNumberBody' === nodeType ||
      'EnumStringBody' === nodeType ||
      'EnumSymbolBody' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'EnumBooleanMember' === nodeType ||
      'EnumNumberMember' === nodeType ||
      'EnumStringMember' === nodeType ||
      'EnumDefaultedMember' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isJSX(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'JSXAttribute' === nodeType ||
      'JSXClosingElement' === nodeType ||
      'JSXElement' === nodeType ||
      'JSXEmptyExpression' === nodeType ||
      'JSXExpressionContainer' === nodeType ||
      'JSXSpreadChild' === nodeType ||
      'JSXIdentifier' === nodeType ||
      'JSXMemberExpression' === nodeType ||
      'JSXNamespacedName' === nodeType ||
      'JSXOpeningElement' === nodeType ||
      'JSXSpreadAttribute' === nodeType ||
      'JSXText' === nodeType ||
      'JSXFragment' === nodeType ||
      'JSXOpeningFragment' === nodeType ||
      'JSXClosingFragment' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isPrivate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'ClassPrivateProperty' === nodeType ||
      'ClassPrivateMethod' === nodeType ||
      'PrivateName' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'TSCallSignatureDeclaration' === nodeType ||
      'TSConstructSignatureDeclaration' === nodeType ||
      'TSPropertySignature' === nodeType ||
      'TSMethodSignature' === nodeType ||
      'TSIndexSignature' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'TSAnyKeyword' === nodeType ||
      'TSBooleanKeyword' === nodeType ||
      'TSBigIntKeyword' === nodeType ||
      'TSIntrinsicKeyword' === nodeType ||
      'TSNeverKeyword' === nodeType ||
      'TSNullKeyword' === nodeType ||
      'TSNumberKeyword' === nodeType ||
      'TSObjectKeyword' === nodeType ||
      'TSStringKeyword' === nodeType ||
      'TSSymbolKeyword' === nodeType ||
      'TSUndefinedKeyword' === nodeType ||
      'TSUnknownKeyword' === nodeType ||
      'TSVoidKeyword' === nodeType ||
      'TSThisType' === nodeType ||
      'TSFunctionType' === nodeType ||
      'TSConstructorType' === nodeType ||
      'TSTypeReference' === nodeType ||
      'TSTypePredicate' === nodeType ||
      'TSTypeQuery' === nodeType ||
      'TSTypeLiteral' === nodeType ||
      'TSArrayType' === nodeType ||
      'TSTupleType' === nodeType ||
      'TSOptionalType' === nodeType ||
      'TSRestType' === nodeType ||
      'TSUnionType' === nodeType ||
      'TSIntersectionType' === nodeType ||
      'TSConditionalType' === nodeType ||
      'TSInferType' === nodeType ||
      'TSParenthesizedType' === nodeType ||
      'TSTypeOperator' === nodeType ||
      'TSIndexedAccessType' === nodeType ||
      'TSMappedType' === nodeType ||
      'TSLiteralType' === nodeType ||
      'TSExpressionWithTypeArguments' === nodeType ||
      'TSImportType' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isTSBaseType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (
      'TSAnyKeyword' === nodeType ||
      'TSBooleanKeyword' === nodeType ||
      'TSBigIntKeyword' === nodeType ||
      'TSIntrinsicKeyword' === nodeType ||
      'TSNeverKeyword' === nodeType ||
      'TSNullKeyword' === nodeType ||
      'TSNumberKeyword' === nodeType ||
      'TSObjectKeyword' === nodeType ||
      'TSStringKeyword' === nodeType ||
      'TSSymbolKeyword' === nodeType ||
      'TSUndefinedKeyword' === nodeType ||
      'TSUnknownKeyword' === nodeType ||
      'TSVoidKeyword' === nodeType ||
      'TSThisType' === nodeType ||
      'TSLiteralType' === nodeType
    ) {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isNumberLiteral(node, opts) {
    console.trace(
      'The node type NumberLiteral has been renamed to NumericLiteral',
    );
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'NumberLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isRegexLiteral(node, opts) {
    console.trace(
      'The node type RegexLiteral has been renamed to RegExpLiteral',
    );
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'RegexLiteral') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isRestProperty(node, opts) {
    console.trace('The node type RestProperty has been renamed to RestElement');
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'RestProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  function isSpreadProperty(node, opts) {
    console.trace(
      'The node type SpreadProperty has been renamed to SpreadElement',
    );
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === 'SpreadProperty') {
      if (typeof opts === 'undefined') {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }

    return false;
  }

  var generated = /*#__PURE__*/ Object.defineProperty(
    {
      isArrayExpression: isArrayExpression_1,
      isAssignmentExpression: isAssignmentExpression_1,
      isBinaryExpression: isBinaryExpression_1,
      isInterpreterDirective: isInterpreterDirective_1,
      isDirective: isDirective_1,
      isDirectiveLiteral: isDirectiveLiteral_1,
      isBlockStatement: isBlockStatement_1,
      isBreakStatement: isBreakStatement_1,
      isCallExpression: isCallExpression_1,
      isCatchClause: isCatchClause_1,
      isConditionalExpression: isConditionalExpression_1,
      isContinueStatement: isContinueStatement_1,
      isDebuggerStatement: isDebuggerStatement_1,
      isDoWhileStatement: isDoWhileStatement_1,
      isEmptyStatement: isEmptyStatement_1,
      isExpressionStatement: isExpressionStatement_1,
      isFile: isFile_1,
      isForInStatement: isForInStatement_1,
      isForStatement: isForStatement_1,
      isFunctionDeclaration: isFunctionDeclaration_1,
      isFunctionExpression: isFunctionExpression_1,
      isIdentifier: isIdentifier_1,
      isIfStatement: isIfStatement_1,
      isLabeledStatement: isLabeledStatement_1,
      isStringLiteral: isStringLiteral_1,
      isNumericLiteral: isNumericLiteral_1,
      isNullLiteral: isNullLiteral_1,
      isBooleanLiteral: isBooleanLiteral_1,
      isRegExpLiteral: isRegExpLiteral_1,
      isLogicalExpression: isLogicalExpression_1,
      isMemberExpression: isMemberExpression_1,
      isNewExpression: isNewExpression_1,
      isProgram: isProgram_1,
      isObjectExpression: isObjectExpression_1,
      isObjectMethod: isObjectMethod_1,
      isObjectProperty: isObjectProperty_1,
      isRestElement: isRestElement_1,
      isReturnStatement: isReturnStatement_1,
      isSequenceExpression: isSequenceExpression_1,
      isParenthesizedExpression: isParenthesizedExpression_1,
      isSwitchCase: isSwitchCase_1,
      isSwitchStatement: isSwitchStatement_1,
      isThisExpression: isThisExpression_1,
      isThrowStatement: isThrowStatement_1,
      isTryStatement: isTryStatement_1,
      isUnaryExpression: isUnaryExpression_1,
      isUpdateExpression: isUpdateExpression_1,
      isVariableDeclaration: isVariableDeclaration_1,
      isVariableDeclarator: isVariableDeclarator_1,
      isWhileStatement: isWhileStatement_1,
      isWithStatement: isWithStatement_1,
      isAssignmentPattern: isAssignmentPattern_1,
      isArrayPattern: isArrayPattern_1,
      isArrowFunctionExpression: isArrowFunctionExpression_1,
      isClassBody: isClassBody_1,
      isClassExpression: isClassExpression_1,
      isClassDeclaration: isClassDeclaration_1,
      isExportAllDeclaration: isExportAllDeclaration_1,
      isExportDefaultDeclaration: isExportDefaultDeclaration_1,
      isExportNamedDeclaration: isExportNamedDeclaration_1,
      isExportSpecifier: isExportSpecifier_1,
      isForOfStatement: isForOfStatement_1,
      isImportDeclaration: isImportDeclaration_1,
      isImportDefaultSpecifier: isImportDefaultSpecifier_1,
      isImportNamespaceSpecifier: isImportNamespaceSpecifier_1,
      isImportSpecifier: isImportSpecifier_1,
      isMetaProperty: isMetaProperty_1,
      isClassMethod: isClassMethod_1,
      isObjectPattern: isObjectPattern_1,
      isSpreadElement: isSpreadElement_1,
      isSuper: isSuper_1,
      isTaggedTemplateExpression: isTaggedTemplateExpression_1,
      isTemplateElement: isTemplateElement_1,
      isTemplateLiteral: isTemplateLiteral_1,
      isYieldExpression: isYieldExpression_1,
      isAwaitExpression: isAwaitExpression_1,
      isImport: isImport_1,
      isBigIntLiteral: isBigIntLiteral_1,
      isExportNamespaceSpecifier: isExportNamespaceSpecifier_1,
      isOptionalMemberExpression: isOptionalMemberExpression_1,
      isOptionalCallExpression: isOptionalCallExpression_1,
      isAnyTypeAnnotation: isAnyTypeAnnotation_1,
      isArrayTypeAnnotation: isArrayTypeAnnotation_1,
      isBooleanTypeAnnotation: isBooleanTypeAnnotation_1,
      isBooleanLiteralTypeAnnotation: isBooleanLiteralTypeAnnotation_1,
      isNullLiteralTypeAnnotation: isNullLiteralTypeAnnotation_1,
      isClassImplements: isClassImplements_1,
      isDeclareClass: isDeclareClass_1,
      isDeclareFunction: isDeclareFunction_1,
      isDeclareInterface: isDeclareInterface_1,
      isDeclareModule: isDeclareModule_1,
      isDeclareModuleExports: isDeclareModuleExports_1,
      isDeclareTypeAlias: isDeclareTypeAlias_1,
      isDeclareOpaqueType: isDeclareOpaqueType_1,
      isDeclareVariable: isDeclareVariable_1,
      isDeclareExportDeclaration: isDeclareExportDeclaration_1,
      isDeclareExportAllDeclaration: isDeclareExportAllDeclaration_1,
      isDeclaredPredicate: isDeclaredPredicate_1,
      isExistsTypeAnnotation: isExistsTypeAnnotation_1,
      isFunctionTypeAnnotation: isFunctionTypeAnnotation_1,
      isFunctionTypeParam: isFunctionTypeParam_1,
      isGenericTypeAnnotation: isGenericTypeAnnotation_1,
      isInferredPredicate: isInferredPredicate_1,
      isInterfaceExtends: isInterfaceExtends_1,
      isInterfaceDeclaration: isInterfaceDeclaration_1,
      isInterfaceTypeAnnotation: isInterfaceTypeAnnotation_1,
      isIntersectionTypeAnnotation: isIntersectionTypeAnnotation_1,
      isMixedTypeAnnotation: isMixedTypeAnnotation_1,
      isEmptyTypeAnnotation: isEmptyTypeAnnotation_1,
      isNullableTypeAnnotation: isNullableTypeAnnotation_1,
      isNumberLiteralTypeAnnotation: isNumberLiteralTypeAnnotation_1,
      isNumberTypeAnnotation: isNumberTypeAnnotation_1,
      isObjectTypeAnnotation: isObjectTypeAnnotation_1,
      isObjectTypeInternalSlot: isObjectTypeInternalSlot_1,
      isObjectTypeCallProperty: isObjectTypeCallProperty_1,
      isObjectTypeIndexer: isObjectTypeIndexer_1,
      isObjectTypeProperty: isObjectTypeProperty_1,
      isObjectTypeSpreadProperty: isObjectTypeSpreadProperty_1,
      isOpaqueType: isOpaqueType_1,
      isQualifiedTypeIdentifier: isQualifiedTypeIdentifier_1,
      isStringLiteralTypeAnnotation: isStringLiteralTypeAnnotation_1,
      isStringTypeAnnotation: isStringTypeAnnotation_1,
      isSymbolTypeAnnotation: isSymbolTypeAnnotation_1,
      isThisTypeAnnotation: isThisTypeAnnotation_1,
      isTupleTypeAnnotation: isTupleTypeAnnotation_1,
      isTypeofTypeAnnotation: isTypeofTypeAnnotation_1,
      isTypeAlias: isTypeAlias_1,
      isTypeAnnotation: isTypeAnnotation_1,
      isTypeCastExpression: isTypeCastExpression_1,
      isTypeParameter: isTypeParameter_1,
      isTypeParameterDeclaration: isTypeParameterDeclaration_1,
      isTypeParameterInstantiation: isTypeParameterInstantiation_1,
      isUnionTypeAnnotation: isUnionTypeAnnotation_1,
      isVariance: isVariance_1,
      isVoidTypeAnnotation: isVoidTypeAnnotation_1,
      isEnumDeclaration: isEnumDeclaration_1,
      isEnumBooleanBody: isEnumBooleanBody_1,
      isEnumNumberBody: isEnumNumberBody_1,
      isEnumStringBody: isEnumStringBody_1,
      isEnumSymbolBody: isEnumSymbolBody_1,
      isEnumBooleanMember: isEnumBooleanMember_1,
      isEnumNumberMember: isEnumNumberMember_1,
      isEnumStringMember: isEnumStringMember_1,
      isEnumDefaultedMember: isEnumDefaultedMember_1,
      isJSXAttribute: isJSXAttribute_1,
      isJSXClosingElement: isJSXClosingElement_1,
      isJSXElement: isJSXElement_1,
      isJSXEmptyExpression: isJSXEmptyExpression_1,
      isJSXExpressionContainer: isJSXExpressionContainer_1,
      isJSXSpreadChild: isJSXSpreadChild_1,
      isJSXIdentifier: isJSXIdentifier_1,
      isJSXMemberExpression: isJSXMemberExpression_1,
      isJSXNamespacedName: isJSXNamespacedName_1,
      isJSXOpeningElement: isJSXOpeningElement_1,
      isJSXSpreadAttribute: isJSXSpreadAttribute_1,
      isJSXText: isJSXText_1,
      isJSXFragment: isJSXFragment_1,
      isJSXOpeningFragment: isJSXOpeningFragment_1,
      isJSXClosingFragment: isJSXClosingFragment_1,
      isNoop: isNoop_1,
      isPlaceholder: isPlaceholder_1,
      isV8IntrinsicIdentifier: isV8IntrinsicIdentifier_1,
      isArgumentPlaceholder: isArgumentPlaceholder_1,
      isBindExpression: isBindExpression_1,
      isClassProperty: isClassProperty_1,
      isPipelineTopicExpression: isPipelineTopicExpression_1,
      isPipelineBareFunction: isPipelineBareFunction_1,
      isPipelinePrimaryTopicReference: isPipelinePrimaryTopicReference_1,
      isClassPrivateProperty: isClassPrivateProperty_1,
      isClassPrivateMethod: isClassPrivateMethod_1,
      isImportAttribute: isImportAttribute_1,
      isDecorator: isDecorator_1,
      isDoExpression: isDoExpression_1,
      isExportDefaultSpecifier: isExportDefaultSpecifier_1,
      isPrivateName: isPrivateName_1,
      isRecordExpression: isRecordExpression_1,
      isTupleExpression: isTupleExpression_1,
      isDecimalLiteral: isDecimalLiteral_1,
      isStaticBlock: isStaticBlock_1,
      isModuleExpression: isModuleExpression_1,
      isTSParameterProperty: isTSParameterProperty_1,
      isTSDeclareFunction: isTSDeclareFunction_1,
      isTSDeclareMethod: isTSDeclareMethod_1,
      isTSQualifiedName: isTSQualifiedName_1,
      isTSCallSignatureDeclaration: isTSCallSignatureDeclaration_1,
      isTSConstructSignatureDeclaration: isTSConstructSignatureDeclaration_1,
      isTSPropertySignature: isTSPropertySignature_1,
      isTSMethodSignature: isTSMethodSignature_1,
      isTSIndexSignature: isTSIndexSignature_1,
      isTSAnyKeyword: isTSAnyKeyword_1,
      isTSBooleanKeyword: isTSBooleanKeyword_1,
      isTSBigIntKeyword: isTSBigIntKeyword_1,
      isTSIntrinsicKeyword: isTSIntrinsicKeyword_1,
      isTSNeverKeyword: isTSNeverKeyword_1,
      isTSNullKeyword: isTSNullKeyword_1,
      isTSNumberKeyword: isTSNumberKeyword_1,
      isTSObjectKeyword: isTSObjectKeyword_1,
      isTSStringKeyword: isTSStringKeyword_1,
      isTSSymbolKeyword: isTSSymbolKeyword_1,
      isTSUndefinedKeyword: isTSUndefinedKeyword_1,
      isTSUnknownKeyword: isTSUnknownKeyword_1,
      isTSVoidKeyword: isTSVoidKeyword_1,
      isTSThisType: isTSThisType_1,
      isTSFunctionType: isTSFunctionType_1,
      isTSConstructorType: isTSConstructorType_1,
      isTSTypeReference: isTSTypeReference_1,
      isTSTypePredicate: isTSTypePredicate_1,
      isTSTypeQuery: isTSTypeQuery_1,
      isTSTypeLiteral: isTSTypeLiteral_1,
      isTSArrayType: isTSArrayType_1,
      isTSTupleType: isTSTupleType_1,
      isTSOptionalType: isTSOptionalType_1,
      isTSRestType: isTSRestType_1,
      isTSNamedTupleMember: isTSNamedTupleMember_1,
      isTSUnionType: isTSUnionType_1,
      isTSIntersectionType: isTSIntersectionType_1,
      isTSConditionalType: isTSConditionalType_1,
      isTSInferType: isTSInferType_1,
      isTSParenthesizedType: isTSParenthesizedType_1,
      isTSTypeOperator: isTSTypeOperator_1,
      isTSIndexedAccessType: isTSIndexedAccessType_1,
      isTSMappedType: isTSMappedType_1,
      isTSLiteralType: isTSLiteralType_1,
      isTSExpressionWithTypeArguments: isTSExpressionWithTypeArguments_1,
      isTSInterfaceDeclaration: isTSInterfaceDeclaration_1,
      isTSInterfaceBody: isTSInterfaceBody_1,
      isTSTypeAliasDeclaration: isTSTypeAliasDeclaration_1,
      isTSAsExpression: isTSAsExpression_1,
      isTSTypeAssertion: isTSTypeAssertion_1,
      isTSEnumDeclaration: isTSEnumDeclaration_1,
      isTSEnumMember: isTSEnumMember_1,
      isTSModuleDeclaration: isTSModuleDeclaration_1,
      isTSModuleBlock: isTSModuleBlock_1,
      isTSImportType: isTSImportType_1,
      isTSImportEqualsDeclaration: isTSImportEqualsDeclaration_1,
      isTSExternalModuleReference: isTSExternalModuleReference_1,
      isTSNonNullExpression: isTSNonNullExpression_1,
      isTSExportAssignment: isTSExportAssignment_1,
      isTSNamespaceExportDeclaration: isTSNamespaceExportDeclaration_1,
      isTSTypeAnnotation: isTSTypeAnnotation_1,
      isTSTypeParameterInstantiation: isTSTypeParameterInstantiation_1,
      isTSTypeParameterDeclaration: isTSTypeParameterDeclaration_1,
      isTSTypeParameter: isTSTypeParameter_1,
      isExpression: isExpression_1,
      isBinary: isBinary_1,
      isScopable: isScopable_1,
      isBlockParent: isBlockParent_1,
      isBlock: isBlock_1,
      isStatement: isStatement_1,
      isTerminatorless: isTerminatorless_1,
      isCompletionStatement: isCompletionStatement_1,
      isConditional: isConditional_1,
      isLoop: isLoop_1,
      isWhile: isWhile_1,
      isExpressionWrapper: isExpressionWrapper_1,
      isFor: isFor_1,
      isForXStatement: isForXStatement_1,
      isFunction: isFunction_1,
      isFunctionParent: isFunctionParent_1,
      isPureish: isPureish_1,
      isDeclaration: isDeclaration_1,
      isPatternLike: isPatternLike_1,
      isLVal: isLVal_1,
      isTSEntityName: isTSEntityName_1,
      isLiteral: isLiteral_1,
      isImmutable: isImmutable_1,
      isUserWhitespacable: isUserWhitespacable_1,
      isMethod: isMethod_1,
      isObjectMember: isObjectMember_1,
      isProperty: isProperty_1,
      isUnaryLike: isUnaryLike_1,
      isPattern: isPattern_1,
      isClass: isClass_1,
      isModuleDeclaration: isModuleDeclaration_1,
      isExportDeclaration: isExportDeclaration_1,
      isModuleSpecifier: isModuleSpecifier_1,
      isFlow: isFlow_1,
      isFlowType: isFlowType_1,
      isFlowBaseAnnotation: isFlowBaseAnnotation_1,
      isFlowDeclaration: isFlowDeclaration_1,
      isFlowPredicate: isFlowPredicate_1,
      isEnumBody: isEnumBody_1,
      isEnumMember: isEnumMember_1,
      isJSX: isJSX_1,
      isPrivate: isPrivate_1,
      isTSTypeElement: isTSTypeElement_1,
      isTSType: isTSType_1,
      isTSBaseType: isTSBaseType_1,
      isNumberLiteral: isNumberLiteral_1,
      isRegexLiteral: isRegexLiteral_1,
      isRestProperty: isRestProperty_1,
      isSpreadProperty: isSpreadProperty_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$1 = matchesPattern;

  function matchesPattern(member, match, allowPartial) {
    if (!(0, generated.isMemberExpression)(member)) return false;
    const parts = Array.isArray(match) ? match : match.split('.');
    const nodes = [];
    let node;

    for (
      node = member;
      (0, generated.isMemberExpression)(node);
      node = node.object
    ) {
      nodes.push(node.property);
    }

    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;

    for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      const node = nodes[j];
      let value;

      if ((0, generated.isIdentifier)(node)) {
        value = node.name;
      } else if ((0, generated.isStringLiteral)(node)) {
        value = node.value;
      } else {
        return false;
      }

      if (parts[i] !== value) return false;
    }

    return true;
  }

  var matchesPattern_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$2 = buildMatchMemberExpression;

  var _matchesPattern = _interopRequireDefault$1(matchesPattern_1);

  function _interopRequireDefault$1(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split('.');
    return (member) =>
      (0, _matchesPattern.default)(member, parts, allowPartial);
  }

  var buildMatchMemberExpression_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$2,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var isReactComponent_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    var _buildMatchMemberExpression = _interopRequireDefault(
      buildMatchMemberExpression_1,
    );

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    const isReactComponent = (0, _buildMatchMemberExpression.default)(
      'React.Component',
    );
    var _default = isReactComponent;
    exports.default = _default;
  });

  var _default$3 = isCompatTag;

  function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }

  var isCompatTag_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$3,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$4 = isType;

  function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (definitions.ALIAS_KEYS[targetType]) return false;
    const aliases = definitions.FLIPPED_ALIAS_KEYS[targetType];

    if (aliases) {
      if (aliases[0] === nodeType) return true;

      for (const alias of aliases) {
        if (nodeType === alias) return true;
      }
    }

    return false;
  }

  var isType_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$4,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$5 = isPlaceholderType;

  function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = definitions.PLACEHOLDERS_ALIAS[placeholderType];

    if (aliases) {
      for (const alias of aliases) {
        if (targetType === alias) return true;
      }
    }

    return false;
  }

  var isPlaceholderType_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$5,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$6 = is;

  var _shallowEqual$1 = _interopRequireDefault$2(shallowEqual_1);

  var _isType = _interopRequireDefault$2(isType_1);

  var _isPlaceholderType = _interopRequireDefault$2(isPlaceholderType_1);

  function _interopRequireDefault$2(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function is(type, node, opts) {
    if (!node) return false;
    const matches = (0, _isType.default)(node.type, type);

    if (!matches) {
      if (
        !opts &&
        node.type === 'Placeholder' &&
        type in definitions.FLIPPED_ALIAS_KEYS
      ) {
        return (0, _isPlaceholderType.default)(node.expectedNode, type);
      }

      return false;
    }

    if (typeof opts === 'undefined') {
      return true;
    } else {
      return (0, _shallowEqual$1.default)(node, opts);
    }
  }

  var is_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$6,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var isIdentifierStart_1 = isIdentifierStart$1;
  var isIdentifierChar_1 = isIdentifierChar$1;
  var isIdentifierName_1 = isIdentifierName;
  let nonASCIIidentifierStartChars$1 =
    '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc';
  let nonASCIIidentifierChars$1 =
    '\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f';
  const nonASCIIidentifierStart$1 = new RegExp(
    '[' + nonASCIIidentifierStartChars$1 + ']',
  );
  const nonASCIIidentifier$1 = new RegExp(
    '[' + nonASCIIidentifierStartChars$1 + nonASCIIidentifierChars$1 + ']',
  );
  nonASCIIidentifierStartChars$1 = nonASCIIidentifierChars$1 = null;
  const astralIdentifierStartCodes$1 = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    157,
    310,
    10,
    21,
    11,
    7,
    153,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    107,
    20,
    28,
    22,
    13,
    52,
    76,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    230,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    35,
    56,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    190,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2749,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    114,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8952,
    286,
    50,
    2,
    18,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    2357,
    44,
    11,
    6,
    17,
    0,
    370,
    43,
    1301,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42717,
    35,
    4148,
    12,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938,
  ];
  const astralIdentifierCodes$1 = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    154,
    10,
    176,
    2,
    54,
    14,
    32,
    9,
    16,
    3,
    46,
    10,
    54,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    19306,
    9,
    135,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    5319,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    262,
    6,
    10,
    9,
    419,
    13,
    1495,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239,
  ];

  function isInAstralSet$1(code, set) {
    let pos = 0x10000;

    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart$1(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return (
        code >= 0xaa &&
        nonASCIIidentifierStart$1.test(String.fromCharCode(code))
      );
    }

    return isInAstralSet$1(code, astralIdentifierStartCodes$1);
  }

  function isIdentifierChar$1(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return (
        code >= 0xaa && nonASCIIidentifier$1.test(String.fromCharCode(code))
      );
    }

    return (
      isInAstralSet$1(code, astralIdentifierStartCodes$1) ||
      isInAstralSet$1(code, astralIdentifierCodes$1)
    );
  }

  function isIdentifierName(name) {
    let isFirst = true;

    for (
      let _i = 0, _Array$from = Array.from(name);
      _i < _Array$from.length;
      _i++
    ) {
      const char = _Array$from[_i];
      const cp = char.codePointAt(0);

      if (isFirst) {
        if (!isIdentifierStart$1(cp)) {
          return false;
        }

        isFirst = false;
      } else if (!isIdentifierChar$1(cp)) {
        return false;
      }
    }

    return !isFirst;
  }

  var identifier = /*#__PURE__*/ Object.defineProperty(
    {
      isIdentifierStart: isIdentifierStart_1,
      isIdentifierChar: isIdentifierChar_1,
      isIdentifierName: isIdentifierName_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var isReservedWord_1 = isReservedWord$1;
  var isStrictReservedWord_1 = isStrictReservedWord$1;
  var isStrictBindOnlyReservedWord_1 = isStrictBindOnlyReservedWord$1;
  var isStrictBindReservedWord_1 = isStrictBindReservedWord$1;
  var isKeyword_1 = isKeyword$1;
  const reservedWords$1 = {
    keyword: [
      'break',
      'case',
      'catch',
      'continue',
      'debugger',
      'default',
      'do',
      'else',
      'finally',
      'for',
      'function',
      'if',
      'return',
      'switch',
      'throw',
      'try',
      'var',
      'const',
      'while',
      'with',
      'new',
      'this',
      'super',
      'class',
      'extends',
      'export',
      'import',
      'null',
      'true',
      'false',
      'in',
      'instanceof',
      'typeof',
      'void',
      'delete',
    ],
    strict: [
      'implements',
      'interface',
      'let',
      'package',
      'private',
      'protected',
      'public',
      'static',
      'yield',
    ],
    strictBind: ['eval', 'arguments'],
  };
  const keywords$2 = new Set(reservedWords$1.keyword);
  const reservedWordsStrictSet$1 = new Set(reservedWords$1.strict);
  const reservedWordsStrictBindSet$1 = new Set(reservedWords$1.strictBind);

  function isReservedWord$1(word, inModule) {
    return (inModule && word === 'await') || word === 'enum';
  }

  function isStrictReservedWord$1(word, inModule) {
    return (
      isReservedWord$1(word, inModule) || reservedWordsStrictSet$1.has(word)
    );
  }

  function isStrictBindOnlyReservedWord$1(word) {
    return reservedWordsStrictBindSet$1.has(word);
  }

  function isStrictBindReservedWord$1(word, inModule) {
    return (
      isStrictReservedWord$1(word, inModule) ||
      isStrictBindOnlyReservedWord$1(word)
    );
  }

  function isKeyword$1(word) {
    return keywords$2.has(word);
  }

  var keyword = /*#__PURE__*/ Object.defineProperty(
    {
      isReservedWord: isReservedWord_1,
      isStrictReservedWord: isStrictReservedWord_1,
      isStrictBindOnlyReservedWord: isStrictBindOnlyReservedWord_1,
      isStrictBindReservedWord: isStrictBindReservedWord_1,
      isKeyword: isKeyword_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var lib$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'isIdentifierName', {
      enumerable: true,
      get: function () {
        return identifier.isIdentifierName;
      },
    });
    Object.defineProperty(exports, 'isIdentifierChar', {
      enumerable: true,
      get: function () {
        return identifier.isIdentifierChar;
      },
    });
    Object.defineProperty(exports, 'isIdentifierStart', {
      enumerable: true,
      get: function () {
        return identifier.isIdentifierStart;
      },
    });
    Object.defineProperty(exports, 'isReservedWord', {
      enumerable: true,
      get: function () {
        return keyword.isReservedWord;
      },
    });
    Object.defineProperty(exports, 'isStrictBindOnlyReservedWord', {
      enumerable: true,
      get: function () {
        return keyword.isStrictBindOnlyReservedWord;
      },
    });
    Object.defineProperty(exports, 'isStrictBindReservedWord', {
      enumerable: true,
      get: function () {
        return keyword.isStrictBindReservedWord;
      },
    });
    Object.defineProperty(exports, 'isStrictReservedWord', {
      enumerable: true,
      get: function () {
        return keyword.isStrictReservedWord;
      },
    });
    Object.defineProperty(exports, 'isKeyword', {
      enumerable: true,
      get: function () {
        return keyword.isKeyword;
      },
    });
  });

  var _default$7 = isValidIdentifier;

  function isValidIdentifier(name, reserved = true) {
    if (typeof name !== 'string') return false;

    if (reserved) {
      if (
        (0, lib$1.isKeyword)(name) ||
        (0, lib$1.isStrictReservedWord)(name, true)
      ) {
        return false;
      }
    }

    return (0, lib$1.isIdentifierName)(name);
  }

  var isValidIdentifier_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$7,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var constants = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
    const STATEMENT_OR_BLOCK_KEYS = ['consequent', 'body', 'alternate'];
    exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
    const FLATTENABLE_KEYS = ['body', 'expressions'];
    exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
    const FOR_INIT_KEYS = ['left', 'init'];
    exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
    const COMMENT_KEYS = [
      'leadingComments',
      'trailingComments',
      'innerComments',
    ];
    exports.COMMENT_KEYS = COMMENT_KEYS;
    const LOGICAL_OPERATORS = ['||', '&&', '??'];
    exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
    const UPDATE_OPERATORS = ['++', '--'];
    exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
    const BOOLEAN_NUMBER_BINARY_OPERATORS = ['>', '<', '>=', '<='];
    exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
    const EQUALITY_BINARY_OPERATORS = ['==', '===', '!=', '!=='];
    exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
    const COMPARISON_BINARY_OPERATORS = [
      ...EQUALITY_BINARY_OPERATORS,
      'in',
      'instanceof',
    ];
    exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
    const BOOLEAN_BINARY_OPERATORS = [
      ...COMPARISON_BINARY_OPERATORS,
      ...BOOLEAN_NUMBER_BINARY_OPERATORS,
    ];
    exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
    const NUMBER_BINARY_OPERATORS = [
      '-',
      '/',
      '%',
      '*',
      '**',
      '&',
      '|',
      '>>',
      '>>>',
      '<<',
      '^',
    ];
    exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
    const BINARY_OPERATORS = [
      '+',
      ...NUMBER_BINARY_OPERATORS,
      ...BOOLEAN_BINARY_OPERATORS,
    ];
    exports.BINARY_OPERATORS = BINARY_OPERATORS;
    const ASSIGNMENT_OPERATORS = [
      '=',
      '+=',
      ...NUMBER_BINARY_OPERATORS.map((op) => op + '='),
      ...LOGICAL_OPERATORS.map((op) => op + '='),
    ];
    exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
    const BOOLEAN_UNARY_OPERATORS = ['delete', '!'];
    exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
    const NUMBER_UNARY_OPERATORS = ['+', '-', '~'];
    exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
    const STRING_UNARY_OPERATORS = ['typeof'];
    exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
    const UNARY_OPERATORS = [
      'void',
      'throw',
      ...BOOLEAN_UNARY_OPERATORS,
      ...NUMBER_UNARY_OPERATORS,
      ...STRING_UNARY_OPERATORS,
    ];
    exports.UNARY_OPERATORS = UNARY_OPERATORS;
    const INHERIT_KEYS = {
      optional: ['typeAnnotation', 'typeParameters', 'returnType'],
      force: ['start', 'loc', 'end'],
    };
    exports.INHERIT_KEYS = INHERIT_KEYS;
    const BLOCK_SCOPED_SYMBOL = Symbol.for('var used to be block scoped');
    exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
    const NOT_LOCAL_BINDING = Symbol.for(
      'should not be considered a local binding',
    );
    exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
  });

  var _default$8 = validate;
  var validateField_1 = validateField;
  var validateChild_1 = validateChild;

  function validate(node, key, val) {
    if (!node) return;
    const fields = definitions.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }

  function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }

  function validateChild(node, key, val) {
    if (val == null) return;
    const validate = definitions.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
  }

  var validate_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$8,
      validateField: validateField_1,
      validateChild: validateChild_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var utils = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.validate = validate;
    exports.typeIs = typeIs;
    exports.validateType = validateType;
    exports.validateOptional = validateOptional;
    exports.validateOptionalType = validateOptionalType;
    exports.arrayOf = arrayOf;
    exports.arrayOfType = arrayOfType;
    exports.validateArrayOfType = validateArrayOfType;
    exports.assertEach = assertEach;
    exports.assertOneOf = assertOneOf;
    exports.assertNodeType = assertNodeType;
    exports.assertNodeOrValueType = assertNodeOrValueType;
    exports.assertValueType = assertValueType;
    exports.assertShape = assertShape;
    exports.assertOptionalChainStart = assertOptionalChainStart;
    exports.chain = chain;
    exports.default = defineType;
    exports.NODE_PARENT_VALIDATIONS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

    var _is = _interopRequireDefault(is_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    const VISITOR_KEYS = {};
    exports.VISITOR_KEYS = VISITOR_KEYS;
    const ALIAS_KEYS = {};
    exports.ALIAS_KEYS = ALIAS_KEYS;
    const FLIPPED_ALIAS_KEYS = {};
    exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
    const NODE_FIELDS = {};
    exports.NODE_FIELDS = NODE_FIELDS;
    const BUILDER_KEYS = {};
    exports.BUILDER_KEYS = BUILDER_KEYS;
    const DEPRECATED_KEYS = {};
    exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
    const NODE_PARENT_VALIDATIONS = {};
    exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;

    function getType(val) {
      if (Array.isArray(val)) {
        return 'array';
      } else if (val === null) {
        return 'null';
      } else {
        return typeof val;
      }
    }

    function validate(validate) {
      return {
        validate,
      };
    }

    function typeIs(typeName) {
      return typeof typeName === 'string'
        ? assertNodeType(typeName)
        : assertNodeType(...typeName);
    }

    function validateType(typeName) {
      return validate(typeIs(typeName));
    }

    function validateOptional(validate) {
      return {
        validate,
        optional: true,
      };
    }

    function validateOptionalType(typeName) {
      return {
        validate: typeIs(typeName),
        optional: true,
      };
    }

    function arrayOf(elementType) {
      return chain(assertValueType('array'), assertEach(elementType));
    }

    function arrayOfType(typeName) {
      return arrayOf(typeIs(typeName));
    }

    function validateArrayOfType(typeName) {
      return validate(arrayOfType(typeName));
    }

    function assertEach(callback) {
      function validator(node, key, val) {
        if (!Array.isArray(val)) return;

        for (let i = 0; i < val.length; i++) {
          const subkey = `${key}[${i}]`;
          const v = val[i];
          callback(node, subkey, v);
          if (browser$1.env.BABEL_TYPES_8_BREAKING)
            (0, validate_1.validateChild)(node, subkey, v);
        }
      }

      validator.each = callback;
      return validator;
    }

    function assertOneOf(...values) {
      function validate(node, key, val) {
        if (values.indexOf(val) < 0) {
          throw new TypeError(
            `Property ${key} expected value to be one of ${JSON.stringify(
              values,
            )} but got ${JSON.stringify(val)}`,
          );
        }
      }

      validate.oneOf = values;
      return validate;
    }

    function assertNodeType(...types) {
      function validate(node, key, val) {
        for (const type of types) {
          if ((0, _is.default)(type, val)) {
            (0, validate_1.validateChild)(node, key, val);
            return;
          }
        }

        throw new TypeError(
          `Property ${key} of ${
            node.type
          } expected node to be of a type ${JSON.stringify(
            types,
          )} but instead got ${JSON.stringify(
            val == null ? void 0 : val.type,
          )}`,
        );
      }

      validate.oneOfNodeTypes = types;
      return validate;
    }

    function assertNodeOrValueType(...types) {
      function validate(node, key, val) {
        for (const type of types) {
          if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, validate_1.validateChild)(node, key, val);
            return;
          }
        }

        throw new TypeError(
          `Property ${key} of ${
            node.type
          } expected node to be of a type ${JSON.stringify(
            types,
          )} but instead got ${JSON.stringify(
            val == null ? void 0 : val.type,
          )}`,
        );
      }

      validate.oneOfNodeOrValueTypes = types;
      return validate;
    }

    function assertValueType(type) {
      function validate(node, key, val) {
        const valid = getType(val) === type;

        if (!valid) {
          throw new TypeError(
            `Property ${key} expected type of ${type} but got ${getType(val)}`,
          );
        }
      }

      validate.type = type;
      return validate;
    }

    function assertShape(shape) {
      function validate(node, key, val) {
        const errors = [];

        for (const property of Object.keys(shape)) {
          try {
            (0, validate_1.validateField)(
              node,
              property,
              val[property],
              shape[property],
            );
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }

            throw error;
          }
        }

        if (errors.length) {
          throw new TypeError(
            `Property ${key} of ${
              node.type
            } expected to have the following:\n${errors.join('\n')}`,
          );
        }
      }

      validate.shapeOf = shape;
      return validate;
    }

    function assertOptionalChainStart() {
      function validate(node) {
        var _current;

        let current = node;

        while (node) {
          const {type} = current;

          if (type === 'OptionalCallExpression') {
            if (current.optional) return;
            current = current.callee;
            continue;
          }

          if (type === 'OptionalMemberExpression') {
            if (current.optional) return;
            current = current.object;
            continue;
          }

          break;
        }

        throw new TypeError(
          `Non-optional ${
            node.type
          } must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${
            (_current = current) == null ? void 0 : _current.type
          }`,
        );
      }

      return validate;
    }

    function chain(...fns) {
      function validate(...args) {
        for (const fn of fns) {
          fn(...args);
        }
      }

      validate.chainOf = fns;

      if (
        fns.length >= 2 &&
        'type' in fns[0] &&
        fns[0].type === 'array' &&
        !('each' in fns[1])
      ) {
        throw new Error(
          `An assertValueType("array") validator can only be followed by an assertEach(...) validator.`,
        );
      }

      return validate;
    }

    const validTypeOpts = [
      'aliases',
      'builder',
      'deprecatedAlias',
      'fields',
      'inherits',
      'visitor',
      'validate',
    ];
    const validFieldKeys = ['default', 'optional', 'validate'];

    function defineType(type, opts = {}) {
      const inherits = (opts.inherits && store[opts.inherits]) || {};
      let fields = opts.fields;

      if (!fields) {
        fields = {};

        if (inherits.fields) {
          const keys = Object.getOwnPropertyNames(inherits.fields);

          for (const key of keys) {
            const field = inherits.fields[key];
            const def = field.default;

            if (
              Array.isArray(def)
                ? def.length > 0
                : def && typeof def === 'object'
            ) {
              throw new Error(
                'field defaults can only be primitives or empty arrays currently',
              );
            }

            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              validate: field.validate,
            };
          }
        }
      }

      const visitor = opts.visitor || inherits.visitor || [];
      const aliases = opts.aliases || inherits.aliases || [];
      const builder = opts.builder || inherits.builder || opts.visitor || [];

      for (const k of Object.keys(opts)) {
        if (validTypeOpts.indexOf(k) === -1) {
          throw new Error(`Unknown type option "${k}" on ${type}`);
        }
      }

      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }

      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }

      for (const key of Object.keys(fields)) {
        const field = fields[key];

        if (field.default !== undefined && builder.indexOf(key) === -1) {
          field.optional = true;
        }

        if (field.default === undefined) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }

        for (const k of Object.keys(field)) {
          if (validFieldKeys.indexOf(k) === -1) {
            throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
        }
      }

      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });

      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }

      store[type] = opts;
    }

    const store = {};
  });

  var core = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

    var _is = _interopRequireDefault(is_1);

    var _isValidIdentifier = _interopRequireDefault(isValidIdentifier_1);

    var _utils = _interopRequireWildcard(utils);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    (0, _utils.default)('ArrayExpression', {
      fields: {
        elements: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeOrValueType)(
                'null',
                'Expression',
                'SpreadElement',
              ),
            ),
          ),
          default: !browser$1.env.BABEL_TYPES_8_BREAKING ? [] : undefined,
        },
      },
      visitor: ['elements'],
      aliases: ['Expression'],
    });
    (0, _utils.default)('AssignmentExpression', {
      fields: {
        operator: {
          validate: (function () {
            if (!browser$1.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertValueType)('string');
            }

            const identifier = (0, _utils.assertOneOf)(
              ...constants.ASSIGNMENT_OPERATORS,
            );
            const pattern = (0, _utils.assertOneOf)('=');
            return function (node, key, val) {
              const validator = (0, _is.default)('Pattern', node.left)
                ? pattern
                : identifier;
              validator(node, key, val);
            };
          })(),
        },
        left: {
          validate: !browser$1.env.BABEL_TYPES_8_BREAKING
            ? (0, _utils.assertNodeType)('LVal')
            : (0, _utils.assertNodeType)(
                'Identifier',
                'MemberExpression',
                'ArrayPattern',
                'ObjectPattern',
              ),
        },
        right: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
      builder: ['operator', 'left', 'right'],
      visitor: ['left', 'right'],
      aliases: ['Expression'],
    });
    (0, _utils.default)('BinaryExpression', {
      builder: ['operator', 'left', 'right'],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(...constants.BINARY_OPERATORS),
        },
        left: {
          validate: (function () {
            const expression = (0, _utils.assertNodeType)('Expression');
            const inOp = (0, _utils.assertNodeType)(
              'Expression',
              'PrivateName',
            );

            const validator = function (node, key, val) {
              const validator = node.operator === 'in' ? inOp : expression;
              validator(node, key, val);
            };

            validator.oneOfNodeTypes = ['Expression', 'PrivateName'];
            return validator;
          })(),
        },
        right: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
      visitor: ['left', 'right'],
      aliases: ['Binary', 'Expression'],
    });
    (0, _utils.default)('InterpreterDirective', {
      builder: ['value'],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)('string'),
        },
      },
    });
    (0, _utils.default)('Directive', {
      visitor: ['value'],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)('DirectiveLiteral'),
        },
      },
    });
    (0, _utils.default)('DirectiveLiteral', {
      builder: ['value'],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)('string'),
        },
      },
    });
    (0, _utils.default)('BlockStatement', {
      builder: ['body', 'directives'],
      visitor: ['directives', 'body'],
      fields: {
        directives: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Directive')),
          ),
          default: [],
        },
        body: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Statement')),
          ),
        },
      },
      aliases: ['Scopable', 'BlockParent', 'Block', 'Statement'],
    });
    (0, _utils.default)('BreakStatement', {
      visitor: ['label'],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)('Identifier'),
          optional: true,
        },
      },
      aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
    });
    (0, _utils.default)('CallExpression', {
      visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
      builder: ['callee', 'arguments'],
      aliases: ['Expression'],
      fields: Object.assign(
        {
          callee: {
            validate: (0, _utils.assertNodeType)(
              'Expression',
              'V8IntrinsicIdentifier',
            ),
          },
          arguments: {
            validate: (0, _utils.chain)(
              (0, _utils.assertValueType)('array'),
              (0, _utils.assertEach)(
                (0, _utils.assertNodeType)(
                  'Expression',
                  'SpreadElement',
                  'JSXNamespacedName',
                  'ArgumentPlaceholder',
                ),
              ),
            ),
          },
        },
        !browser$1.env.BABEL_TYPES_8_BREAKING
          ? {
              optional: {
                validate: (0, _utils.assertOneOf)(true, false),
                optional: true,
              },
            }
          : {},
        {
          typeArguments: {
            validate: (0, _utils.assertNodeType)('TypeParameterInstantiation'),
            optional: true,
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)(
              'TSTypeParameterInstantiation',
            ),
            optional: true,
          },
        },
      ),
    });
    (0, _utils.default)('CatchClause', {
      visitor: ['param', 'body'],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)(
            'Identifier',
            'ArrayPattern',
            'ObjectPattern',
          ),
          optional: true,
        },
        body: {
          validate: (0, _utils.assertNodeType)('BlockStatement'),
        },
      },
      aliases: ['Scopable', 'BlockParent'],
    });
    (0, _utils.default)('ConditionalExpression', {
      visitor: ['test', 'consequent', 'alternate'],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        consequent: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        alternate: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
      aliases: ['Expression', 'Conditional'],
    });
    (0, _utils.default)('ContinueStatement', {
      visitor: ['label'],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)('Identifier'),
          optional: true,
        },
      },
      aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
    });
    (0, _utils.default)('DebuggerStatement', {
      aliases: ['Statement'],
    });
    (0, _utils.default)('DoWhileStatement', {
      visitor: ['test', 'body'],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        body: {
          validate: (0, _utils.assertNodeType)('Statement'),
        },
      },
      aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
    });
    (0, _utils.default)('EmptyStatement', {
      aliases: ['Statement'],
    });
    (0, _utils.default)('ExpressionStatement', {
      visitor: ['expression'],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
      aliases: ['Statement', 'ExpressionWrapper'],
    });
    (0, _utils.default)('File', {
      builder: ['program', 'comments', 'tokens'],
      visitor: ['program'],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)('Program'),
        },
        comments: {
          validate: !browser$1.env.BABEL_TYPES_8_BREAKING
            ? Object.assign(() => {}, {
                each: {
                  oneOfNodeTypes: ['CommentBlock', 'CommentLine'],
                },
              })
            : (0, _utils.assertEach)(
                (0, _utils.assertNodeType)('CommentBlock', 'CommentLine'),
              ),
          optional: true,
        },
        tokens: {
          validate: (0, _utils.assertEach)(
            Object.assign(() => {}, {
              type: 'any',
            }),
          ),
          optional: true,
        },
      },
    });
    (0, _utils.default)('ForInStatement', {
      visitor: ['left', 'right', 'body'],
      aliases: [
        'Scopable',
        'Statement',
        'For',
        'BlockParent',
        'Loop',
        'ForXStatement',
      ],
      fields: {
        left: {
          validate: !browser$1.env.BABEL_TYPES_8_BREAKING
            ? (0, _utils.assertNodeType)('VariableDeclaration', 'LVal')
            : (0, _utils.assertNodeType)(
                'VariableDeclaration',
                'Identifier',
                'MemberExpression',
                'ArrayPattern',
                'ObjectPattern',
              ),
        },
        right: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        body: {
          validate: (0, _utils.assertNodeType)('Statement'),
        },
      },
    });
    (0, _utils.default)('ForStatement', {
      visitor: ['init', 'test', 'update', 'body'],
      aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop'],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)(
            'VariableDeclaration',
            'Expression',
          ),
          optional: true,
        },
        test: {
          validate: (0, _utils.assertNodeType)('Expression'),
          optional: true,
        },
        update: {
          validate: (0, _utils.assertNodeType)('Expression'),
          optional: true,
        },
        body: {
          validate: (0, _utils.assertNodeType)('Statement'),
        },
      },
    });
    const functionCommon = {
      params: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)('array'),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              'Identifier',
              'Pattern',
              'RestElement',
              'TSParameterProperty',
            ),
          ),
        ),
      },
      generator: {
        default: false,
      },
      async: {
        default: false,
      },
    };
    exports.functionCommon = functionCommon;
    const functionTypeAnnotationCommon = {
      returnType: {
        validate: (0, _utils.assertNodeType)(
          'TypeAnnotation',
          'TSTypeAnnotation',
          'Noop',
        ),
        optional: true,
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          'TypeParameterDeclaration',
          'TSTypeParameterDeclaration',
          'Noop',
        ),
        optional: true,
      },
    };
    exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    const functionDeclarationCommon = Object.assign({}, functionCommon, {
      declare: {
        validate: (0, _utils.assertValueType)('boolean'),
        optional: true,
      },
      id: {
        validate: (0, _utils.assertNodeType)('Identifier'),
        optional: true,
      },
    });
    exports.functionDeclarationCommon = functionDeclarationCommon;
    (0, _utils.default)('FunctionDeclaration', {
      builder: ['id', 'params', 'body', 'generator', 'async'],
      visitor: ['id', 'params', 'body', 'returnType', 'typeParameters'],
      fields: Object.assign(
        {},
        functionDeclarationCommon,
        functionTypeAnnotationCommon,
        {
          body: {
            validate: (0, _utils.assertNodeType)('BlockStatement'),
          },
        },
      ),
      aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Statement',
        'Pureish',
        'Declaration',
      ],
      validate: (function () {
        if (!browser$1.env.BABEL_TYPES_8_BREAKING) return () => {};
        const identifier = (0, _utils.assertNodeType)('Identifier');
        return function (parent, key, node) {
          if (!(0, _is.default)('ExportDefaultDeclaration', parent)) {
            identifier(node, 'id', node.id);
          }
        };
      })(),
    });
    (0, _utils.default)('FunctionExpression', {
      inherits: 'FunctionDeclaration',
      aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Expression',
        'Pureish',
      ],
      fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        id: {
          validate: (0, _utils.assertNodeType)('Identifier'),
          optional: true,
        },
        body: {
          validate: (0, _utils.assertNodeType)('BlockStatement'),
        },
      }),
    });
    const patternLikeCommon = {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)(
          'TypeAnnotation',
          'TSTypeAnnotation',
          'Noop',
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)('array'),
          (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator')),
        ),
      },
    };
    exports.patternLikeCommon = patternLikeCommon;
    (0, _utils.default)('Identifier', {
      builder: ['name'],
      visitor: ['typeAnnotation', 'decorators'],
      aliases: ['Expression', 'PatternLike', 'LVal', 'TSEntityName'],
      fields: Object.assign({}, patternLikeCommon, {
        name: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('string'),
            Object.assign(
              function (node, key, val) {
                if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;

                if (!(0, _isValidIdentifier.default)(val, false)) {
                  throw new TypeError(
                    `"${val}" is not a valid identifier name`,
                  );
                }
              },
              {
                type: 'string',
              },
            ),
          ),
        },
        optional: {
          validate: (0, _utils.assertValueType)('boolean'),
          optional: true,
        },
      }),

      validate(parent, key, node) {
        if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;
        const match = /\.(\w+)$/.exec(key);
        if (!match) return;
        const [, parentKey] = match;
        const nonComp = {
          computed: false,
        };

        if (parentKey === 'property') {
          if ((0, _is.default)('MemberExpression', parent, nonComp)) return;
          if ((0, _is.default)('OptionalMemberExpression', parent, nonComp))
            return;
        } else if (parentKey === 'key') {
          if ((0, _is.default)('Property', parent, nonComp)) return;
          if ((0, _is.default)('Method', parent, nonComp)) return;
        } else if (parentKey === 'exported') {
          if ((0, _is.default)('ExportSpecifier', parent)) return;
        } else if (parentKey === 'imported') {
          if (
            (0, _is.default)('ImportSpecifier', parent, {
              imported: node,
            })
          )
            return;
        } else if (parentKey === 'meta') {
          if (
            (0, _is.default)('MetaProperty', parent, {
              meta: node,
            })
          )
            return;
        }

        if (
          ((0, lib$1.isKeyword)(node.name) ||
            (0, lib$1.isReservedWord)(node.name, false)) &&
          node.name !== 'this'
        ) {
          throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
      },
    });
    (0, _utils.default)('IfStatement', {
      visitor: ['test', 'consequent', 'alternate'],
      aliases: ['Statement', 'Conditional'],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        consequent: {
          validate: (0, _utils.assertNodeType)('Statement'),
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)('Statement'),
        },
      },
    });
    (0, _utils.default)('LabeledStatement', {
      visitor: ['label', 'body'],
      aliases: ['Statement'],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)('Identifier'),
        },
        body: {
          validate: (0, _utils.assertNodeType)('Statement'),
        },
      },
    });
    (0, _utils.default)('StringLiteral', {
      builder: ['value'],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)('string'),
        },
      },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    });
    (0, _utils.default)('NumericLiteral', {
      builder: ['value'],
      deprecatedAlias: 'NumberLiteral',
      fields: {
        value: {
          validate: (0, _utils.assertValueType)('number'),
        },
      },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    });
    (0, _utils.default)('NullLiteral', {
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    });
    (0, _utils.default)('BooleanLiteral', {
      builder: ['value'],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)('boolean'),
        },
      },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    });
    (0, _utils.default)('RegExpLiteral', {
      builder: ['pattern', 'flags'],
      deprecatedAlias: 'RegexLiteral',
      aliases: ['Expression', 'Pureish', 'Literal'],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)('string'),
        },
        flags: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('string'),
            Object.assign(
              function (node, key, val) {
                if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;
                const invalid = /[^gimsuy]/.exec(val);

                if (invalid) {
                  throw new TypeError(
                    `"${invalid[0]}" is not a valid RegExp flag`,
                  );
                }
              },
              {
                type: 'string',
              },
            ),
          ),
          default: '',
        },
      },
    });
    (0, _utils.default)('LogicalExpression', {
      builder: ['operator', 'left', 'right'],
      visitor: ['left', 'right'],
      aliases: ['Binary', 'Expression'],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(...constants.LOGICAL_OPERATORS),
        },
        left: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        right: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
    });
    (0, _utils.default)('MemberExpression', {
      builder: ['object', 'property', 'computed', 'optional'],
      visitor: ['object', 'property'],
      aliases: ['Expression', 'LVal'],
      fields: Object.assign(
        {
          object: {
            validate: (0, _utils.assertNodeType)('Expression'),
          },
          property: {
            validate: (function () {
              const normal = (0, _utils.assertNodeType)(
                'Identifier',
                'PrivateName',
              );
              const computed = (0, _utils.assertNodeType)('Expression');

              const validator = function (node, key, val) {
                const validator = node.computed ? computed : normal;
                validator(node, key, val);
              };

              validator.oneOfNodeTypes = [
                'Expression',
                'Identifier',
                'PrivateName',
              ];
              return validator;
            })(),
          },
          computed: {
            default: false,
          },
        },
        !browser$1.env.BABEL_TYPES_8_BREAKING
          ? {
              optional: {
                validate: (0, _utils.assertOneOf)(true, false),
                optional: true,
              },
            }
          : {},
      ),
    });
    (0, _utils.default)('NewExpression', {
      inherits: 'CallExpression',
    });
    (0, _utils.default)('Program', {
      visitor: ['directives', 'body'],
      builder: ['body', 'directives', 'sourceType', 'interpreter'],
      fields: {
        sourceFile: {
          validate: (0, _utils.assertValueType)('string'),
        },
        sourceType: {
          validate: (0, _utils.assertOneOf)('script', 'module'),
          default: 'script',
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)('InterpreterDirective'),
          default: null,
          optional: true,
        },
        directives: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Directive')),
          ),
          default: [],
        },
        body: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Statement')),
          ),
        },
      },
      aliases: ['Scopable', 'BlockParent', 'Block'],
    });
    (0, _utils.default)('ObjectExpression', {
      visitor: ['properties'],
      aliases: ['Expression'],
      fields: {
        properties: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                'ObjectMethod',
                'ObjectProperty',
                'SpreadElement',
              ),
            ),
          ),
        },
      },
    });
    (0, _utils.default)('ObjectMethod', {
      builder: [
        'kind',
        'key',
        'params',
        'body',
        'computed',
        'generator',
        'async',
      ],
      fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        kind: Object.assign(
          {
            validate: (0, _utils.assertOneOf)('method', 'get', 'set'),
          },
          !browser$1.env.BABEL_TYPES_8_BREAKING
            ? {
                default: 'method',
              }
            : {},
        ),
        computed: {
          default: false,
        },
        key: {
          validate: (function () {
            const normal = (0, _utils.assertNodeType)(
              'Identifier',
              'StringLiteral',
              'NumericLiteral',
            );
            const computed = (0, _utils.assertNodeType)('Expression');

            const validator = function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };

            validator.oneOfNodeTypes = [
              'Expression',
              'Identifier',
              'StringLiteral',
              'NumericLiteral',
            ];
            return validator;
          })(),
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator')),
          ),
          optional: true,
        },
        body: {
          validate: (0, _utils.assertNodeType)('BlockStatement'),
        },
      }),
      visitor: [
        'key',
        'params',
        'body',
        'decorators',
        'returnType',
        'typeParameters',
      ],
      aliases: [
        'UserWhitespacable',
        'Function',
        'Scopable',
        'BlockParent',
        'FunctionParent',
        'Method',
        'ObjectMember',
      ],
    });
    (0, _utils.default)('ObjectProperty', {
      builder: [
        'key',
        'value',
        'computed',
        'shorthand',
        ...(!browser$1.env.BABEL_TYPES_8_BREAKING ? ['decorators'] : []),
      ],
      fields: {
        computed: {
          default: false,
        },
        key: {
          validate: (function () {
            const normal = (0, _utils.assertNodeType)(
              'Identifier',
              'StringLiteral',
              'NumericLiteral',
            );
            const computed = (0, _utils.assertNodeType)('Expression');

            const validator = function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };

            validator.oneOfNodeTypes = [
              'Expression',
              'Identifier',
              'StringLiteral',
              'NumericLiteral',
            ];
            return validator;
          })(),
        },
        value: {
          validate: (0, _utils.assertNodeType)('Expression', 'PatternLike'),
        },
        shorthand: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('boolean'),
            Object.assign(
              function (node, key, val) {
                if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;

                if (val && node.computed) {
                  throw new TypeError(
                    'Property shorthand of ObjectProperty cannot be true if computed is true',
                  );
                }
              },
              {
                type: 'boolean',
              },
            ),
            function (node, key, val) {
              if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;

              if (val && !(0, _is.default)('Identifier', node.key)) {
                throw new TypeError(
                  'Property shorthand of ObjectProperty cannot be true if key is not an Identifier',
                );
              }
            },
          ),
          default: false,
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator')),
          ),
          optional: true,
        },
      },
      visitor: ['key', 'value', 'decorators'],
      aliases: ['UserWhitespacable', 'Property', 'ObjectMember'],
      validate: (function () {
        const pattern = (0, _utils.assertNodeType)('Identifier', 'Pattern');
        const expression = (0, _utils.assertNodeType)('Expression');
        return function (parent, key, node) {
          if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;
          const validator = (0, _is.default)('ObjectPattern', parent)
            ? pattern
            : expression;
          validator(node, 'value', node.value);
        };
      })(),
    });
    (0, _utils.default)('RestElement', {
      visitor: ['argument', 'typeAnnotation'],
      builder: ['argument'],
      aliases: ['LVal', 'PatternLike'],
      deprecatedAlias: 'RestProperty',
      fields: Object.assign({}, patternLikeCommon, {
        argument: {
          validate: !browser$1.env.BABEL_TYPES_8_BREAKING
            ? (0, _utils.assertNodeType)('LVal')
            : (0, _utils.assertNodeType)(
                'Identifier',
                'Pattern',
                'MemberExpression',
              ),
        },
      }),

      validate(parent, key) {
        if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;
        const match = /(\w+)\[(\d+)\]/.exec(key);
        if (!match) throw new Error('Internal Babel error: malformed key.');
        const [, listKey, index] = match;

        if (parent[listKey].length > index + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      },
    });
    (0, _utils.default)('ReturnStatement', {
      visitor: ['argument'],
      aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)('Expression'),
          optional: true,
        },
      },
    });
    (0, _utils.default)('SequenceExpression', {
      visitor: ['expressions'],
      fields: {
        expressions: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Expression')),
          ),
        },
      },
      aliases: ['Expression'],
    });
    (0, _utils.default)('ParenthesizedExpression', {
      visitor: ['expression'],
      aliases: ['Expression', 'ExpressionWrapper'],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
    });
    (0, _utils.default)('SwitchCase', {
      visitor: ['test', 'consequent'],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)('Expression'),
          optional: true,
        },
        consequent: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Statement')),
          ),
        },
      },
    });
    (0, _utils.default)('SwitchStatement', {
      visitor: ['discriminant', 'cases'],
      aliases: ['Statement', 'BlockParent', 'Scopable'],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        cases: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('SwitchCase')),
          ),
        },
      },
    });
    (0, _utils.default)('ThisExpression', {
      aliases: ['Expression'],
    });
    (0, _utils.default)('ThrowStatement', {
      visitor: ['argument'],
      aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
    });
    (0, _utils.default)('TryStatement', {
      visitor: ['block', 'handler', 'finalizer'],
      aliases: ['Statement'],
      fields: {
        block: {
          validate: (0, _utils.chain)(
            (0, _utils.assertNodeType)('BlockStatement'),
            Object.assign(
              function (node) {
                if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;

                if (!node.handler && !node.finalizer) {
                  throw new TypeError(
                    'TryStatement expects either a handler or finalizer, or both',
                  );
                }
              },
              {
                oneOfNodeTypes: ['BlockStatement'],
              },
            ),
          ),
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)('CatchClause'),
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)('BlockStatement'),
        },
      },
    });
    (0, _utils.default)('UnaryExpression', {
      builder: ['operator', 'argument', 'prefix'],
      fields: {
        prefix: {
          default: true,
        },
        argument: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        operator: {
          validate: (0, _utils.assertOneOf)(...constants.UNARY_OPERATORS),
        },
      },
      visitor: ['argument'],
      aliases: ['UnaryLike', 'Expression'],
    });
    (0, _utils.default)('UpdateExpression', {
      builder: ['operator', 'argument', 'prefix'],
      fields: {
        prefix: {
          default: false,
        },
        argument: {
          validate: !browser$1.env.BABEL_TYPES_8_BREAKING
            ? (0, _utils.assertNodeType)('Expression')
            : (0, _utils.assertNodeType)('Identifier', 'MemberExpression'),
        },
        operator: {
          validate: (0, _utils.assertOneOf)(...constants.UPDATE_OPERATORS),
        },
      },
      visitor: ['argument'],
      aliases: ['Expression'],
    });
    (0, _utils.default)('VariableDeclaration', {
      builder: ['kind', 'declarations'],
      visitor: ['declarations'],
      aliases: ['Statement', 'Declaration'],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)('boolean'),
          optional: true,
        },
        kind: {
          validate: (0, _utils.assertOneOf)('var', 'let', 'const'),
        },
        declarations: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)('VariableDeclarator'),
            ),
          ),
        },
      },

      validate(parent, key, node) {
        if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;
        if (
          !(0, _is.default)('ForXStatement', parent, {
            left: node,
          })
        )
          return;

        if (node.declarations.length !== 1) {
          throw new TypeError(
            `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,
          );
        }
      },
    });
    (0, _utils.default)('VariableDeclarator', {
      visitor: ['id', 'init'],
      fields: {
        id: {
          validate: (function () {
            if (!browser$1.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)('LVal');
            }

            const normal = (0, _utils.assertNodeType)(
              'Identifier',
              'ArrayPattern',
              'ObjectPattern',
            );
            const without = (0, _utils.assertNodeType)('Identifier');
            return function (node, key, val) {
              const validator = node.init ? normal : without;
              validator(node, key, val);
            };
          })(),
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)('boolean'),
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
    });
    (0, _utils.default)('WhileStatement', {
      visitor: ['test', 'body'],
      aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        body: {
          validate: (0, _utils.assertNodeType)('Statement'),
        },
      },
    });
    (0, _utils.default)('WithStatement', {
      visitor: ['object', 'body'],
      aliases: ['Statement'],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        body: {
          validate: (0, _utils.assertNodeType)('Statement'),
        },
      },
    });
    (0, _utils.default)('AssignmentPattern', {
      visitor: ['left', 'right', 'decorators'],
      builder: ['left', 'right'],
      aliases: ['Pattern', 'PatternLike', 'LVal'],
      fields: Object.assign({}, patternLikeCommon, {
        left: {
          validate: (0, _utils.assertNodeType)(
            'Identifier',
            'ObjectPattern',
            'ArrayPattern',
            'MemberExpression',
          ),
        },
        right: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator')),
          ),
          optional: true,
        },
      }),
    });
    (0, _utils.default)('ArrayPattern', {
      visitor: ['elements', 'typeAnnotation'],
      builder: ['elements'],
      aliases: ['Pattern', 'PatternLike', 'LVal'],
      fields: Object.assign({}, patternLikeCommon, {
        elements: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeOrValueType)('null', 'PatternLike'),
            ),
          ),
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator')),
          ),
          optional: true,
        },
      }),
    });
    (0, _utils.default)('ArrowFunctionExpression', {
      builder: ['params', 'body', 'async'],
      visitor: ['params', 'body', 'returnType', 'typeParameters'],
      aliases: [
        'Scopable',
        'Function',
        'BlockParent',
        'FunctionParent',
        'Expression',
        'Pureish',
      ],
      fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        expression: {
          validate: (0, _utils.assertValueType)('boolean'),
        },
        body: {
          validate: (0, _utils.assertNodeType)('BlockStatement', 'Expression'),
        },
      }),
    });
    (0, _utils.default)('ClassBody', {
      visitor: ['body'],
      fields: {
        body: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                'ClassMethod',
                'ClassPrivateMethod',
                'ClassProperty',
                'ClassPrivateProperty',
                'TSDeclareMethod',
                'TSIndexSignature',
              ),
            ),
          ),
        },
      },
    });
    (0, _utils.default)('ClassExpression', {
      builder: ['id', 'superClass', 'body', 'decorators'],
      visitor: [
        'id',
        'body',
        'superClass',
        'mixins',
        'typeParameters',
        'superTypeParameters',
        'implements',
        'decorators',
      ],
      aliases: ['Scopable', 'Class', 'Expression'],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)('Identifier'),
          optional: true,
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)(
            'TypeParameterDeclaration',
            'TSTypeParameterDeclaration',
            'Noop',
          ),
          optional: true,
        },
        body: {
          validate: (0, _utils.assertNodeType)('ClassBody'),
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)(
            'TypeParameterInstantiation',
            'TSTypeParameterInstantiation',
          ),
          optional: true,
        },
        implements: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                'TSExpressionWithTypeArguments',
                'ClassImplements',
              ),
            ),
          ),
          optional: true,
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator')),
          ),
          optional: true,
        },
        mixins: {
          validate: (0, _utils.assertNodeType)('InterfaceExtends'),
          optional: true,
        },
      },
    });
    (0, _utils.default)('ClassDeclaration', {
      inherits: 'ClassExpression',
      aliases: ['Scopable', 'Class', 'Statement', 'Declaration'],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)('Identifier'),
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)(
            'TypeParameterDeclaration',
            'TSTypeParameterDeclaration',
            'Noop',
          ),
          optional: true,
        },
        body: {
          validate: (0, _utils.assertNodeType)('ClassBody'),
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)(
            'TypeParameterInstantiation',
            'TSTypeParameterInstantiation',
          ),
          optional: true,
        },
        implements: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                'TSExpressionWithTypeArguments',
                'ClassImplements',
              ),
            ),
          ),
          optional: true,
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator')),
          ),
          optional: true,
        },
        mixins: {
          validate: (0, _utils.assertNodeType)('InterfaceExtends'),
          optional: true,
        },
        declare: {
          validate: (0, _utils.assertValueType)('boolean'),
          optional: true,
        },
        abstract: {
          validate: (0, _utils.assertValueType)('boolean'),
          optional: true,
        },
      },
      validate: (function () {
        const identifier = (0, _utils.assertNodeType)('Identifier');
        return function (parent, key, node) {
          if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;

          if (!(0, _is.default)('ExportDefaultDeclaration', parent)) {
            identifier(node, 'id', node.id);
          }
        };
      })(),
    });
    (0, _utils.default)('ExportAllDeclaration', {
      visitor: ['source'],
      aliases: [
        'Statement',
        'Declaration',
        'ModuleDeclaration',
        'ExportDeclaration',
      ],
      fields: {
        source: {
          validate: (0, _utils.assertNodeType)('StringLiteral'),
        },
        exportKind: (0, _utils.validateOptional)(
          (0, _utils.assertOneOf)('type', 'value'),
        ),
        assertions: {
          optional: true,
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)('ImportAttribute'),
            ),
          ),
        },
      },
    });
    (0, _utils.default)('ExportDefaultDeclaration', {
      visitor: ['declaration'],
      aliases: [
        'Statement',
        'Declaration',
        'ModuleDeclaration',
        'ExportDeclaration',
      ],
      fields: {
        declaration: {
          validate: (0, _utils.assertNodeType)(
            'FunctionDeclaration',
            'TSDeclareFunction',
            'ClassDeclaration',
            'Expression',
          ),
        },
      },
    });
    (0, _utils.default)('ExportNamedDeclaration', {
      visitor: ['declaration', 'specifiers', 'source'],
      aliases: [
        'Statement',
        'Declaration',
        'ModuleDeclaration',
        'ExportDeclaration',
      ],
      fields: {
        declaration: {
          optional: true,
          validate: (0, _utils.chain)(
            (0, _utils.assertNodeType)('Declaration'),
            Object.assign(
              function (node, key, val) {
                if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;

                if (val && node.specifiers.length) {
                  throw new TypeError(
                    'Only declaration or specifiers is allowed on ExportNamedDeclaration',
                  );
                }
              },
              {
                oneOfNodeTypes: ['Declaration'],
              },
            ),
            function (node, key, val) {
              if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;

              if (val && node.source) {
                throw new TypeError(
                  'Cannot export a declaration from a source',
                );
              }
            },
          ),
        },
        assertions: {
          optional: true,
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)('ImportAttribute'),
            ),
          ),
        },
        specifiers: {
          default: [],
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (function () {
                const sourced = (0, _utils.assertNodeType)(
                  'ExportSpecifier',
                  'ExportDefaultSpecifier',
                  'ExportNamespaceSpecifier',
                );
                const sourceless = (0, _utils.assertNodeType)(
                  'ExportSpecifier',
                );
                if (!browser$1.env.BABEL_TYPES_8_BREAKING) return sourced;
                return function (node, key, val) {
                  const validator = node.source ? sourced : sourceless;
                  validator(node, key, val);
                };
              })(),
            ),
          ),
        },
        source: {
          validate: (0, _utils.assertNodeType)('StringLiteral'),
          optional: true,
        },
        exportKind: (0, _utils.validateOptional)(
          (0, _utils.assertOneOf)('type', 'value'),
        ),
      },
    });
    (0, _utils.default)('ExportSpecifier', {
      visitor: ['local', 'exported'],
      aliases: ['ModuleSpecifier'],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)('Identifier'),
        },
        exported: {
          validate: (0, _utils.assertNodeType)('Identifier', 'StringLiteral'),
        },
      },
    });
    (0, _utils.default)('ForOfStatement', {
      visitor: ['left', 'right', 'body'],
      builder: ['left', 'right', 'body', 'await'],
      aliases: [
        'Scopable',
        'Statement',
        'For',
        'BlockParent',
        'Loop',
        'ForXStatement',
      ],
      fields: {
        left: {
          validate: (function () {
            if (!browser$1.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)('VariableDeclaration', 'LVal');
            }

            const declaration = (0, _utils.assertNodeType)(
              'VariableDeclaration',
            );
            const lval = (0, _utils.assertNodeType)(
              'Identifier',
              'MemberExpression',
              'ArrayPattern',
              'ObjectPattern',
            );
            return function (node, key, val) {
              if ((0, _is.default)('VariableDeclaration', val)) {
                declaration(node, key, val);
              } else {
                lval(node, key, val);
              }
            };
          })(),
        },
        right: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        body: {
          validate: (0, _utils.assertNodeType)('Statement'),
        },
        await: {
          default: false,
        },
      },
    });
    (0, _utils.default)('ImportDeclaration', {
      visitor: ['specifiers', 'source'],
      aliases: ['Statement', 'Declaration', 'ModuleDeclaration'],
      fields: {
        assertions: {
          optional: true,
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)('ImportAttribute'),
            ),
          ),
        },
        specifiers: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                'ImportSpecifier',
                'ImportDefaultSpecifier',
                'ImportNamespaceSpecifier',
              ),
            ),
          ),
        },
        source: {
          validate: (0, _utils.assertNodeType)('StringLiteral'),
        },
        importKind: {
          validate: (0, _utils.assertOneOf)('type', 'typeof', 'value'),
          optional: true,
        },
      },
    });
    (0, _utils.default)('ImportDefaultSpecifier', {
      visitor: ['local'],
      aliases: ['ModuleSpecifier'],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)('Identifier'),
        },
      },
    });
    (0, _utils.default)('ImportNamespaceSpecifier', {
      visitor: ['local'],
      aliases: ['ModuleSpecifier'],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)('Identifier'),
        },
      },
    });
    (0, _utils.default)('ImportSpecifier', {
      visitor: ['local', 'imported'],
      aliases: ['ModuleSpecifier'],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)('Identifier'),
        },
        imported: {
          validate: (0, _utils.assertNodeType)('Identifier', 'StringLiteral'),
        },
        importKind: {
          validate: (0, _utils.assertOneOf)('type', 'typeof'),
          optional: true,
        },
      },
    });
    (0, _utils.default)('MetaProperty', {
      visitor: ['meta', 'property'],
      aliases: ['Expression'],
      fields: {
        meta: {
          validate: (0, _utils.chain)(
            (0, _utils.assertNodeType)('Identifier'),
            Object.assign(
              function (node, key, val) {
                if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;
                let property;

                switch (val.name) {
                  case 'function':
                    property = 'sent';
                    break;

                  case 'new':
                    property = 'target';
                    break;

                  case 'import':
                    property = 'meta';
                    break;
                }

                if (
                  !(0, _is.default)('Identifier', node.property, {
                    name: property,
                  })
                ) {
                  throw new TypeError('Unrecognised MetaProperty');
                }
              },
              {
                oneOfNodeTypes: ['Identifier'],
              },
            ),
          ),
        },
        property: {
          validate: (0, _utils.assertNodeType)('Identifier'),
        },
      },
    });
    const classMethodOrPropertyCommon = {
      abstract: {
        validate: (0, _utils.assertValueType)('boolean'),
        optional: true,
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)('public', 'private', 'protected'),
        optional: true,
      },
      static: {
        default: false,
      },
      computed: {
        default: false,
      },
      optional: {
        validate: (0, _utils.assertValueType)('boolean'),
        optional: true,
      },
      key: {
        validate: (0, _utils.chain)(
          (function () {
            const normal = (0, _utils.assertNodeType)(
              'Identifier',
              'StringLiteral',
              'NumericLiteral',
            );
            const computed = (0, _utils.assertNodeType)('Expression');
            return function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          })(),
          (0, _utils.assertNodeType)(
            'Identifier',
            'StringLiteral',
            'NumericLiteral',
            'Expression',
          ),
        ),
      },
    };
    exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    const classMethodOrDeclareMethodCommon = Object.assign(
      {},
      functionCommon,
      classMethodOrPropertyCommon,
      {
        kind: {
          validate: (0, _utils.assertOneOf)(
            'get',
            'set',
            'method',
            'constructor',
          ),
          default: 'method',
        },
        access: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('string'),
            (0, _utils.assertOneOf)('public', 'private', 'protected'),
          ),
          optional: true,
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator')),
          ),
          optional: true,
        },
      },
    );
    exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    (0, _utils.default)('ClassMethod', {
      aliases: [
        'Function',
        'Scopable',
        'BlockParent',
        'FunctionParent',
        'Method',
      ],
      builder: [
        'kind',
        'key',
        'params',
        'body',
        'computed',
        'static',
        'generator',
        'async',
      ],
      visitor: [
        'key',
        'params',
        'body',
        'decorators',
        'returnType',
        'typeParameters',
      ],
      fields: Object.assign(
        {},
        classMethodOrDeclareMethodCommon,
        functionTypeAnnotationCommon,
        {
          body: {
            validate: (0, _utils.assertNodeType)('BlockStatement'),
          },
        },
      ),
    });
    (0, _utils.default)('ObjectPattern', {
      visitor: ['properties', 'typeAnnotation', 'decorators'],
      builder: ['properties'],
      aliases: ['Pattern', 'PatternLike', 'LVal'],
      fields: Object.assign({}, patternLikeCommon, {
        properties: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)('RestElement', 'ObjectProperty'),
            ),
          ),
        },
      }),
    });
    (0, _utils.default)('SpreadElement', {
      visitor: ['argument'],
      aliases: ['UnaryLike'],
      deprecatedAlias: 'SpreadProperty',
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
    });
    (0, _utils.default)('Super', {
      aliases: ['Expression'],
    });
    (0, _utils.default)('TaggedTemplateExpression', {
      visitor: ['tag', 'quasi'],
      aliases: ['Expression'],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        quasi: {
          validate: (0, _utils.assertNodeType)('TemplateLiteral'),
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)(
            'TypeParameterInstantiation',
            'TSTypeParameterInstantiation',
          ),
          optional: true,
        },
      },
    });
    (0, _utils.default)('TemplateElement', {
      builder: ['value', 'tail'],
      fields: {
        value: {
          validate: (0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)('string'),
            },
            cooked: {
              validate: (0, _utils.assertValueType)('string'),
              optional: true,
            },
          }),
        },
        tail: {
          default: false,
        },
      },
    });
    (0, _utils.default)('TemplateLiteral', {
      visitor: ['quasis', 'expressions'],
      aliases: ['Expression', 'Literal'],
      fields: {
        quasis: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)('TemplateElement'),
            ),
          ),
        },
        expressions: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)('Expression', 'TSType'),
            ),
            function (node, key, val) {
              if (node.quasis.length !== val.length + 1) {
                throw new TypeError(
                  `Number of ${
                    node.type
                  } quasis should be exactly one more than the number of expressions.\nExpected ${
                    val.length + 1
                  } quasis but got ${node.quasis.length}`,
                );
              }
            },
          ),
        },
      },
    });
    (0, _utils.default)('YieldExpression', {
      builder: ['argument', 'delegate'],
      visitor: ['argument'],
      aliases: ['Expression', 'Terminatorless'],
      fields: {
        delegate: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('boolean'),
            Object.assign(
              function (node, key, val) {
                if (!browser$1.env.BABEL_TYPES_8_BREAKING) return;

                if (val && !node.argument) {
                  throw new TypeError(
                    'Property delegate of YieldExpression cannot be true if there is no argument',
                  );
                }
              },
              {
                type: 'boolean',
              },
            ),
          ),
          default: false,
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
    });
    (0, _utils.default)('AwaitExpression', {
      builder: ['argument'],
      visitor: ['argument'],
      aliases: ['Expression', 'Terminatorless'],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
      },
    });
    (0, _utils.default)('Import', {
      aliases: ['Expression'],
    });
    (0, _utils.default)('BigIntLiteral', {
      builder: ['value'],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)('string'),
        },
      },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    });
    (0, _utils.default)('ExportNamespaceSpecifier', {
      visitor: ['exported'],
      aliases: ['ModuleSpecifier'],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)('Identifier'),
        },
      },
    });
    (0, _utils.default)('OptionalMemberExpression', {
      builder: ['object', 'property', 'computed', 'optional'],
      visitor: ['object', 'property'],
      aliases: ['Expression'],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        property: {
          validate: (function () {
            const normal = (0, _utils.assertNodeType)('Identifier');
            const computed = (0, _utils.assertNodeType)('Expression');

            const validator = function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };

            validator.oneOfNodeTypes = ['Expression', 'Identifier'];
            return validator;
          })(),
        },
        computed: {
          default: false,
        },
        optional: {
          validate: !browser$1.env.BABEL_TYPES_8_BREAKING
            ? (0, _utils.assertValueType)('boolean')
            : (0, _utils.chain)(
                (0, _utils.assertValueType)('boolean'),
                (0, _utils.assertOptionalChainStart)(),
              ),
        },
      },
    });
    (0, _utils.default)('OptionalCallExpression', {
      visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
      builder: ['callee', 'arguments', 'optional'],
      aliases: ['Expression'],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)('Expression'),
        },
        arguments: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)('array'),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                'Expression',
                'SpreadElement',
                'JSXNamespacedName',
                'ArgumentPlaceholder',
              ),
            ),
          ),
        },
        optional: {
          validate: !browser$1.env.BABEL_TYPES_8_BREAKING
            ? (0, _utils.assertValueType)('boolean')
            : (0, _utils.chain)(
                (0, _utils.assertValueType)('boolean'),
                (0, _utils.assertOptionalChainStart)(),
              ),
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)('TypeParameterInstantiation'),
          optional: true,
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)('TSTypeParameterInstantiation'),
          optional: true,
        },
      },
    });
  });

  var _utils = _interopRequireWildcard(utils);

  function _getRequireWildcardCache() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  const defineInterfaceishType = (
    name,
    typeParameterType = 'TypeParameterDeclaration',
  ) => {
    (0, _utils.default)(name, {
      builder: ['id', 'typeParameters', 'extends', 'body'],
      visitor: [
        'id',
        'typeParameters',
        'extends',
        'mixins',
        'implements',
        'body',
      ],
      aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
      fields: {
        id: (0, _utils.validateType)('Identifier'),
        typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
        extends: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)('InterfaceExtends'),
        ),
        mixins: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)('InterfaceExtends'),
        ),
        implements: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)('ClassImplements'),
        ),
        body: (0, _utils.validateType)('ObjectTypeAnnotation'),
      },
    });
  };

  (0, _utils.default)('AnyTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('ArrayTypeAnnotation', {
    visitor: ['elementType'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      elementType: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('BooleanTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('BooleanLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
    },
  });
  (0, _utils.default)('NullLiteralTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('ClassImplements', {
    visitor: ['id', 'typeParameters'],
    aliases: ['Flow'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      typeParameters: (0, _utils.validateOptionalType)(
        'TypeParameterInstantiation',
      ),
    },
  });
  defineInterfaceishType('DeclareClass');
  (0, _utils.default)('DeclareFunction', {
    visitor: ['id'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      predicate: (0, _utils.validateOptionalType)('DeclaredPredicate'),
    },
  });
  defineInterfaceishType('DeclareInterface');
  (0, _utils.default)('DeclareModule', {
    builder: ['id', 'body', 'kind'],
    visitor: ['id', 'body'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      id: (0, _utils.validateType)(['Identifier', 'StringLiteral']),
      body: (0, _utils.validateType)('BlockStatement'),
      kind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)('CommonJS', 'ES'),
      ),
    },
  });
  (0, _utils.default)('DeclareModuleExports', {
    visitor: ['typeAnnotation'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      typeAnnotation: (0, _utils.validateType)('TypeAnnotation'),
    },
  });
  (0, _utils.default)('DeclareTypeAlias', {
    visitor: ['id', 'typeParameters', 'right'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      typeParameters: (0, _utils.validateOptionalType)(
        'TypeParameterDeclaration',
      ),
      right: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('DeclareOpaqueType', {
    visitor: ['id', 'typeParameters', 'supertype'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      typeParameters: (0, _utils.validateOptionalType)(
        'TypeParameterDeclaration',
      ),
      supertype: (0, _utils.validateOptionalType)('FlowType'),
    },
  });
  (0, _utils.default)('DeclareVariable', {
    visitor: ['id'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
    },
  });
  (0, _utils.default)('DeclareExportDeclaration', {
    visitor: ['declaration', 'specifiers', 'source'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      declaration: (0, _utils.validateOptionalType)('Flow'),
      specifiers: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)([
          'ExportSpecifier',
          'ExportNamespaceSpecifier',
        ]),
      ),
      source: (0, _utils.validateOptionalType)('StringLiteral'),
      default: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)('boolean'),
      ),
    },
  });
  (0, _utils.default)('DeclareExportAllDeclaration', {
    visitor: ['source'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      source: (0, _utils.validateType)('StringLiteral'),
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)('type', 'value'),
      ),
    },
  });
  (0, _utils.default)('DeclaredPredicate', {
    visitor: ['value'],
    aliases: ['Flow', 'FlowPredicate'],
    fields: {
      value: (0, _utils.validateType)('Flow'),
    },
  });
  (0, _utils.default)('ExistsTypeAnnotation', {
    aliases: ['Flow', 'FlowType'],
  });
  (0, _utils.default)('FunctionTypeAnnotation', {
    visitor: ['typeParameters', 'params', 'rest', 'returnType'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)(
        'TypeParameterDeclaration',
      ),
      params: (0, _utils.validate)(
        (0, _utils.arrayOfType)('FunctionTypeParam'),
      ),
      rest: (0, _utils.validateOptionalType)('FunctionTypeParam'),
      this: (0, _utils.validateOptionalType)('FunctionTypeParam'),
      returnType: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('FunctionTypeParam', {
    visitor: ['name', 'typeAnnotation'],
    aliases: ['Flow'],
    fields: {
      name: (0, _utils.validateOptionalType)('Identifier'),
      typeAnnotation: (0, _utils.validateType)('FlowType'),
      optional: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)('boolean'),
      ),
    },
  });
  (0, _utils.default)('GenericTypeAnnotation', {
    visitor: ['id', 'typeParameters'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      id: (0, _utils.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
      typeParameters: (0, _utils.validateOptionalType)(
        'TypeParameterInstantiation',
      ),
    },
  });
  (0, _utils.default)('InferredPredicate', {
    aliases: ['Flow', 'FlowPredicate'],
  });
  (0, _utils.default)('InterfaceExtends', {
    visitor: ['id', 'typeParameters'],
    aliases: ['Flow'],
    fields: {
      id: (0, _utils.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
      typeParameters: (0, _utils.validateOptionalType)(
        'TypeParameterInstantiation',
      ),
    },
  });
  defineInterfaceishType('InterfaceDeclaration');
  (0, _utils.default)('InterfaceTypeAnnotation', {
    visitor: ['extends', 'body'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      extends: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)('InterfaceExtends'),
      ),
      body: (0, _utils.validateType)('ObjectTypeAnnotation'),
    },
  });
  (0, _utils.default)('IntersectionTypeAnnotation', {
    visitor: ['types'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)('FlowType')),
    },
  });
  (0, _utils.default)('MixedTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('EmptyTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('NullableTypeAnnotation', {
    visitor: ['typeAnnotation'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      typeAnnotation: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('NumberLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)('number')),
    },
  });
  (0, _utils.default)('NumberTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('ObjectTypeAnnotation', {
    visitor: ['properties', 'indexers', 'callProperties', 'internalSlots'],
    aliases: ['Flow', 'FlowType'],
    builder: [
      'properties',
      'indexers',
      'callProperties',
      'internalSlots',
      'exact',
    ],
    fields: {
      properties: (0, _utils.validate)(
        (0, _utils.arrayOfType)([
          'ObjectTypeProperty',
          'ObjectTypeSpreadProperty',
        ]),
      ),
      indexers: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)('ObjectTypeIndexer'),
      ),
      callProperties: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)('ObjectTypeCallProperty'),
      ),
      internalSlots: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)('ObjectTypeInternalSlot'),
      ),
      exact: {
        validate: (0, _utils.assertValueType)('boolean'),
        default: false,
      },
      inexact: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)('boolean'),
      ),
    },
  });
  (0, _utils.default)('ObjectTypeInternalSlot', {
    visitor: ['id', 'value', 'optional', 'static', 'method'],
    aliases: ['Flow', 'UserWhitespacable'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      value: (0, _utils.validateType)('FlowType'),
      optional: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
      static: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
      method: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
    },
  });
  (0, _utils.default)('ObjectTypeCallProperty', {
    visitor: ['value'],
    aliases: ['Flow', 'UserWhitespacable'],
    fields: {
      value: (0, _utils.validateType)('FlowType'),
      static: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
    },
  });
  (0, _utils.default)('ObjectTypeIndexer', {
    visitor: ['id', 'key', 'value', 'variance'],
    aliases: ['Flow', 'UserWhitespacable'],
    fields: {
      id: (0, _utils.validateOptionalType)('Identifier'),
      key: (0, _utils.validateType)('FlowType'),
      value: (0, _utils.validateType)('FlowType'),
      static: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
      variance: (0, _utils.validateOptionalType)('Variance'),
    },
  });
  (0, _utils.default)('ObjectTypeProperty', {
    visitor: ['key', 'value', 'variance'],
    aliases: ['Flow', 'UserWhitespacable'],
    fields: {
      key: (0, _utils.validateType)(['Identifier', 'StringLiteral']),
      value: (0, _utils.validateType)('FlowType'),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)('init', 'get', 'set')),
      static: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
      proto: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
      optional: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
      variance: (0, _utils.validateOptionalType)('Variance'),
      method: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
    },
  });
  (0, _utils.default)('ObjectTypeSpreadProperty', {
    visitor: ['argument'],
    aliases: ['Flow', 'UserWhitespacable'],
    fields: {
      argument: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('OpaqueType', {
    visitor: ['id', 'typeParameters', 'supertype', 'impltype'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      typeParameters: (0, _utils.validateOptionalType)(
        'TypeParameterDeclaration',
      ),
      supertype: (0, _utils.validateOptionalType)('FlowType'),
      impltype: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('QualifiedTypeIdentifier', {
    visitor: ['id', 'qualification'],
    aliases: ['Flow'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      qualification: (0, _utils.validateType)([
        'Identifier',
        'QualifiedTypeIdentifier',
      ]),
    },
  });
  (0, _utils.default)('StringLiteralTypeAnnotation', {
    builder: ['value'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)('string')),
    },
  });
  (0, _utils.default)('StringTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('SymbolTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('ThisTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('TupleTypeAnnotation', {
    visitor: ['types'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)('FlowType')),
    },
  });
  (0, _utils.default)('TypeofTypeAnnotation', {
    visitor: ['argument'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      argument: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('TypeAlias', {
    visitor: ['id', 'typeParameters', 'right'],
    aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      typeParameters: (0, _utils.validateOptionalType)(
        'TypeParameterDeclaration',
      ),
      right: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('TypeAnnotation', {
    aliases: ['Flow'],
    visitor: ['typeAnnotation'],
    fields: {
      typeAnnotation: (0, _utils.validateType)('FlowType'),
    },
  });
  (0, _utils.default)('TypeCastExpression', {
    visitor: ['expression', 'typeAnnotation'],
    aliases: ['Flow', 'ExpressionWrapper', 'Expression'],
    fields: {
      expression: (0, _utils.validateType)('Expression'),
      typeAnnotation: (0, _utils.validateType)('TypeAnnotation'),
    },
  });
  (0, _utils.default)('TypeParameter', {
    aliases: ['Flow'],
    visitor: ['bound', 'default', 'variance'],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)('string')),
      bound: (0, _utils.validateOptionalType)('TypeAnnotation'),
      default: (0, _utils.validateOptionalType)('FlowType'),
      variance: (0, _utils.validateOptionalType)('Variance'),
    },
  });
  (0, _utils.default)('TypeParameterDeclaration', {
    aliases: ['Flow'],
    visitor: ['params'],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)('TypeParameter')),
    },
  });
  (0, _utils.default)('TypeParameterInstantiation', {
    aliases: ['Flow'],
    visitor: ['params'],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)('FlowType')),
    },
  });
  (0, _utils.default)('UnionTypeAnnotation', {
    visitor: ['types'],
    aliases: ['Flow', 'FlowType'],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)('FlowType')),
    },
  });
  (0, _utils.default)('Variance', {
    aliases: ['Flow'],
    builder: ['kind'],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)('minus', 'plus')),
    },
  });
  (0, _utils.default)('VoidTypeAnnotation', {
    aliases: ['Flow', 'FlowType', 'FlowBaseAnnotation'],
  });
  (0, _utils.default)('EnumDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'body'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      body: (0, _utils.validateType)([
        'EnumBooleanBody',
        'EnumNumberBody',
        'EnumStringBody',
        'EnumSymbolBody',
      ]),
    },
  });
  (0, _utils.default)('EnumBooleanBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)('boolean'),
      ),
      members: (0, _utils.validateArrayOfType)('EnumBooleanMember'),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)('boolean'),
      ),
    },
  });
  (0, _utils.default)('EnumNumberBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)('boolean'),
      ),
      members: (0, _utils.validateArrayOfType)('EnumNumberMember'),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)('boolean'),
      ),
    },
  });
  (0, _utils.default)('EnumStringBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)('boolean'),
      ),
      members: (0, _utils.validateArrayOfType)([
        'EnumStringMember',
        'EnumDefaultedMember',
      ]),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)('boolean'),
      ),
    },
  });
  (0, _utils.default)('EnumSymbolBody', {
    aliases: ['EnumBody'],
    visitor: ['members'],
    fields: {
      members: (0, _utils.validateArrayOfType)('EnumDefaultedMember'),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)('boolean'),
      ),
    },
  });
  (0, _utils.default)('EnumBooleanMember', {
    aliases: ['EnumMember'],
    visitor: ['id'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      init: (0, _utils.validateType)('BooleanLiteral'),
    },
  });
  (0, _utils.default)('EnumNumberMember', {
    aliases: ['EnumMember'],
    visitor: ['id', 'init'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      init: (0, _utils.validateType)('NumericLiteral'),
    },
  });
  (0, _utils.default)('EnumStringMember', {
    aliases: ['EnumMember'],
    visitor: ['id', 'init'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
      init: (0, _utils.validateType)('StringLiteral'),
    },
  });
  (0, _utils.default)('EnumDefaultedMember', {
    aliases: ['EnumMember'],
    visitor: ['id'],
    fields: {
      id: (0, _utils.validateType)('Identifier'),
    },
  });

  var _utils$1 = _interopRequireWildcard$1(utils);

  function _getRequireWildcardCache$1() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$1 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$1(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$1();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  (0, _utils$1.default)('JSXAttribute', {
    visitor: ['name', 'value'],
    aliases: ['JSX', 'Immutable'],
    fields: {
      name: {
        validate: (0, _utils$1.assertNodeType)(
          'JSXIdentifier',
          'JSXNamespacedName',
        ),
      },
      value: {
        optional: true,
        validate: (0, _utils$1.assertNodeType)(
          'JSXElement',
          'JSXFragment',
          'StringLiteral',
          'JSXExpressionContainer',
        ),
      },
    },
  });
  (0, _utils$1.default)('JSXClosingElement', {
    visitor: ['name'],
    aliases: ['JSX', 'Immutable'],
    fields: {
      name: {
        validate: (0, _utils$1.assertNodeType)(
          'JSXIdentifier',
          'JSXMemberExpression',
          'JSXNamespacedName',
        ),
      },
    },
  });
  (0, _utils$1.default)('JSXElement', {
    builder: ['openingElement', 'closingElement', 'children', 'selfClosing'],
    visitor: ['openingElement', 'children', 'closingElement'],
    aliases: ['JSX', 'Immutable', 'Expression'],
    fields: {
      openingElement: {
        validate: (0, _utils$1.assertNodeType)('JSXOpeningElement'),
      },
      closingElement: {
        optional: true,
        validate: (0, _utils$1.assertNodeType)('JSXClosingElement'),
      },
      children: {
        validate: (0, _utils$1.chain)(
          (0, _utils$1.assertValueType)('array'),
          (0, _utils$1.assertEach)(
            (0, _utils$1.assertNodeType)(
              'JSXText',
              'JSXExpressionContainer',
              'JSXSpreadChild',
              'JSXElement',
              'JSXFragment',
            ),
          ),
        ),
      },
      selfClosing: {
        validate: (0, _utils$1.assertValueType)('boolean'),
        optional: true,
      },
    },
  });
  (0, _utils$1.default)('JSXEmptyExpression', {
    aliases: ['JSX'],
  });
  (0, _utils$1.default)('JSXExpressionContainer', {
    visitor: ['expression'],
    aliases: ['JSX', 'Immutable'],
    fields: {
      expression: {
        validate: (0, _utils$1.assertNodeType)(
          'Expression',
          'JSXEmptyExpression',
        ),
      },
    },
  });
  (0, _utils$1.default)('JSXSpreadChild', {
    visitor: ['expression'],
    aliases: ['JSX', 'Immutable'],
    fields: {
      expression: {
        validate: (0, _utils$1.assertNodeType)('Expression'),
      },
    },
  });
  (0, _utils$1.default)('JSXIdentifier', {
    builder: ['name'],
    aliases: ['JSX'],
    fields: {
      name: {
        validate: (0, _utils$1.assertValueType)('string'),
      },
    },
  });
  (0, _utils$1.default)('JSXMemberExpression', {
    visitor: ['object', 'property'],
    aliases: ['JSX'],
    fields: {
      object: {
        validate: (0, _utils$1.assertNodeType)(
          'JSXMemberExpression',
          'JSXIdentifier',
        ),
      },
      property: {
        validate: (0, _utils$1.assertNodeType)('JSXIdentifier'),
      },
    },
  });
  (0, _utils$1.default)('JSXNamespacedName', {
    visitor: ['namespace', 'name'],
    aliases: ['JSX'],
    fields: {
      namespace: {
        validate: (0, _utils$1.assertNodeType)('JSXIdentifier'),
      },
      name: {
        validate: (0, _utils$1.assertNodeType)('JSXIdentifier'),
      },
    },
  });
  (0, _utils$1.default)('JSXOpeningElement', {
    builder: ['name', 'attributes', 'selfClosing'],
    visitor: ['name', 'attributes'],
    aliases: ['JSX', 'Immutable'],
    fields: {
      name: {
        validate: (0, _utils$1.assertNodeType)(
          'JSXIdentifier',
          'JSXMemberExpression',
          'JSXNamespacedName',
        ),
      },
      selfClosing: {
        default: false,
      },
      attributes: {
        validate: (0, _utils$1.chain)(
          (0, _utils$1.assertValueType)('array'),
          (0, _utils$1.assertEach)(
            (0, _utils$1.assertNodeType)('JSXAttribute', 'JSXSpreadAttribute'),
          ),
        ),
      },
      typeParameters: {
        validate: (0, _utils$1.assertNodeType)(
          'TypeParameterInstantiation',
          'TSTypeParameterInstantiation',
        ),
        optional: true,
      },
    },
  });
  (0, _utils$1.default)('JSXSpreadAttribute', {
    visitor: ['argument'],
    aliases: ['JSX'],
    fields: {
      argument: {
        validate: (0, _utils$1.assertNodeType)('Expression'),
      },
    },
  });
  (0, _utils$1.default)('JSXText', {
    aliases: ['JSX', 'Immutable'],
    builder: ['value'],
    fields: {
      value: {
        validate: (0, _utils$1.assertValueType)('string'),
      },
    },
  });
  (0, _utils$1.default)('JSXFragment', {
    builder: ['openingFragment', 'closingFragment', 'children'],
    visitor: ['openingFragment', 'children', 'closingFragment'],
    aliases: ['JSX', 'Immutable', 'Expression'],
    fields: {
      openingFragment: {
        validate: (0, _utils$1.assertNodeType)('JSXOpeningFragment'),
      },
      closingFragment: {
        validate: (0, _utils$1.assertNodeType)('JSXClosingFragment'),
      },
      children: {
        validate: (0, _utils$1.chain)(
          (0, _utils$1.assertValueType)('array'),
          (0, _utils$1.assertEach)(
            (0, _utils$1.assertNodeType)(
              'JSXText',
              'JSXExpressionContainer',
              'JSXSpreadChild',
              'JSXElement',
              'JSXFragment',
            ),
          ),
        ),
      },
    },
  });
  (0, _utils$1.default)('JSXOpeningFragment', {
    aliases: ['JSX', 'Immutable'],
  });
  (0, _utils$1.default)('JSXClosingFragment', {
    aliases: ['JSX', 'Immutable'],
  });

  var placeholders$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
    const PLACEHOLDERS = [
      'Identifier',
      'StringLiteral',
      'Expression',
      'Statement',
      'Declaration',
      'BlockStatement',
      'ClassBody',
      'Pattern',
    ];
    exports.PLACEHOLDERS = PLACEHOLDERS;
    const PLACEHOLDERS_ALIAS = {
      Declaration: ['Statement'],
      Pattern: ['PatternLike', 'LVal'],
    };
    exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;

    for (const type of PLACEHOLDERS) {
      const alias = utils.ALIAS_KEYS[type];
      if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
    }

    const PLACEHOLDERS_FLIPPED_ALIAS = {};
    exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }

        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  });

  var _utils$2 = _interopRequireWildcard$2(utils);

  function _getRequireWildcardCache$2() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$2 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$2(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$2();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  {
    (0, _utils$2.default)('Noop', {
      visitor: [],
    });
  }
  (0, _utils$2.default)('Placeholder', {
    visitor: [],
    builder: ['expectedNode', 'name'],
    fields: {
      name: {
        validate: (0, _utils$2.assertNodeType)('Identifier'),
      },
      expectedNode: {
        validate: (0, _utils$2.assertOneOf)(...placeholders$1.PLACEHOLDERS),
      },
    },
  });
  (0, _utils$2.default)('V8IntrinsicIdentifier', {
    builder: ['name'],
    fields: {
      name: {
        validate: (0, _utils$2.assertValueType)('string'),
      },
    },
  });

  var _utils$3 = _interopRequireWildcard$3(utils);

  function _getRequireWildcardCache$3() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$3 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$3(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$3();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  (0, _utils$3.default)('ArgumentPlaceholder', {});
  (0, _utils$3.default)('BindExpression', {
    visitor: ['object', 'callee'],
    aliases: ['Expression'],
    fields: !browser$1.env.BABEL_TYPES_8_BREAKING
      ? {
          object: {
            validate: Object.assign(() => {}, {
              oneOfNodeTypes: ['Expression'],
            }),
          },
          callee: {
            validate: Object.assign(() => {}, {
              oneOfNodeTypes: ['Expression'],
            }),
          },
        }
      : {
          object: {
            validate: (0, _utils$3.assertNodeType)('Expression'),
          },
          callee: {
            validate: (0, _utils$3.assertNodeType)('Expression'),
          },
        },
  });
  (0, _utils$3.default)('ClassProperty', {
    visitor: ['key', 'value', 'typeAnnotation', 'decorators'],
    builder: [
      'key',
      'value',
      'typeAnnotation',
      'decorators',
      'computed',
      'static',
    ],
    aliases: ['Property'],
    fields: Object.assign({}, core.classMethodOrPropertyCommon, {
      value: {
        validate: (0, _utils$3.assertNodeType)('Expression'),
        optional: true,
      },
      definite: {
        validate: (0, _utils$3.assertValueType)('boolean'),
        optional: true,
      },
      typeAnnotation: {
        validate: (0, _utils$3.assertNodeType)(
          'TypeAnnotation',
          'TSTypeAnnotation',
          'Noop',
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils$3.chain)(
          (0, _utils$3.assertValueType)('array'),
          (0, _utils$3.assertEach)((0, _utils$3.assertNodeType)('Decorator')),
        ),
        optional: true,
      },
      readonly: {
        validate: (0, _utils$3.assertValueType)('boolean'),
        optional: true,
      },
      declare: {
        validate: (0, _utils$3.assertValueType)('boolean'),
        optional: true,
      },
    }),
  });
  (0, _utils$3.default)('PipelineTopicExpression', {
    builder: ['expression'],
    visitor: ['expression'],
    fields: {
      expression: {
        validate: (0, _utils$3.assertNodeType)('Expression'),
      },
    },
  });
  (0, _utils$3.default)('PipelineBareFunction', {
    builder: ['callee'],
    visitor: ['callee'],
    fields: {
      callee: {
        validate: (0, _utils$3.assertNodeType)('Expression'),
      },
    },
  });
  (0, _utils$3.default)('PipelinePrimaryTopicReference', {
    aliases: ['Expression'],
  });
  (0, _utils$3.default)('ClassPrivateProperty', {
    visitor: ['key', 'value', 'decorators'],
    builder: ['key', 'value', 'decorators', 'static'],
    aliases: ['Property', 'Private'],
    fields: {
      key: {
        validate: (0, _utils$3.assertNodeType)('PrivateName'),
      },
      value: {
        validate: (0, _utils$3.assertNodeType)('Expression'),
        optional: true,
      },
      typeAnnotation: {
        validate: (0, _utils$3.assertNodeType)(
          'TypeAnnotation',
          'TSTypeAnnotation',
          'Noop',
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils$3.chain)(
          (0, _utils$3.assertValueType)('array'),
          (0, _utils$3.assertEach)((0, _utils$3.assertNodeType)('Decorator')),
        ),
        optional: true,
      },
    },
  });
  (0, _utils$3.default)('ClassPrivateMethod', {
    builder: ['kind', 'key', 'params', 'body', 'static'],
    visitor: [
      'key',
      'params',
      'body',
      'decorators',
      'returnType',
      'typeParameters',
    ],
    aliases: [
      'Function',
      'Scopable',
      'BlockParent',
      'FunctionParent',
      'Method',
      'Private',
    ],
    fields: Object.assign(
      {},
      core.classMethodOrDeclareMethodCommon,
      core.functionTypeAnnotationCommon,
      {
        key: {
          validate: (0, _utils$3.assertNodeType)('PrivateName'),
        },
        body: {
          validate: (0, _utils$3.assertNodeType)('BlockStatement'),
        },
      },
    ),
  });
  (0, _utils$3.default)('ImportAttribute', {
    visitor: ['key', 'value'],
    fields: {
      key: {
        validate: (0, _utils$3.assertNodeType)('Identifier', 'StringLiteral'),
      },
      value: {
        validate: (0, _utils$3.assertNodeType)('StringLiteral'),
      },
    },
  });
  (0, _utils$3.default)('Decorator', {
    visitor: ['expression'],
    fields: {
      expression: {
        validate: (0, _utils$3.assertNodeType)('Expression'),
      },
    },
  });
  (0, _utils$3.default)('DoExpression', {
    visitor: ['body'],
    aliases: ['Expression'],
    fields: {
      body: {
        validate: (0, _utils$3.assertNodeType)('BlockStatement'),
      },
    },
  });
  (0, _utils$3.default)('ExportDefaultSpecifier', {
    visitor: ['exported'],
    aliases: ['ModuleSpecifier'],
    fields: {
      exported: {
        validate: (0, _utils$3.assertNodeType)('Identifier'),
      },
    },
  });
  (0, _utils$3.default)('PrivateName', {
    visitor: ['id'],
    aliases: ['Private'],
    fields: {
      id: {
        validate: (0, _utils$3.assertNodeType)('Identifier'),
      },
    },
  });
  (0, _utils$3.default)('RecordExpression', {
    visitor: ['properties'],
    aliases: ['Expression'],
    fields: {
      properties: {
        validate: (0, _utils$3.chain)(
          (0, _utils$3.assertValueType)('array'),
          (0, _utils$3.assertEach)(
            (0, _utils$3.assertNodeType)('ObjectProperty', 'SpreadElement'),
          ),
        ),
      },
    },
  });
  (0, _utils$3.default)('TupleExpression', {
    fields: {
      elements: {
        validate: (0, _utils$3.chain)(
          (0, _utils$3.assertValueType)('array'),
          (0, _utils$3.assertEach)(
            (0, _utils$3.assertNodeType)('Expression', 'SpreadElement'),
          ),
        ),
        default: [],
      },
    },
    visitor: ['elements'],
    aliases: ['Expression'],
  });
  (0, _utils$3.default)('DecimalLiteral', {
    builder: ['value'],
    fields: {
      value: {
        validate: (0, _utils$3.assertValueType)('string'),
      },
    },
    aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
  });
  (0, _utils$3.default)('StaticBlock', {
    visitor: ['body'],
    fields: {
      body: {
        validate: (0, _utils$3.chain)(
          (0, _utils$3.assertValueType)('array'),
          (0, _utils$3.assertEach)((0, _utils$3.assertNodeType)('Statement')),
        ),
      },
    },
    aliases: ['Scopable', 'BlockParent'],
  });
  (0, _utils$3.default)('ModuleExpression', {
    visitor: ['body'],
    fields: {
      body: {
        validate: (0, _utils$3.assertNodeType)('Program'),
      },
    },
    aliases: ['Expression'],
  });

  var _utils$4 = _interopRequireWildcard$4(utils);

  function _getRequireWildcardCache$4() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$4 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$4(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$4();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  const bool = (0, _utils$4.assertValueType)('boolean');
  const tSFunctionTypeAnnotationCommon = {
    returnType: {
      validate: (0, _utils$4.assertNodeType)('TSTypeAnnotation', 'Noop'),
      optional: true,
    },
    typeParameters: {
      validate: (0, _utils$4.assertNodeType)(
        'TSTypeParameterDeclaration',
        'Noop',
      ),
      optional: true,
    },
  };
  (0, _utils$4.default)('TSParameterProperty', {
    aliases: ['LVal'],
    visitor: ['parameter'],
    fields: {
      accessibility: {
        validate: (0, _utils$4.assertOneOf)('public', 'private', 'protected'),
        optional: true,
      },
      readonly: {
        validate: (0, _utils$4.assertValueType)('boolean'),
        optional: true,
      },
      parameter: {
        validate: (0, _utils$4.assertNodeType)(
          'Identifier',
          'AssignmentPattern',
        ),
      },
    },
  });
  (0, _utils$4.default)('TSDeclareFunction', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'typeParameters', 'params', 'returnType'],
    fields: Object.assign(
      {},
      core.functionDeclarationCommon,
      tSFunctionTypeAnnotationCommon,
    ),
  });
  (0, _utils$4.default)('TSDeclareMethod', {
    visitor: ['decorators', 'key', 'typeParameters', 'params', 'returnType'],
    fields: Object.assign(
      {},
      core.classMethodOrDeclareMethodCommon,
      tSFunctionTypeAnnotationCommon,
    ),
  });
  (0, _utils$4.default)('TSQualifiedName', {
    aliases: ['TSEntityName'],
    visitor: ['left', 'right'],
    fields: {
      left: (0, _utils$4.validateType)('TSEntityName'),
      right: (0, _utils$4.validateType)('Identifier'),
    },
  });
  const signatureDeclarationCommon = {
    typeParameters: (0, _utils$4.validateOptionalType)(
      'TSTypeParameterDeclaration',
    ),
    parameters: (0, _utils$4.validateArrayOfType)([
      'Identifier',
      'RestElement',
    ]),
    typeAnnotation: (0, _utils$4.validateOptionalType)('TSTypeAnnotation'),
  };
  const callConstructSignatureDeclaration = {
    aliases: ['TSTypeElement'],
    visitor: ['typeParameters', 'parameters', 'typeAnnotation'],
    fields: signatureDeclarationCommon,
  };
  (0, _utils$4.default)(
    'TSCallSignatureDeclaration',
    callConstructSignatureDeclaration,
  );
  (0, _utils$4.default)(
    'TSConstructSignatureDeclaration',
    callConstructSignatureDeclaration,
  );
  const namedTypeElementCommon = {
    key: (0, _utils$4.validateType)('Expression'),
    computed: (0, _utils$4.validate)(bool),
    optional: (0, _utils$4.validateOptional)(bool),
  };
  (0, _utils$4.default)('TSPropertySignature', {
    aliases: ['TSTypeElement'],
    visitor: ['key', 'typeAnnotation', 'initializer'],
    fields: Object.assign({}, namedTypeElementCommon, {
      readonly: (0, _utils$4.validateOptional)(bool),
      typeAnnotation: (0, _utils$4.validateOptionalType)('TSTypeAnnotation'),
      initializer: (0, _utils$4.validateOptionalType)('Expression'),
    }),
  });
  (0, _utils$4.default)('TSMethodSignature', {
    aliases: ['TSTypeElement'],
    visitor: ['key', 'typeParameters', 'parameters', 'typeAnnotation'],
    fields: Object.assign(
      {},
      signatureDeclarationCommon,
      namedTypeElementCommon,
    ),
  });
  (0, _utils$4.default)('TSIndexSignature', {
    aliases: ['TSTypeElement'],
    visitor: ['parameters', 'typeAnnotation'],
    fields: {
      readonly: (0, _utils$4.validateOptional)(bool),
      parameters: (0, _utils$4.validateArrayOfType)('Identifier'),
      typeAnnotation: (0, _utils$4.validateOptionalType)('TSTypeAnnotation'),
    },
  });
  const tsKeywordTypes = [
    'TSAnyKeyword',
    'TSBooleanKeyword',
    'TSBigIntKeyword',
    'TSIntrinsicKeyword',
    'TSNeverKeyword',
    'TSNullKeyword',
    'TSNumberKeyword',
    'TSObjectKeyword',
    'TSStringKeyword',
    'TSSymbolKeyword',
    'TSUndefinedKeyword',
    'TSUnknownKeyword',
    'TSVoidKeyword',
  ];

  for (const type of tsKeywordTypes) {
    (0, _utils$4.default)(type, {
      aliases: ['TSType', 'TSBaseType'],
      visitor: [],
      fields: {},
    });
  }

  (0, _utils$4.default)('TSThisType', {
    aliases: ['TSType', 'TSBaseType'],
    visitor: [],
    fields: {},
  });
  const fnOrCtrBase = {
    aliases: ['TSType'],
    visitor: ['typeParameters', 'parameters', 'typeAnnotation'],
  };
  (0, _utils$4.default)(
    'TSFunctionType',
    Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon,
    }),
  );
  (0, _utils$4.default)(
    'TSConstructorType',
    Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon, {
        abstract: (0, _utils$4.validateOptional)(bool),
      }),
    }),
  );
  (0, _utils$4.default)('TSTypeReference', {
    aliases: ['TSType'],
    visitor: ['typeName', 'typeParameters'],
    fields: {
      typeName: (0, _utils$4.validateType)('TSEntityName'),
      typeParameters: (0, _utils$4.validateOptionalType)(
        'TSTypeParameterInstantiation',
      ),
    },
  });
  (0, _utils$4.default)('TSTypePredicate', {
    aliases: ['TSType'],
    visitor: ['parameterName', 'typeAnnotation'],
    builder: ['parameterName', 'typeAnnotation', 'asserts'],
    fields: {
      parameterName: (0, _utils$4.validateType)(['Identifier', 'TSThisType']),
      typeAnnotation: (0, _utils$4.validateOptionalType)('TSTypeAnnotation'),
      asserts: (0, _utils$4.validateOptional)(bool),
    },
  });
  (0, _utils$4.default)('TSTypeQuery', {
    aliases: ['TSType'],
    visitor: ['exprName'],
    fields: {
      exprName: (0, _utils$4.validateType)(['TSEntityName', 'TSImportType']),
    },
  });
  (0, _utils$4.default)('TSTypeLiteral', {
    aliases: ['TSType'],
    visitor: ['members'],
    fields: {
      members: (0, _utils$4.validateArrayOfType)('TSTypeElement'),
    },
  });
  (0, _utils$4.default)('TSArrayType', {
    aliases: ['TSType'],
    visitor: ['elementType'],
    fields: {
      elementType: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSTupleType', {
    aliases: ['TSType'],
    visitor: ['elementTypes'],
    fields: {
      elementTypes: (0, _utils$4.validateArrayOfType)([
        'TSType',
        'TSNamedTupleMember',
      ]),
    },
  });
  (0, _utils$4.default)('TSOptionalType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
      typeAnnotation: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSRestType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
      typeAnnotation: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSNamedTupleMember', {
    visitor: ['label', 'elementType'],
    builder: ['label', 'elementType', 'optional'],
    fields: {
      label: (0, _utils$4.validateType)('Identifier'),
      optional: {
        validate: bool,
        default: false,
      },
      elementType: (0, _utils$4.validateType)('TSType'),
    },
  });
  const unionOrIntersection = {
    aliases: ['TSType'],
    visitor: ['types'],
    fields: {
      types: (0, _utils$4.validateArrayOfType)('TSType'),
    },
  };
  (0, _utils$4.default)('TSUnionType', unionOrIntersection);
  (0, _utils$4.default)('TSIntersectionType', unionOrIntersection);
  (0, _utils$4.default)('TSConditionalType', {
    aliases: ['TSType'],
    visitor: ['checkType', 'extendsType', 'trueType', 'falseType'],
    fields: {
      checkType: (0, _utils$4.validateType)('TSType'),
      extendsType: (0, _utils$4.validateType)('TSType'),
      trueType: (0, _utils$4.validateType)('TSType'),
      falseType: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSInferType', {
    aliases: ['TSType'],
    visitor: ['typeParameter'],
    fields: {
      typeParameter: (0, _utils$4.validateType)('TSTypeParameter'),
    },
  });
  (0, _utils$4.default)('TSParenthesizedType', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
      typeAnnotation: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSTypeOperator', {
    aliases: ['TSType'],
    visitor: ['typeAnnotation'],
    fields: {
      operator: (0, _utils$4.validate)((0, _utils$4.assertValueType)('string')),
      typeAnnotation: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSIndexedAccessType', {
    aliases: ['TSType'],
    visitor: ['objectType', 'indexType'],
    fields: {
      objectType: (0, _utils$4.validateType)('TSType'),
      indexType: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSMappedType', {
    aliases: ['TSType'],
    visitor: ['typeParameter', 'typeAnnotation', 'nameType'],
    fields: {
      readonly: (0, _utils$4.validateOptional)(bool),
      typeParameter: (0, _utils$4.validateType)('TSTypeParameter'),
      optional: (0, _utils$4.validateOptional)(bool),
      typeAnnotation: (0, _utils$4.validateOptionalType)('TSType'),
      nameType: (0, _utils$4.validateOptionalType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSLiteralType', {
    aliases: ['TSType', 'TSBaseType'],
    visitor: ['literal'],
    fields: {
      literal: (0, _utils$4.validateType)([
        'NumericLiteral',
        'StringLiteral',
        'BooleanLiteral',
        'BigIntLiteral',
      ]),
    },
  });
  (0, _utils$4.default)('TSExpressionWithTypeArguments', {
    aliases: ['TSType'],
    visitor: ['expression', 'typeParameters'],
    fields: {
      expression: (0, _utils$4.validateType)('TSEntityName'),
      typeParameters: (0, _utils$4.validateOptionalType)(
        'TSTypeParameterInstantiation',
      ),
    },
  });
  (0, _utils$4.default)('TSInterfaceDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'typeParameters', 'extends', 'body'],
    fields: {
      declare: (0, _utils$4.validateOptional)(bool),
      id: (0, _utils$4.validateType)('Identifier'),
      typeParameters: (0, _utils$4.validateOptionalType)(
        'TSTypeParameterDeclaration',
      ),
      extends: (0, _utils$4.validateOptional)(
        (0, _utils$4.arrayOfType)('TSExpressionWithTypeArguments'),
      ),
      body: (0, _utils$4.validateType)('TSInterfaceBody'),
    },
  });
  (0, _utils$4.default)('TSInterfaceBody', {
    visitor: ['body'],
    fields: {
      body: (0, _utils$4.validateArrayOfType)('TSTypeElement'),
    },
  });
  (0, _utils$4.default)('TSTypeAliasDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'typeParameters', 'typeAnnotation'],
    fields: {
      declare: (0, _utils$4.validateOptional)(bool),
      id: (0, _utils$4.validateType)('Identifier'),
      typeParameters: (0, _utils$4.validateOptionalType)(
        'TSTypeParameterDeclaration',
      ),
      typeAnnotation: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSAsExpression', {
    aliases: ['Expression'],
    visitor: ['expression', 'typeAnnotation'],
    fields: {
      expression: (0, _utils$4.validateType)('Expression'),
      typeAnnotation: (0, _utils$4.validateType)('TSType'),
    },
  });
  (0, _utils$4.default)('TSTypeAssertion', {
    aliases: ['Expression'],
    visitor: ['typeAnnotation', 'expression'],
    fields: {
      typeAnnotation: (0, _utils$4.validateType)('TSType'),
      expression: (0, _utils$4.validateType)('Expression'),
    },
  });
  (0, _utils$4.default)('TSEnumDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'members'],
    fields: {
      declare: (0, _utils$4.validateOptional)(bool),
      const: (0, _utils$4.validateOptional)(bool),
      id: (0, _utils$4.validateType)('Identifier'),
      members: (0, _utils$4.validateArrayOfType)('TSEnumMember'),
      initializer: (0, _utils$4.validateOptionalType)('Expression'),
    },
  });
  (0, _utils$4.default)('TSEnumMember', {
    visitor: ['id', 'initializer'],
    fields: {
      id: (0, _utils$4.validateType)(['Identifier', 'StringLiteral']),
      initializer: (0, _utils$4.validateOptionalType)('Expression'),
    },
  });
  (0, _utils$4.default)('TSModuleDeclaration', {
    aliases: ['Statement', 'Declaration'],
    visitor: ['id', 'body'],
    fields: {
      declare: (0, _utils$4.validateOptional)(bool),
      global: (0, _utils$4.validateOptional)(bool),
      id: (0, _utils$4.validateType)(['Identifier', 'StringLiteral']),
      body: (0, _utils$4.validateType)([
        'TSModuleBlock',
        'TSModuleDeclaration',
      ]),
    },
  });
  (0, _utils$4.default)('TSModuleBlock', {
    aliases: ['Scopable', 'Block', 'BlockParent'],
    visitor: ['body'],
    fields: {
      body: (0, _utils$4.validateArrayOfType)('Statement'),
    },
  });
  (0, _utils$4.default)('TSImportType', {
    aliases: ['TSType'],
    visitor: ['argument', 'qualifier', 'typeParameters'],
    fields: {
      argument: (0, _utils$4.validateType)('StringLiteral'),
      qualifier: (0, _utils$4.validateOptionalType)('TSEntityName'),
      typeParameters: (0, _utils$4.validateOptionalType)(
        'TSTypeParameterInstantiation',
      ),
    },
  });
  (0, _utils$4.default)('TSImportEqualsDeclaration', {
    aliases: ['Statement'],
    visitor: ['id', 'moduleReference'],
    fields: {
      isExport: (0, _utils$4.validate)(bool),
      id: (0, _utils$4.validateType)('Identifier'),
      moduleReference: (0, _utils$4.validateType)([
        'TSEntityName',
        'TSExternalModuleReference',
      ]),
    },
  });
  (0, _utils$4.default)('TSExternalModuleReference', {
    visitor: ['expression'],
    fields: {
      expression: (0, _utils$4.validateType)('StringLiteral'),
    },
  });
  (0, _utils$4.default)('TSNonNullExpression', {
    aliases: ['Expression'],
    visitor: ['expression'],
    fields: {
      expression: (0, _utils$4.validateType)('Expression'),
    },
  });
  (0, _utils$4.default)('TSExportAssignment', {
    aliases: ['Statement'],
    visitor: ['expression'],
    fields: {
      expression: (0, _utils$4.validateType)('Expression'),
    },
  });
  (0, _utils$4.default)('TSNamespaceExportDeclaration', {
    aliases: ['Statement'],
    visitor: ['id'],
    fields: {
      id: (0, _utils$4.validateType)('Identifier'),
    },
  });
  (0, _utils$4.default)('TSTypeAnnotation', {
    visitor: ['typeAnnotation'],
    fields: {
      typeAnnotation: {
        validate: (0, _utils$4.assertNodeType)('TSType'),
      },
    },
  });
  (0, _utils$4.default)('TSTypeParameterInstantiation', {
    visitor: ['params'],
    fields: {
      params: {
        validate: (0, _utils$4.chain)(
          (0, _utils$4.assertValueType)('array'),
          (0, _utils$4.assertEach)((0, _utils$4.assertNodeType)('TSType')),
        ),
      },
    },
  });
  (0, _utils$4.default)('TSTypeParameterDeclaration', {
    visitor: ['params'],
    fields: {
      params: {
        validate: (0, _utils$4.chain)(
          (0, _utils$4.assertValueType)('array'),
          (0, _utils$4.assertEach)(
            (0, _utils$4.assertNodeType)('TSTypeParameter'),
          ),
        ),
      },
    },
  });
  (0, _utils$4.default)('TSTypeParameter', {
    builder: ['constraint', 'default', 'name'],
    visitor: ['constraint', 'default'],
    fields: {
      name: {
        validate: (0, _utils$4.assertValueType)('string'),
      },
      constraint: {
        validate: (0, _utils$4.assertNodeType)('TSType'),
        optional: true,
      },
      default: {
        validate: (0, _utils$4.assertNodeType)('TSType'),
        optional: true,
      },
    },
  });

  let fastProto = null; // Creates an object with permanently fast properties in V8. See Toon Verwaest's
  // post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
  // for more details. Use %HasFastProperties(object) and the Node.js flag
  // --allow-natives-syntax to check whether an object has fast properties.

  function FastObject(o) {
    // A prototype object will have "fast properties" enabled once it is checked
    // against the inline property cache of a function, e.g. fastProto.property:
    // https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
    if (fastProto !== null && typeof fastProto.property) {
      const result = fastProto;
      fastProto = FastObject.prototype = null;
      return result;
    }

    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject();
  } // Initialize the inline property cache of FastObject

  FastObject();

  var toFastProperties = function toFastproperties(o) {
    return FastObject(o);
  };

  var definitions = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'VISITOR_KEYS', {
      enumerable: true,
      get: function () {
        return utils.VISITOR_KEYS;
      },
    });
    Object.defineProperty(exports, 'ALIAS_KEYS', {
      enumerable: true,
      get: function () {
        return utils.ALIAS_KEYS;
      },
    });
    Object.defineProperty(exports, 'FLIPPED_ALIAS_KEYS', {
      enumerable: true,
      get: function () {
        return utils.FLIPPED_ALIAS_KEYS;
      },
    });
    Object.defineProperty(exports, 'NODE_FIELDS', {
      enumerable: true,
      get: function () {
        return utils.NODE_FIELDS;
      },
    });
    Object.defineProperty(exports, 'BUILDER_KEYS', {
      enumerable: true,
      get: function () {
        return utils.BUILDER_KEYS;
      },
    });
    Object.defineProperty(exports, 'DEPRECATED_KEYS', {
      enumerable: true,
      get: function () {
        return utils.DEPRECATED_KEYS;
      },
    });
    Object.defineProperty(exports, 'NODE_PARENT_VALIDATIONS', {
      enumerable: true,
      get: function () {
        return utils.NODE_PARENT_VALIDATIONS;
      },
    });
    Object.defineProperty(exports, 'PLACEHOLDERS', {
      enumerable: true,
      get: function () {
        return placeholders$1.PLACEHOLDERS;
      },
    });
    Object.defineProperty(exports, 'PLACEHOLDERS_ALIAS', {
      enumerable: true,
      get: function () {
        return placeholders$1.PLACEHOLDERS_ALIAS;
      },
    });
    Object.defineProperty(exports, 'PLACEHOLDERS_FLIPPED_ALIAS', {
      enumerable: true,
      get: function () {
        return placeholders$1.PLACEHOLDERS_FLIPPED_ALIAS;
      },
    });
    exports.TYPES = void 0;
    toFastProperties(utils.VISITOR_KEYS);
    toFastProperties(utils.ALIAS_KEYS);
    toFastProperties(utils.FLIPPED_ALIAS_KEYS);
    toFastProperties(utils.NODE_FIELDS);
    toFastProperties(utils.BUILDER_KEYS);
    toFastProperties(utils.DEPRECATED_KEYS);
    toFastProperties(placeholders$1.PLACEHOLDERS_ALIAS);
    toFastProperties(placeholders$1.PLACEHOLDERS_FLIPPED_ALIAS);
    const TYPES = Object.keys(utils.VISITOR_KEYS)
      .concat(Object.keys(utils.FLIPPED_ALIAS_KEYS))
      .concat(Object.keys(utils.DEPRECATED_KEYS));
    exports.TYPES = TYPES;
  });

  var _default$9 = builder;

  var _validate = _interopRequireDefault$3(validate_1);

  function _interopRequireDefault$3(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function builder(type, ...args) {
    const keys = definitions.BUILDER_KEYS[type];
    const countArgs = args.length;

    if (countArgs > keys.length) {
      throw new Error(
        `${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`,
      );
    }

    const node = {
      type,
    };
    let i = 0;
    keys.forEach((key) => {
      const field = definitions.NODE_FIELDS[type][key];
      let arg;
      if (i < countArgs) arg = args[i];

      if (arg === undefined) {
        arg = Array.isArray(field.default) ? [] : field.default;
      }

      node[key] = arg;
      i++;
    });

    for (const key of Object.keys(node)) {
      (0, _validate.default)(node, key, node[key]);
    }

    return node;
  }

  var builder_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$9,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var generated$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.arrayExpression = arrayExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.binaryExpression = binaryExpression;
    exports.interpreterDirective = interpreterDirective;
    exports.directive = directive;
    exports.directiveLiteral = directiveLiteral;
    exports.blockStatement = blockStatement;
    exports.breakStatement = breakStatement;
    exports.callExpression = callExpression;
    exports.catchClause = catchClause;
    exports.conditionalExpression = conditionalExpression;
    exports.continueStatement = continueStatement;
    exports.debuggerStatement = debuggerStatement;
    exports.doWhileStatement = doWhileStatement;
    exports.emptyStatement = emptyStatement;
    exports.expressionStatement = expressionStatement;
    exports.file = file;
    exports.forInStatement = forInStatement;
    exports.forStatement = forStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.functionExpression = functionExpression;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.labeledStatement = labeledStatement;
    exports.stringLiteral = stringLiteral;
    exports.numericLiteral = numericLiteral;
    exports.nullLiteral = nullLiteral;
    exports.booleanLiteral = booleanLiteral;
    exports.regExpLiteral = regExpLiteral;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.newExpression = newExpression;
    exports.program = program;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectProperty = objectProperty;
    exports.restElement = restElement;
    exports.returnStatement = returnStatement;
    exports.sequenceExpression = sequenceExpression;
    exports.parenthesizedExpression = parenthesizedExpression;
    exports.switchCase = switchCase;
    exports.switchStatement = switchStatement;
    exports.thisExpression = thisExpression;
    exports.throwStatement = throwStatement;
    exports.tryStatement = tryStatement;
    exports.unaryExpression = unaryExpression;
    exports.updateExpression = updateExpression;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
    exports.whileStatement = whileStatement;
    exports.withStatement = withStatement;
    exports.assignmentPattern = assignmentPattern;
    exports.arrayPattern = arrayPattern;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.classBody = classBody;
    exports.classExpression = classExpression;
    exports.classDeclaration = classDeclaration;
    exports.exportAllDeclaration = exportAllDeclaration;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.exportNamedDeclaration = exportNamedDeclaration;
    exports.exportSpecifier = exportSpecifier;
    exports.forOfStatement = forOfStatement;
    exports.importDeclaration = importDeclaration;
    exports.importDefaultSpecifier = importDefaultSpecifier;
    exports.importNamespaceSpecifier = importNamespaceSpecifier;
    exports.importSpecifier = importSpecifier;
    exports.metaProperty = metaProperty;
    exports.classMethod = classMethod;
    exports.objectPattern = objectPattern;
    exports.spreadElement = spreadElement;
    exports.super = _super;
    exports.taggedTemplateExpression = taggedTemplateExpression;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.yieldExpression = yieldExpression;
    exports.awaitExpression = awaitExpression;
    exports.import = _import;
    exports.bigIntLiteral = bigIntLiteral;
    exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports.optionalMemberExpression = optionalMemberExpression;
    exports.optionalCallExpression = optionalCallExpression;
    exports.anyTypeAnnotation = anyTypeAnnotation;
    exports.arrayTypeAnnotation = arrayTypeAnnotation;
    exports.booleanTypeAnnotation = booleanTypeAnnotation;
    exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports.classImplements = classImplements;
    exports.declareClass = declareClass;
    exports.declareFunction = declareFunction;
    exports.declareInterface = declareInterface;
    exports.declareModule = declareModule;
    exports.declareModuleExports = declareModuleExports;
    exports.declareTypeAlias = declareTypeAlias;
    exports.declareOpaqueType = declareOpaqueType;
    exports.declareVariable = declareVariable;
    exports.declareExportDeclaration = declareExportDeclaration;
    exports.declareExportAllDeclaration = declareExportAllDeclaration;
    exports.declaredPredicate = declaredPredicate;
    exports.existsTypeAnnotation = existsTypeAnnotation;
    exports.functionTypeAnnotation = functionTypeAnnotation;
    exports.functionTypeParam = functionTypeParam;
    exports.genericTypeAnnotation = genericTypeAnnotation;
    exports.inferredPredicate = inferredPredicate;
    exports.interfaceExtends = interfaceExtends;
    exports.interfaceDeclaration = interfaceDeclaration;
    exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports.mixedTypeAnnotation = mixedTypeAnnotation;
    exports.emptyTypeAnnotation = emptyTypeAnnotation;
    exports.nullableTypeAnnotation = nullableTypeAnnotation;
    exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports.numberTypeAnnotation = numberTypeAnnotation;
    exports.objectTypeAnnotation = objectTypeAnnotation;
    exports.objectTypeInternalSlot = objectTypeInternalSlot;
    exports.objectTypeCallProperty = objectTypeCallProperty;
    exports.objectTypeIndexer = objectTypeIndexer;
    exports.objectTypeProperty = objectTypeProperty;
    exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports.opaqueType = opaqueType;
    exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports.stringTypeAnnotation = stringTypeAnnotation;
    exports.symbolTypeAnnotation = symbolTypeAnnotation;
    exports.thisTypeAnnotation = thisTypeAnnotation;
    exports.tupleTypeAnnotation = tupleTypeAnnotation;
    exports.typeofTypeAnnotation = typeofTypeAnnotation;
    exports.typeAlias = typeAlias;
    exports.typeAnnotation = typeAnnotation;
    exports.typeCastExpression = typeCastExpression;
    exports.typeParameter = typeParameter;
    exports.typeParameterDeclaration = typeParameterDeclaration;
    exports.typeParameterInstantiation = typeParameterInstantiation;
    exports.unionTypeAnnotation = unionTypeAnnotation;
    exports.variance = variance;
    exports.voidTypeAnnotation = voidTypeAnnotation;
    exports.enumDeclaration = enumDeclaration;
    exports.enumBooleanBody = enumBooleanBody;
    exports.enumNumberBody = enumNumberBody;
    exports.enumStringBody = enumStringBody;
    exports.enumSymbolBody = enumSymbolBody;
    exports.enumBooleanMember = enumBooleanMember;
    exports.enumNumberMember = enumNumberMember;
    exports.enumStringMember = enumStringMember;
    exports.enumDefaultedMember = enumDefaultedMember;
    exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
    exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
    exports.jSXElement = exports.jsxElement = jsxElement;
    exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
    exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
    exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
    exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
    exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
    exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
    exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
    exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
    exports.jSXText = exports.jsxText = jsxText;
    exports.jSXFragment = exports.jsxFragment = jsxFragment;
    exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
    exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
    exports.noop = noop;
    exports.placeholder = placeholder;
    exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports.argumentPlaceholder = argumentPlaceholder;
    exports.bindExpression = bindExpression;
    exports.classProperty = classProperty;
    exports.pipelineTopicExpression = pipelineTopicExpression;
    exports.pipelineBareFunction = pipelineBareFunction;
    exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports.classPrivateProperty = classPrivateProperty;
    exports.classPrivateMethod = classPrivateMethod;
    exports.importAttribute = importAttribute;
    exports.decorator = decorator;
    exports.doExpression = doExpression;
    exports.exportDefaultSpecifier = exportDefaultSpecifier;
    exports.privateName = privateName;
    exports.recordExpression = recordExpression;
    exports.tupleExpression = tupleExpression;
    exports.decimalLiteral = decimalLiteral;
    exports.staticBlock = staticBlock;
    exports.moduleExpression = moduleExpression;
    exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
    exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
    exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
    exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
    exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
    exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
    exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
    exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
    exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
    exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
    exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
    exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
    exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
    exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
    exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
    exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
    exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
    exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
    exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
    exports.tSThisType = exports.tsThisType = tsThisType;
    exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
    exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
    exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
    exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
    exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
    exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
    exports.tSArrayType = exports.tsArrayType = tsArrayType;
    exports.tSTupleType = exports.tsTupleType = tsTupleType;
    exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
    exports.tSRestType = exports.tsRestType = tsRestType;
    exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
    exports.tSUnionType = exports.tsUnionType = tsUnionType;
    exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
    exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
    exports.tSInferType = exports.tsInferType = tsInferType;
    exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
    exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
    exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
    exports.tSMappedType = exports.tsMappedType = tsMappedType;
    exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
    exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
    exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
    exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
    exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
    exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
    exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
    exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
    exports.tSImportType = exports.tsImportType = tsImportType;
    exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
    exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
    exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
    exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
    exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
    exports.numberLiteral = NumberLiteral;
    exports.regexLiteral = RegexLiteral;
    exports.restProperty = RestProperty;
    exports.spreadProperty = SpreadProperty;

    var _builder = _interopRequireDefault(builder_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    function arrayExpression(elements) {
      return (0, _builder.default)('ArrayExpression', ...arguments);
    }

    function assignmentExpression(operator, left, right) {
      return (0, _builder.default)('AssignmentExpression', ...arguments);
    }

    function binaryExpression(operator, left, right) {
      return (0, _builder.default)('BinaryExpression', ...arguments);
    }

    function interpreterDirective(value) {
      return (0, _builder.default)('InterpreterDirective', ...arguments);
    }

    function directive(value) {
      return (0, _builder.default)('Directive', ...arguments);
    }

    function directiveLiteral(value) {
      return (0, _builder.default)('DirectiveLiteral', ...arguments);
    }

    function blockStatement(body, directives) {
      return (0, _builder.default)('BlockStatement', ...arguments);
    }

    function breakStatement(label) {
      return (0, _builder.default)('BreakStatement', ...arguments);
    }

    function callExpression(callee, _arguments) {
      return (0, _builder.default)('CallExpression', ...arguments);
    }

    function catchClause(param, body) {
      return (0, _builder.default)('CatchClause', ...arguments);
    }

    function conditionalExpression(test, consequent, alternate) {
      return (0, _builder.default)('ConditionalExpression', ...arguments);
    }

    function continueStatement(label) {
      return (0, _builder.default)('ContinueStatement', ...arguments);
    }

    function debuggerStatement() {
      return (0, _builder.default)('DebuggerStatement', ...arguments);
    }

    function doWhileStatement(test, body) {
      return (0, _builder.default)('DoWhileStatement', ...arguments);
    }

    function emptyStatement() {
      return (0, _builder.default)('EmptyStatement', ...arguments);
    }

    function expressionStatement(expression) {
      return (0, _builder.default)('ExpressionStatement', ...arguments);
    }

    function file(program, comments, tokens) {
      return (0, _builder.default)('File', ...arguments);
    }

    function forInStatement(left, right, body) {
      return (0, _builder.default)('ForInStatement', ...arguments);
    }

    function forStatement(init, test, update, body) {
      return (0, _builder.default)('ForStatement', ...arguments);
    }

    function functionDeclaration(id, params, body, generator, async) {
      return (0, _builder.default)('FunctionDeclaration', ...arguments);
    }

    function functionExpression(id, params, body, generator, async) {
      return (0, _builder.default)('FunctionExpression', ...arguments);
    }

    function identifier(name) {
      return (0, _builder.default)('Identifier', ...arguments);
    }

    function ifStatement(test, consequent, alternate) {
      return (0, _builder.default)('IfStatement', ...arguments);
    }

    function labeledStatement(label, body) {
      return (0, _builder.default)('LabeledStatement', ...arguments);
    }

    function stringLiteral(value) {
      return (0, _builder.default)('StringLiteral', ...arguments);
    }

    function numericLiteral(value) {
      return (0, _builder.default)('NumericLiteral', ...arguments);
    }

    function nullLiteral() {
      return (0, _builder.default)('NullLiteral', ...arguments);
    }

    function booleanLiteral(value) {
      return (0, _builder.default)('BooleanLiteral', ...arguments);
    }

    function regExpLiteral(pattern, flags) {
      return (0, _builder.default)('RegExpLiteral', ...arguments);
    }

    function logicalExpression(operator, left, right) {
      return (0, _builder.default)('LogicalExpression', ...arguments);
    }

    function memberExpression(object, property, computed, optional) {
      return (0, _builder.default)('MemberExpression', ...arguments);
    }

    function newExpression(callee, _arguments) {
      return (0, _builder.default)('NewExpression', ...arguments);
    }

    function program(body, directives, sourceType, interpreter) {
      return (0, _builder.default)('Program', ...arguments);
    }

    function objectExpression(properties) {
      return (0, _builder.default)('ObjectExpression', ...arguments);
    }

    function objectMethod(kind, key, params, body, computed, generator, async) {
      return (0, _builder.default)('ObjectMethod', ...arguments);
    }

    function objectProperty(key, value, computed, shorthand, decorators) {
      return (0, _builder.default)('ObjectProperty', ...arguments);
    }

    function restElement(argument) {
      return (0, _builder.default)('RestElement', ...arguments);
    }

    function returnStatement(argument) {
      return (0, _builder.default)('ReturnStatement', ...arguments);
    }

    function sequenceExpression(expressions) {
      return (0, _builder.default)('SequenceExpression', ...arguments);
    }

    function parenthesizedExpression(expression) {
      return (0, _builder.default)('ParenthesizedExpression', ...arguments);
    }

    function switchCase(test, consequent) {
      return (0, _builder.default)('SwitchCase', ...arguments);
    }

    function switchStatement(discriminant, cases) {
      return (0, _builder.default)('SwitchStatement', ...arguments);
    }

    function thisExpression() {
      return (0, _builder.default)('ThisExpression', ...arguments);
    }

    function throwStatement(argument) {
      return (0, _builder.default)('ThrowStatement', ...arguments);
    }

    function tryStatement(block, handler, finalizer) {
      return (0, _builder.default)('TryStatement', ...arguments);
    }

    function unaryExpression(operator, argument, prefix) {
      return (0, _builder.default)('UnaryExpression', ...arguments);
    }

    function updateExpression(operator, argument, prefix) {
      return (0, _builder.default)('UpdateExpression', ...arguments);
    }

    function variableDeclaration(kind, declarations) {
      return (0, _builder.default)('VariableDeclaration', ...arguments);
    }

    function variableDeclarator(id, init) {
      return (0, _builder.default)('VariableDeclarator', ...arguments);
    }

    function whileStatement(test, body) {
      return (0, _builder.default)('WhileStatement', ...arguments);
    }

    function withStatement(object, body) {
      return (0, _builder.default)('WithStatement', ...arguments);
    }

    function assignmentPattern(left, right) {
      return (0, _builder.default)('AssignmentPattern', ...arguments);
    }

    function arrayPattern(elements) {
      return (0, _builder.default)('ArrayPattern', ...arguments);
    }

    function arrowFunctionExpression(params, body, async) {
      return (0, _builder.default)('ArrowFunctionExpression', ...arguments);
    }

    function classBody(body) {
      return (0, _builder.default)('ClassBody', ...arguments);
    }

    function classExpression(id, superClass, body, decorators) {
      return (0, _builder.default)('ClassExpression', ...arguments);
    }

    function classDeclaration(id, superClass, body, decorators) {
      return (0, _builder.default)('ClassDeclaration', ...arguments);
    }

    function exportAllDeclaration(source) {
      return (0, _builder.default)('ExportAllDeclaration', ...arguments);
    }

    function exportDefaultDeclaration(declaration) {
      return (0, _builder.default)('ExportDefaultDeclaration', ...arguments);
    }

    function exportNamedDeclaration(declaration, specifiers, source) {
      return (0, _builder.default)('ExportNamedDeclaration', ...arguments);
    }

    function exportSpecifier(local, exported) {
      return (0, _builder.default)('ExportSpecifier', ...arguments);
    }

    function forOfStatement(left, right, body, _await) {
      return (0, _builder.default)('ForOfStatement', ...arguments);
    }

    function importDeclaration(specifiers, source) {
      return (0, _builder.default)('ImportDeclaration', ...arguments);
    }

    function importDefaultSpecifier(local) {
      return (0, _builder.default)('ImportDefaultSpecifier', ...arguments);
    }

    function importNamespaceSpecifier(local) {
      return (0, _builder.default)('ImportNamespaceSpecifier', ...arguments);
    }

    function importSpecifier(local, imported) {
      return (0, _builder.default)('ImportSpecifier', ...arguments);
    }

    function metaProperty(meta, property) {
      return (0, _builder.default)('MetaProperty', ...arguments);
    }

    function classMethod(
      kind,
      key,
      params,
      body,
      computed,
      _static,
      generator,
      async,
    ) {
      return (0, _builder.default)('ClassMethod', ...arguments);
    }

    function objectPattern(properties) {
      return (0, _builder.default)('ObjectPattern', ...arguments);
    }

    function spreadElement(argument) {
      return (0, _builder.default)('SpreadElement', ...arguments);
    }

    function _super() {
      return (0, _builder.default)('Super', ...arguments);
    }

    function taggedTemplateExpression(tag, quasi) {
      return (0, _builder.default)('TaggedTemplateExpression', ...arguments);
    }

    function templateElement(value, tail) {
      return (0, _builder.default)('TemplateElement', ...arguments);
    }

    function templateLiteral(quasis, expressions) {
      return (0, _builder.default)('TemplateLiteral', ...arguments);
    }

    function yieldExpression(argument, delegate) {
      return (0, _builder.default)('YieldExpression', ...arguments);
    }

    function awaitExpression(argument) {
      return (0, _builder.default)('AwaitExpression', ...arguments);
    }

    function _import() {
      return (0, _builder.default)('Import', ...arguments);
    }

    function bigIntLiteral(value) {
      return (0, _builder.default)('BigIntLiteral', ...arguments);
    }

    function exportNamespaceSpecifier(exported) {
      return (0, _builder.default)('ExportNamespaceSpecifier', ...arguments);
    }

    function optionalMemberExpression(object, property, computed, optional) {
      return (0, _builder.default)('OptionalMemberExpression', ...arguments);
    }

    function optionalCallExpression(callee, _arguments, optional) {
      return (0, _builder.default)('OptionalCallExpression', ...arguments);
    }

    function anyTypeAnnotation() {
      return (0, _builder.default)('AnyTypeAnnotation', ...arguments);
    }

    function arrayTypeAnnotation(elementType) {
      return (0, _builder.default)('ArrayTypeAnnotation', ...arguments);
    }

    function booleanTypeAnnotation() {
      return (0, _builder.default)('BooleanTypeAnnotation', ...arguments);
    }

    function booleanLiteralTypeAnnotation(value) {
      return (0,
      _builder.default)('BooleanLiteralTypeAnnotation', ...arguments);
    }

    function nullLiteralTypeAnnotation() {
      return (0, _builder.default)('NullLiteralTypeAnnotation', ...arguments);
    }

    function classImplements(id, typeParameters) {
      return (0, _builder.default)('ClassImplements', ...arguments);
    }

    function declareClass(id, typeParameters, _extends, body) {
      return (0, _builder.default)('DeclareClass', ...arguments);
    }

    function declareFunction(id) {
      return (0, _builder.default)('DeclareFunction', ...arguments);
    }

    function declareInterface(id, typeParameters, _extends, body) {
      return (0, _builder.default)('DeclareInterface', ...arguments);
    }

    function declareModule(id, body, kind) {
      return (0, _builder.default)('DeclareModule', ...arguments);
    }

    function declareModuleExports(typeAnnotation) {
      return (0, _builder.default)('DeclareModuleExports', ...arguments);
    }

    function declareTypeAlias(id, typeParameters, right) {
      return (0, _builder.default)('DeclareTypeAlias', ...arguments);
    }

    function declareOpaqueType(id, typeParameters, supertype) {
      return (0, _builder.default)('DeclareOpaqueType', ...arguments);
    }

    function declareVariable(id) {
      return (0, _builder.default)('DeclareVariable', ...arguments);
    }

    function declareExportDeclaration(declaration, specifiers, source) {
      return (0, _builder.default)('DeclareExportDeclaration', ...arguments);
    }

    function declareExportAllDeclaration(source) {
      return (0, _builder.default)('DeclareExportAllDeclaration', ...arguments);
    }

    function declaredPredicate(value) {
      return (0, _builder.default)('DeclaredPredicate', ...arguments);
    }

    function existsTypeAnnotation() {
      return (0, _builder.default)('ExistsTypeAnnotation', ...arguments);
    }

    function functionTypeAnnotation(typeParameters, params, rest, returnType) {
      return (0, _builder.default)('FunctionTypeAnnotation', ...arguments);
    }

    function functionTypeParam(name, typeAnnotation) {
      return (0, _builder.default)('FunctionTypeParam', ...arguments);
    }

    function genericTypeAnnotation(id, typeParameters) {
      return (0, _builder.default)('GenericTypeAnnotation', ...arguments);
    }

    function inferredPredicate() {
      return (0, _builder.default)('InferredPredicate', ...arguments);
    }

    function interfaceExtends(id, typeParameters) {
      return (0, _builder.default)('InterfaceExtends', ...arguments);
    }

    function interfaceDeclaration(id, typeParameters, _extends, body) {
      return (0, _builder.default)('InterfaceDeclaration', ...arguments);
    }

    function interfaceTypeAnnotation(_extends, body) {
      return (0, _builder.default)('InterfaceTypeAnnotation', ...arguments);
    }

    function intersectionTypeAnnotation(types) {
      return (0, _builder.default)('IntersectionTypeAnnotation', ...arguments);
    }

    function mixedTypeAnnotation() {
      return (0, _builder.default)('MixedTypeAnnotation', ...arguments);
    }

    function emptyTypeAnnotation() {
      return (0, _builder.default)('EmptyTypeAnnotation', ...arguments);
    }

    function nullableTypeAnnotation(typeAnnotation) {
      return (0, _builder.default)('NullableTypeAnnotation', ...arguments);
    }

    function numberLiteralTypeAnnotation(value) {
      return (0, _builder.default)('NumberLiteralTypeAnnotation', ...arguments);
    }

    function numberTypeAnnotation() {
      return (0, _builder.default)('NumberTypeAnnotation', ...arguments);
    }

    function objectTypeAnnotation(
      properties,
      indexers,
      callProperties,
      internalSlots,
      exact,
    ) {
      return (0, _builder.default)('ObjectTypeAnnotation', ...arguments);
    }

    function objectTypeInternalSlot(id, value, optional, _static, method) {
      return (0, _builder.default)('ObjectTypeInternalSlot', ...arguments);
    }

    function objectTypeCallProperty(value) {
      return (0, _builder.default)('ObjectTypeCallProperty', ...arguments);
    }

    function objectTypeIndexer(id, key, value, variance) {
      return (0, _builder.default)('ObjectTypeIndexer', ...arguments);
    }

    function objectTypeProperty(key, value, variance) {
      return (0, _builder.default)('ObjectTypeProperty', ...arguments);
    }

    function objectTypeSpreadProperty(argument) {
      return (0, _builder.default)('ObjectTypeSpreadProperty', ...arguments);
    }

    function opaqueType(id, typeParameters, supertype, impltype) {
      return (0, _builder.default)('OpaqueType', ...arguments);
    }

    function qualifiedTypeIdentifier(id, qualification) {
      return (0, _builder.default)('QualifiedTypeIdentifier', ...arguments);
    }

    function stringLiteralTypeAnnotation(value) {
      return (0, _builder.default)('StringLiteralTypeAnnotation', ...arguments);
    }

    function stringTypeAnnotation() {
      return (0, _builder.default)('StringTypeAnnotation', ...arguments);
    }

    function symbolTypeAnnotation() {
      return (0, _builder.default)('SymbolTypeAnnotation', ...arguments);
    }

    function thisTypeAnnotation() {
      return (0, _builder.default)('ThisTypeAnnotation', ...arguments);
    }

    function tupleTypeAnnotation(types) {
      return (0, _builder.default)('TupleTypeAnnotation', ...arguments);
    }

    function typeofTypeAnnotation(argument) {
      return (0, _builder.default)('TypeofTypeAnnotation', ...arguments);
    }

    function typeAlias(id, typeParameters, right) {
      return (0, _builder.default)('TypeAlias', ...arguments);
    }

    function typeAnnotation(typeAnnotation) {
      return (0, _builder.default)('TypeAnnotation', ...arguments);
    }

    function typeCastExpression(expression, typeAnnotation) {
      return (0, _builder.default)('TypeCastExpression', ...arguments);
    }

    function typeParameter(bound, _default, variance) {
      return (0, _builder.default)('TypeParameter', ...arguments);
    }

    function typeParameterDeclaration(params) {
      return (0, _builder.default)('TypeParameterDeclaration', ...arguments);
    }

    function typeParameterInstantiation(params) {
      return (0, _builder.default)('TypeParameterInstantiation', ...arguments);
    }

    function unionTypeAnnotation(types) {
      return (0, _builder.default)('UnionTypeAnnotation', ...arguments);
    }

    function variance(kind) {
      return (0, _builder.default)('Variance', ...arguments);
    }

    function voidTypeAnnotation() {
      return (0, _builder.default)('VoidTypeAnnotation', ...arguments);
    }

    function enumDeclaration(id, body) {
      return (0, _builder.default)('EnumDeclaration', ...arguments);
    }

    function enumBooleanBody(members) {
      return (0, _builder.default)('EnumBooleanBody', ...arguments);
    }

    function enumNumberBody(members) {
      return (0, _builder.default)('EnumNumberBody', ...arguments);
    }

    function enumStringBody(members) {
      return (0, _builder.default)('EnumStringBody', ...arguments);
    }

    function enumSymbolBody(members) {
      return (0, _builder.default)('EnumSymbolBody', ...arguments);
    }

    function enumBooleanMember(id) {
      return (0, _builder.default)('EnumBooleanMember', ...arguments);
    }

    function enumNumberMember(id, init) {
      return (0, _builder.default)('EnumNumberMember', ...arguments);
    }

    function enumStringMember(id, init) {
      return (0, _builder.default)('EnumStringMember', ...arguments);
    }

    function enumDefaultedMember(id) {
      return (0, _builder.default)('EnumDefaultedMember', ...arguments);
    }

    function jsxAttribute(name, value) {
      return (0, _builder.default)('JSXAttribute', ...arguments);
    }

    function jsxClosingElement(name) {
      return (0, _builder.default)('JSXClosingElement', ...arguments);
    }

    function jsxElement(openingElement, closingElement, children, selfClosing) {
      return (0, _builder.default)('JSXElement', ...arguments);
    }

    function jsxEmptyExpression() {
      return (0, _builder.default)('JSXEmptyExpression', ...arguments);
    }

    function jsxExpressionContainer(expression) {
      return (0, _builder.default)('JSXExpressionContainer', ...arguments);
    }

    function jsxSpreadChild(expression) {
      return (0, _builder.default)('JSXSpreadChild', ...arguments);
    }

    function jsxIdentifier(name) {
      return (0, _builder.default)('JSXIdentifier', ...arguments);
    }

    function jsxMemberExpression(object, property) {
      return (0, _builder.default)('JSXMemberExpression', ...arguments);
    }

    function jsxNamespacedName(namespace, name) {
      return (0, _builder.default)('JSXNamespacedName', ...arguments);
    }

    function jsxOpeningElement(name, attributes, selfClosing) {
      return (0, _builder.default)('JSXOpeningElement', ...arguments);
    }

    function jsxSpreadAttribute(argument) {
      return (0, _builder.default)('JSXSpreadAttribute', ...arguments);
    }

    function jsxText(value) {
      return (0, _builder.default)('JSXText', ...arguments);
    }

    function jsxFragment(openingFragment, closingFragment, children) {
      return (0, _builder.default)('JSXFragment', ...arguments);
    }

    function jsxOpeningFragment() {
      return (0, _builder.default)('JSXOpeningFragment', ...arguments);
    }

    function jsxClosingFragment() {
      return (0, _builder.default)('JSXClosingFragment', ...arguments);
    }

    function noop() {
      return (0, _builder.default)('Noop', ...arguments);
    }

    function placeholder(expectedNode, name) {
      return (0, _builder.default)('Placeholder', ...arguments);
    }

    function v8IntrinsicIdentifier(name) {
      return (0, _builder.default)('V8IntrinsicIdentifier', ...arguments);
    }

    function argumentPlaceholder() {
      return (0, _builder.default)('ArgumentPlaceholder', ...arguments);
    }

    function bindExpression(object, callee) {
      return (0, _builder.default)('BindExpression', ...arguments);
    }

    function classProperty(
      key,
      value,
      typeAnnotation,
      decorators,
      computed,
      _static,
    ) {
      return (0, _builder.default)('ClassProperty', ...arguments);
    }

    function pipelineTopicExpression(expression) {
      return (0, _builder.default)('PipelineTopicExpression', ...arguments);
    }

    function pipelineBareFunction(callee) {
      return (0, _builder.default)('PipelineBareFunction', ...arguments);
    }

    function pipelinePrimaryTopicReference() {
      return (0,
      _builder.default)('PipelinePrimaryTopicReference', ...arguments);
    }

    function classPrivateProperty(key, value, decorators, _static) {
      return (0, _builder.default)('ClassPrivateProperty', ...arguments);
    }

    function classPrivateMethod(kind, key, params, body, _static) {
      return (0, _builder.default)('ClassPrivateMethod', ...arguments);
    }

    function importAttribute(key, value) {
      return (0, _builder.default)('ImportAttribute', ...arguments);
    }

    function decorator(expression) {
      return (0, _builder.default)('Decorator', ...arguments);
    }

    function doExpression(body) {
      return (0, _builder.default)('DoExpression', ...arguments);
    }

    function exportDefaultSpecifier(exported) {
      return (0, _builder.default)('ExportDefaultSpecifier', ...arguments);
    }

    function privateName(id) {
      return (0, _builder.default)('PrivateName', ...arguments);
    }

    function recordExpression(properties) {
      return (0, _builder.default)('RecordExpression', ...arguments);
    }

    function tupleExpression(elements) {
      return (0, _builder.default)('TupleExpression', ...arguments);
    }

    function decimalLiteral(value) {
      return (0, _builder.default)('DecimalLiteral', ...arguments);
    }

    function staticBlock(body) {
      return (0, _builder.default)('StaticBlock', ...arguments);
    }

    function moduleExpression(body) {
      return (0, _builder.default)('ModuleExpression', ...arguments);
    }

    function tsParameterProperty(parameter) {
      return (0, _builder.default)('TSParameterProperty', ...arguments);
    }

    function tsDeclareFunction(id, typeParameters, params, returnType) {
      return (0, _builder.default)('TSDeclareFunction', ...arguments);
    }

    function tsDeclareMethod(
      decorators,
      key,
      typeParameters,
      params,
      returnType,
    ) {
      return (0, _builder.default)('TSDeclareMethod', ...arguments);
    }

    function tsQualifiedName(left, right) {
      return (0, _builder.default)('TSQualifiedName', ...arguments);
    }

    function tsCallSignatureDeclaration(
      typeParameters,
      parameters,
      typeAnnotation,
    ) {
      return (0, _builder.default)('TSCallSignatureDeclaration', ...arguments);
    }

    function tsConstructSignatureDeclaration(
      typeParameters,
      parameters,
      typeAnnotation,
    ) {
      return (0,
      _builder.default)('TSConstructSignatureDeclaration', ...arguments);
    }

    function tsPropertySignature(key, typeAnnotation, initializer) {
      return (0, _builder.default)('TSPropertySignature', ...arguments);
    }

    function tsMethodSignature(
      key,
      typeParameters,
      parameters,
      typeAnnotation,
    ) {
      return (0, _builder.default)('TSMethodSignature', ...arguments);
    }

    function tsIndexSignature(parameters, typeAnnotation) {
      return (0, _builder.default)('TSIndexSignature', ...arguments);
    }

    function tsAnyKeyword() {
      return (0, _builder.default)('TSAnyKeyword', ...arguments);
    }

    function tsBooleanKeyword() {
      return (0, _builder.default)('TSBooleanKeyword', ...arguments);
    }

    function tsBigIntKeyword() {
      return (0, _builder.default)('TSBigIntKeyword', ...arguments);
    }

    function tsIntrinsicKeyword() {
      return (0, _builder.default)('TSIntrinsicKeyword', ...arguments);
    }

    function tsNeverKeyword() {
      return (0, _builder.default)('TSNeverKeyword', ...arguments);
    }

    function tsNullKeyword() {
      return (0, _builder.default)('TSNullKeyword', ...arguments);
    }

    function tsNumberKeyword() {
      return (0, _builder.default)('TSNumberKeyword', ...arguments);
    }

    function tsObjectKeyword() {
      return (0, _builder.default)('TSObjectKeyword', ...arguments);
    }

    function tsStringKeyword() {
      return (0, _builder.default)('TSStringKeyword', ...arguments);
    }

    function tsSymbolKeyword() {
      return (0, _builder.default)('TSSymbolKeyword', ...arguments);
    }

    function tsUndefinedKeyword() {
      return (0, _builder.default)('TSUndefinedKeyword', ...arguments);
    }

    function tsUnknownKeyword() {
      return (0, _builder.default)('TSUnknownKeyword', ...arguments);
    }

    function tsVoidKeyword() {
      return (0, _builder.default)('TSVoidKeyword', ...arguments);
    }

    function tsThisType() {
      return (0, _builder.default)('TSThisType', ...arguments);
    }

    function tsFunctionType(typeParameters, parameters, typeAnnotation) {
      return (0, _builder.default)('TSFunctionType', ...arguments);
    }

    function tsConstructorType(typeParameters, parameters, typeAnnotation) {
      return (0, _builder.default)('TSConstructorType', ...arguments);
    }

    function tsTypeReference(typeName, typeParameters) {
      return (0, _builder.default)('TSTypeReference', ...arguments);
    }

    function tsTypePredicate(parameterName, typeAnnotation, asserts) {
      return (0, _builder.default)('TSTypePredicate', ...arguments);
    }

    function tsTypeQuery(exprName) {
      return (0, _builder.default)('TSTypeQuery', ...arguments);
    }

    function tsTypeLiteral(members) {
      return (0, _builder.default)('TSTypeLiteral', ...arguments);
    }

    function tsArrayType(elementType) {
      return (0, _builder.default)('TSArrayType', ...arguments);
    }

    function tsTupleType(elementTypes) {
      return (0, _builder.default)('TSTupleType', ...arguments);
    }

    function tsOptionalType(typeAnnotation) {
      return (0, _builder.default)('TSOptionalType', ...arguments);
    }

    function tsRestType(typeAnnotation) {
      return (0, _builder.default)('TSRestType', ...arguments);
    }

    function tsNamedTupleMember(label, elementType, optional) {
      return (0, _builder.default)('TSNamedTupleMember', ...arguments);
    }

    function tsUnionType(types) {
      return (0, _builder.default)('TSUnionType', ...arguments);
    }

    function tsIntersectionType(types) {
      return (0, _builder.default)('TSIntersectionType', ...arguments);
    }

    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      return (0, _builder.default)('TSConditionalType', ...arguments);
    }

    function tsInferType(typeParameter) {
      return (0, _builder.default)('TSInferType', ...arguments);
    }

    function tsParenthesizedType(typeAnnotation) {
      return (0, _builder.default)('TSParenthesizedType', ...arguments);
    }

    function tsTypeOperator(typeAnnotation) {
      return (0, _builder.default)('TSTypeOperator', ...arguments);
    }

    function tsIndexedAccessType(objectType, indexType) {
      return (0, _builder.default)('TSIndexedAccessType', ...arguments);
    }

    function tsMappedType(typeParameter, typeAnnotation, nameType) {
      return (0, _builder.default)('TSMappedType', ...arguments);
    }

    function tsLiteralType(literal) {
      return (0, _builder.default)('TSLiteralType', ...arguments);
    }

    function tsExpressionWithTypeArguments(expression, typeParameters) {
      return (0,
      _builder.default)('TSExpressionWithTypeArguments', ...arguments);
    }

    function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
      return (0, _builder.default)('TSInterfaceDeclaration', ...arguments);
    }

    function tsInterfaceBody(body) {
      return (0, _builder.default)('TSInterfaceBody', ...arguments);
    }

    function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
      return (0, _builder.default)('TSTypeAliasDeclaration', ...arguments);
    }

    function tsAsExpression(expression, typeAnnotation) {
      return (0, _builder.default)('TSAsExpression', ...arguments);
    }

    function tsTypeAssertion(typeAnnotation, expression) {
      return (0, _builder.default)('TSTypeAssertion', ...arguments);
    }

    function tsEnumDeclaration(id, members) {
      return (0, _builder.default)('TSEnumDeclaration', ...arguments);
    }

    function tsEnumMember(id, initializer) {
      return (0, _builder.default)('TSEnumMember', ...arguments);
    }

    function tsModuleDeclaration(id, body) {
      return (0, _builder.default)('TSModuleDeclaration', ...arguments);
    }

    function tsModuleBlock(body) {
      return (0, _builder.default)('TSModuleBlock', ...arguments);
    }

    function tsImportType(argument, qualifier, typeParameters) {
      return (0, _builder.default)('TSImportType', ...arguments);
    }

    function tsImportEqualsDeclaration(id, moduleReference) {
      return (0, _builder.default)('TSImportEqualsDeclaration', ...arguments);
    }

    function tsExternalModuleReference(expression) {
      return (0, _builder.default)('TSExternalModuleReference', ...arguments);
    }

    function tsNonNullExpression(expression) {
      return (0, _builder.default)('TSNonNullExpression', ...arguments);
    }

    function tsExportAssignment(expression) {
      return (0, _builder.default)('TSExportAssignment', ...arguments);
    }

    function tsNamespaceExportDeclaration(id) {
      return (0,
      _builder.default)('TSNamespaceExportDeclaration', ...arguments);
    }

    function tsTypeAnnotation(typeAnnotation) {
      return (0, _builder.default)('TSTypeAnnotation', ...arguments);
    }

    function tsTypeParameterInstantiation(params) {
      return (0,
      _builder.default)('TSTypeParameterInstantiation', ...arguments);
    }

    function tsTypeParameterDeclaration(params) {
      return (0, _builder.default)('TSTypeParameterDeclaration', ...arguments);
    }

    function tsTypeParameter(constraint, _default, name) {
      return (0, _builder.default)('TSTypeParameter', ...arguments);
    }

    function NumberLiteral(...args) {
      console.trace(
        'The node type NumberLiteral has been renamed to NumericLiteral',
      );
      return (0, _builder.default)('NumberLiteral', ...args);
    }

    function RegexLiteral(...args) {
      console.trace(
        'The node type RegexLiteral has been renamed to RegExpLiteral',
      );
      return (0, _builder.default)('RegexLiteral', ...args);
    }

    function RestProperty(...args) {
      console.trace(
        'The node type RestProperty has been renamed to RestElement',
      );
      return (0, _builder.default)('RestProperty', ...args);
    }

    function SpreadProperty(...args) {
      console.trace(
        'The node type SpreadProperty has been renamed to SpreadElement',
      );
      return (0, _builder.default)('SpreadProperty', ...args);
    }
  });

  var _default$a = cleanJSXElementLiteralChild;

  function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;

    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    let str = '';

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, ' ');

      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, '');
      }

      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, '');
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += ' ';
        }

        str += trimmedLine;
      }
    }

    if (str) args.push((0, generated$1.stringLiteral)(str));
  }

  var cleanJSXElementLiteralChild_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$a,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$b = buildChildren;

  var _cleanJSXElementLiteralChild = _interopRequireDefault$4(
    cleanJSXElementLiteralChild_1,
  );

  function _interopRequireDefault$4(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function buildChildren(node) {
    const elements = [];

    for (let i = 0; i < node.children.length; i++) {
      let child = node.children[i];

      if ((0, generated.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }

      if ((0, generated.isJSXExpressionContainer)(child))
        child = child.expression;
      if ((0, generated.isJSXEmptyExpression)(child)) continue;
      elements.push(child);
    }

    return elements;
  }

  var buildChildren_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$b,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$c = isNode;

  function isNode(node) {
    return !!(node && definitions.VISITOR_KEYS[node.type]);
  }

  var isNode_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$c,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$d = assertNode;

  var _isNode = _interopRequireDefault$5(isNode_1);

  function _interopRequireDefault$5(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function assertNode(node) {
    if (!(0, _isNode.default)(node)) {
      var _node$type;

      const type =
        (_node$type = node == null ? void 0 : node.type) != null
          ? _node$type
          : JSON.stringify(node);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  }

  var assertNode_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$d,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var assertArrayExpression_1 = assertArrayExpression;
  var assertAssignmentExpression_1 = assertAssignmentExpression;
  var assertBinaryExpression_1 = assertBinaryExpression;
  var assertInterpreterDirective_1 = assertInterpreterDirective;
  var assertDirective_1 = assertDirective;
  var assertDirectiveLiteral_1 = assertDirectiveLiteral;
  var assertBlockStatement_1 = assertBlockStatement;
  var assertBreakStatement_1 = assertBreakStatement;
  var assertCallExpression_1 = assertCallExpression;
  var assertCatchClause_1 = assertCatchClause;
  var assertConditionalExpression_1 = assertConditionalExpression;
  var assertContinueStatement_1 = assertContinueStatement;
  var assertDebuggerStatement_1 = assertDebuggerStatement;
  var assertDoWhileStatement_1 = assertDoWhileStatement;
  var assertEmptyStatement_1 = assertEmptyStatement;
  var assertExpressionStatement_1 = assertExpressionStatement;
  var assertFile_1 = assertFile;
  var assertForInStatement_1 = assertForInStatement;
  var assertForStatement_1 = assertForStatement;
  var assertFunctionDeclaration_1 = assertFunctionDeclaration;
  var assertFunctionExpression_1 = assertFunctionExpression;
  var assertIdentifier_1 = assertIdentifier;
  var assertIfStatement_1 = assertIfStatement;
  var assertLabeledStatement_1 = assertLabeledStatement;
  var assertStringLiteral_1 = assertStringLiteral;
  var assertNumericLiteral_1 = assertNumericLiteral;
  var assertNullLiteral_1 = assertNullLiteral;
  var assertBooleanLiteral_1 = assertBooleanLiteral;
  var assertRegExpLiteral_1 = assertRegExpLiteral;
  var assertLogicalExpression_1 = assertLogicalExpression;
  var assertMemberExpression_1 = assertMemberExpression;
  var assertNewExpression_1 = assertNewExpression;
  var assertProgram_1 = assertProgram;
  var assertObjectExpression_1 = assertObjectExpression;
  var assertObjectMethod_1 = assertObjectMethod;
  var assertObjectProperty_1 = assertObjectProperty;
  var assertRestElement_1 = assertRestElement;
  var assertReturnStatement_1 = assertReturnStatement;
  var assertSequenceExpression_1 = assertSequenceExpression;
  var assertParenthesizedExpression_1 = assertParenthesizedExpression;
  var assertSwitchCase_1 = assertSwitchCase;
  var assertSwitchStatement_1 = assertSwitchStatement;
  var assertThisExpression_1 = assertThisExpression;
  var assertThrowStatement_1 = assertThrowStatement;
  var assertTryStatement_1 = assertTryStatement;
  var assertUnaryExpression_1 = assertUnaryExpression;
  var assertUpdateExpression_1 = assertUpdateExpression;
  var assertVariableDeclaration_1 = assertVariableDeclaration;
  var assertVariableDeclarator_1 = assertVariableDeclarator;
  var assertWhileStatement_1 = assertWhileStatement;
  var assertWithStatement_1 = assertWithStatement;
  var assertAssignmentPattern_1 = assertAssignmentPattern;
  var assertArrayPattern_1 = assertArrayPattern;
  var assertArrowFunctionExpression_1 = assertArrowFunctionExpression;
  var assertClassBody_1 = assertClassBody;
  var assertClassExpression_1 = assertClassExpression;
  var assertClassDeclaration_1 = assertClassDeclaration;
  var assertExportAllDeclaration_1 = assertExportAllDeclaration;
  var assertExportDefaultDeclaration_1 = assertExportDefaultDeclaration;
  var assertExportNamedDeclaration_1 = assertExportNamedDeclaration;
  var assertExportSpecifier_1 = assertExportSpecifier;
  var assertForOfStatement_1 = assertForOfStatement;
  var assertImportDeclaration_1 = assertImportDeclaration;
  var assertImportDefaultSpecifier_1 = assertImportDefaultSpecifier;
  var assertImportNamespaceSpecifier_1 = assertImportNamespaceSpecifier;
  var assertImportSpecifier_1 = assertImportSpecifier;
  var assertMetaProperty_1 = assertMetaProperty;
  var assertClassMethod_1 = assertClassMethod;
  var assertObjectPattern_1 = assertObjectPattern;
  var assertSpreadElement_1 = assertSpreadElement;
  var assertSuper_1 = assertSuper;
  var assertTaggedTemplateExpression_1 = assertTaggedTemplateExpression;
  var assertTemplateElement_1 = assertTemplateElement;
  var assertTemplateLiteral_1 = assertTemplateLiteral;
  var assertYieldExpression_1 = assertYieldExpression;
  var assertAwaitExpression_1 = assertAwaitExpression;
  var assertImport_1 = assertImport;
  var assertBigIntLiteral_1 = assertBigIntLiteral;
  var assertExportNamespaceSpecifier_1 = assertExportNamespaceSpecifier;
  var assertOptionalMemberExpression_1 = assertOptionalMemberExpression;
  var assertOptionalCallExpression_1 = assertOptionalCallExpression;
  var assertAnyTypeAnnotation_1 = assertAnyTypeAnnotation;
  var assertArrayTypeAnnotation_1 = assertArrayTypeAnnotation;
  var assertBooleanTypeAnnotation_1 = assertBooleanTypeAnnotation;
  var assertBooleanLiteralTypeAnnotation_1 = assertBooleanLiteralTypeAnnotation;
  var assertNullLiteralTypeAnnotation_1 = assertNullLiteralTypeAnnotation;
  var assertClassImplements_1 = assertClassImplements;
  var assertDeclareClass_1 = assertDeclareClass;
  var assertDeclareFunction_1 = assertDeclareFunction;
  var assertDeclareInterface_1 = assertDeclareInterface;
  var assertDeclareModule_1 = assertDeclareModule;
  var assertDeclareModuleExports_1 = assertDeclareModuleExports;
  var assertDeclareTypeAlias_1 = assertDeclareTypeAlias;
  var assertDeclareOpaqueType_1 = assertDeclareOpaqueType;
  var assertDeclareVariable_1 = assertDeclareVariable;
  var assertDeclareExportDeclaration_1 = assertDeclareExportDeclaration;
  var assertDeclareExportAllDeclaration_1 = assertDeclareExportAllDeclaration;
  var assertDeclaredPredicate_1 = assertDeclaredPredicate;
  var assertExistsTypeAnnotation_1 = assertExistsTypeAnnotation;
  var assertFunctionTypeAnnotation_1 = assertFunctionTypeAnnotation;
  var assertFunctionTypeParam_1 = assertFunctionTypeParam;
  var assertGenericTypeAnnotation_1 = assertGenericTypeAnnotation;
  var assertInferredPredicate_1 = assertInferredPredicate;
  var assertInterfaceExtends_1 = assertInterfaceExtends;
  var assertInterfaceDeclaration_1 = assertInterfaceDeclaration;
  var assertInterfaceTypeAnnotation_1 = assertInterfaceTypeAnnotation;
  var assertIntersectionTypeAnnotation_1 = assertIntersectionTypeAnnotation;
  var assertMixedTypeAnnotation_1 = assertMixedTypeAnnotation;
  var assertEmptyTypeAnnotation_1 = assertEmptyTypeAnnotation;
  var assertNullableTypeAnnotation_1 = assertNullableTypeAnnotation;
  var assertNumberLiteralTypeAnnotation_1 = assertNumberLiteralTypeAnnotation;
  var assertNumberTypeAnnotation_1 = assertNumberTypeAnnotation;
  var assertObjectTypeAnnotation_1 = assertObjectTypeAnnotation;
  var assertObjectTypeInternalSlot_1 = assertObjectTypeInternalSlot;
  var assertObjectTypeCallProperty_1 = assertObjectTypeCallProperty;
  var assertObjectTypeIndexer_1 = assertObjectTypeIndexer;
  var assertObjectTypeProperty_1 = assertObjectTypeProperty;
  var assertObjectTypeSpreadProperty_1 = assertObjectTypeSpreadProperty;
  var assertOpaqueType_1 = assertOpaqueType;
  var assertQualifiedTypeIdentifier_1 = assertQualifiedTypeIdentifier;
  var assertStringLiteralTypeAnnotation_1 = assertStringLiteralTypeAnnotation;
  var assertStringTypeAnnotation_1 = assertStringTypeAnnotation;
  var assertSymbolTypeAnnotation_1 = assertSymbolTypeAnnotation;
  var assertThisTypeAnnotation_1 = assertThisTypeAnnotation;
  var assertTupleTypeAnnotation_1 = assertTupleTypeAnnotation;
  var assertTypeofTypeAnnotation_1 = assertTypeofTypeAnnotation;
  var assertTypeAlias_1 = assertTypeAlias;
  var assertTypeAnnotation_1 = assertTypeAnnotation;
  var assertTypeCastExpression_1 = assertTypeCastExpression;
  var assertTypeParameter_1 = assertTypeParameter;
  var assertTypeParameterDeclaration_1 = assertTypeParameterDeclaration;
  var assertTypeParameterInstantiation_1 = assertTypeParameterInstantiation;
  var assertUnionTypeAnnotation_1 = assertUnionTypeAnnotation;
  var assertVariance_1 = assertVariance;
  var assertVoidTypeAnnotation_1 = assertVoidTypeAnnotation;
  var assertEnumDeclaration_1 = assertEnumDeclaration;
  var assertEnumBooleanBody_1 = assertEnumBooleanBody;
  var assertEnumNumberBody_1 = assertEnumNumberBody;
  var assertEnumStringBody_1 = assertEnumStringBody;
  var assertEnumSymbolBody_1 = assertEnumSymbolBody;
  var assertEnumBooleanMember_1 = assertEnumBooleanMember;
  var assertEnumNumberMember_1 = assertEnumNumberMember;
  var assertEnumStringMember_1 = assertEnumStringMember;
  var assertEnumDefaultedMember_1 = assertEnumDefaultedMember;
  var assertJSXAttribute_1 = assertJSXAttribute;
  var assertJSXClosingElement_1 = assertJSXClosingElement;
  var assertJSXElement_1 = assertJSXElement;
  var assertJSXEmptyExpression_1 = assertJSXEmptyExpression;
  var assertJSXExpressionContainer_1 = assertJSXExpressionContainer;
  var assertJSXSpreadChild_1 = assertJSXSpreadChild;
  var assertJSXIdentifier_1 = assertJSXIdentifier;
  var assertJSXMemberExpression_1 = assertJSXMemberExpression;
  var assertJSXNamespacedName_1 = assertJSXNamespacedName;
  var assertJSXOpeningElement_1 = assertJSXOpeningElement;
  var assertJSXSpreadAttribute_1 = assertJSXSpreadAttribute;
  var assertJSXText_1 = assertJSXText;
  var assertJSXFragment_1 = assertJSXFragment;
  var assertJSXOpeningFragment_1 = assertJSXOpeningFragment;
  var assertJSXClosingFragment_1 = assertJSXClosingFragment;
  var assertNoop_1 = assertNoop;
  var assertPlaceholder_1 = assertPlaceholder;
  var assertV8IntrinsicIdentifier_1 = assertV8IntrinsicIdentifier;
  var assertArgumentPlaceholder_1 = assertArgumentPlaceholder;
  var assertBindExpression_1 = assertBindExpression;
  var assertClassProperty_1 = assertClassProperty;
  var assertPipelineTopicExpression_1 = assertPipelineTopicExpression;
  var assertPipelineBareFunction_1 = assertPipelineBareFunction;
  var assertPipelinePrimaryTopicReference_1 = assertPipelinePrimaryTopicReference;
  var assertClassPrivateProperty_1 = assertClassPrivateProperty;
  var assertClassPrivateMethod_1 = assertClassPrivateMethod;
  var assertImportAttribute_1 = assertImportAttribute;
  var assertDecorator_1 = assertDecorator;
  var assertDoExpression_1 = assertDoExpression;
  var assertExportDefaultSpecifier_1 = assertExportDefaultSpecifier;
  var assertPrivateName_1 = assertPrivateName;
  var assertRecordExpression_1 = assertRecordExpression;
  var assertTupleExpression_1 = assertTupleExpression;
  var assertDecimalLiteral_1 = assertDecimalLiteral;
  var assertStaticBlock_1 = assertStaticBlock;
  var assertModuleExpression_1 = assertModuleExpression;
  var assertTSParameterProperty_1 = assertTSParameterProperty;
  var assertTSDeclareFunction_1 = assertTSDeclareFunction;
  var assertTSDeclareMethod_1 = assertTSDeclareMethod;
  var assertTSQualifiedName_1 = assertTSQualifiedName;
  var assertTSCallSignatureDeclaration_1 = assertTSCallSignatureDeclaration;
  var assertTSConstructSignatureDeclaration_1 = assertTSConstructSignatureDeclaration;
  var assertTSPropertySignature_1 = assertTSPropertySignature;
  var assertTSMethodSignature_1 = assertTSMethodSignature;
  var assertTSIndexSignature_1 = assertTSIndexSignature;
  var assertTSAnyKeyword_1 = assertTSAnyKeyword;
  var assertTSBooleanKeyword_1 = assertTSBooleanKeyword;
  var assertTSBigIntKeyword_1 = assertTSBigIntKeyword;
  var assertTSIntrinsicKeyword_1 = assertTSIntrinsicKeyword;
  var assertTSNeverKeyword_1 = assertTSNeverKeyword;
  var assertTSNullKeyword_1 = assertTSNullKeyword;
  var assertTSNumberKeyword_1 = assertTSNumberKeyword;
  var assertTSObjectKeyword_1 = assertTSObjectKeyword;
  var assertTSStringKeyword_1 = assertTSStringKeyword;
  var assertTSSymbolKeyword_1 = assertTSSymbolKeyword;
  var assertTSUndefinedKeyword_1 = assertTSUndefinedKeyword;
  var assertTSUnknownKeyword_1 = assertTSUnknownKeyword;
  var assertTSVoidKeyword_1 = assertTSVoidKeyword;
  var assertTSThisType_1 = assertTSThisType;
  var assertTSFunctionType_1 = assertTSFunctionType;
  var assertTSConstructorType_1 = assertTSConstructorType;
  var assertTSTypeReference_1 = assertTSTypeReference;
  var assertTSTypePredicate_1 = assertTSTypePredicate;
  var assertTSTypeQuery_1 = assertTSTypeQuery;
  var assertTSTypeLiteral_1 = assertTSTypeLiteral;
  var assertTSArrayType_1 = assertTSArrayType;
  var assertTSTupleType_1 = assertTSTupleType;
  var assertTSOptionalType_1 = assertTSOptionalType;
  var assertTSRestType_1 = assertTSRestType;
  var assertTSNamedTupleMember_1 = assertTSNamedTupleMember;
  var assertTSUnionType_1 = assertTSUnionType;
  var assertTSIntersectionType_1 = assertTSIntersectionType;
  var assertTSConditionalType_1 = assertTSConditionalType;
  var assertTSInferType_1 = assertTSInferType;
  var assertTSParenthesizedType_1 = assertTSParenthesizedType;
  var assertTSTypeOperator_1 = assertTSTypeOperator;
  var assertTSIndexedAccessType_1 = assertTSIndexedAccessType;
  var assertTSMappedType_1 = assertTSMappedType;
  var assertTSLiteralType_1 = assertTSLiteralType;
  var assertTSExpressionWithTypeArguments_1 = assertTSExpressionWithTypeArguments;
  var assertTSInterfaceDeclaration_1 = assertTSInterfaceDeclaration;
  var assertTSInterfaceBody_1 = assertTSInterfaceBody;
  var assertTSTypeAliasDeclaration_1 = assertTSTypeAliasDeclaration;
  var assertTSAsExpression_1 = assertTSAsExpression;
  var assertTSTypeAssertion_1 = assertTSTypeAssertion;
  var assertTSEnumDeclaration_1 = assertTSEnumDeclaration;
  var assertTSEnumMember_1 = assertTSEnumMember;
  var assertTSModuleDeclaration_1 = assertTSModuleDeclaration;
  var assertTSModuleBlock_1 = assertTSModuleBlock;
  var assertTSImportType_1 = assertTSImportType;
  var assertTSImportEqualsDeclaration_1 = assertTSImportEqualsDeclaration;
  var assertTSExternalModuleReference_1 = assertTSExternalModuleReference;
  var assertTSNonNullExpression_1 = assertTSNonNullExpression;
  var assertTSExportAssignment_1 = assertTSExportAssignment;
  var assertTSNamespaceExportDeclaration_1 = assertTSNamespaceExportDeclaration;
  var assertTSTypeAnnotation_1 = assertTSTypeAnnotation;
  var assertTSTypeParameterInstantiation_1 = assertTSTypeParameterInstantiation;
  var assertTSTypeParameterDeclaration_1 = assertTSTypeParameterDeclaration;
  var assertTSTypeParameter_1 = assertTSTypeParameter;
  var assertExpression_1 = assertExpression;
  var assertBinary_1 = assertBinary;
  var assertScopable_1 = assertScopable;
  var assertBlockParent_1 = assertBlockParent;
  var assertBlock_1 = assertBlock;
  var assertStatement_1 = assertStatement;
  var assertTerminatorless_1 = assertTerminatorless;
  var assertCompletionStatement_1 = assertCompletionStatement;
  var assertConditional_1 = assertConditional;
  var assertLoop_1 = assertLoop;
  var assertWhile_1 = assertWhile;
  var assertExpressionWrapper_1 = assertExpressionWrapper;
  var assertFor_1 = assertFor;
  var assertForXStatement_1 = assertForXStatement;
  var assertFunction_1 = assertFunction;
  var assertFunctionParent_1 = assertFunctionParent;
  var assertPureish_1 = assertPureish;
  var assertDeclaration_1 = assertDeclaration;
  var assertPatternLike_1 = assertPatternLike;
  var assertLVal_1 = assertLVal;
  var assertTSEntityName_1 = assertTSEntityName;
  var assertLiteral_1 = assertLiteral;
  var assertImmutable_1 = assertImmutable;
  var assertUserWhitespacable_1 = assertUserWhitespacable;
  var assertMethod_1 = assertMethod;
  var assertObjectMember_1 = assertObjectMember;
  var assertProperty_1 = assertProperty;
  var assertUnaryLike_1 = assertUnaryLike;
  var assertPattern_1 = assertPattern;
  var assertClass_1 = assertClass;
  var assertModuleDeclaration_1 = assertModuleDeclaration;
  var assertExportDeclaration_1 = assertExportDeclaration;
  var assertModuleSpecifier_1 = assertModuleSpecifier;
  var assertFlow_1 = assertFlow;
  var assertFlowType_1 = assertFlowType;
  var assertFlowBaseAnnotation_1 = assertFlowBaseAnnotation;
  var assertFlowDeclaration_1 = assertFlowDeclaration;
  var assertFlowPredicate_1 = assertFlowPredicate;
  var assertEnumBody_1 = assertEnumBody;
  var assertEnumMember_1 = assertEnumMember;
  var assertJSX_1 = assertJSX;
  var assertPrivate_1 = assertPrivate;
  var assertTSTypeElement_1 = assertTSTypeElement;
  var assertTSType_1 = assertTSType;
  var assertTSBaseType_1 = assertTSBaseType;
  var assertNumberLiteral_1 = assertNumberLiteral;
  var assertRegexLiteral_1 = assertRegexLiteral;
  var assertRestProperty_1 = assertRestProperty;
  var assertSpreadProperty_1 = assertSpreadProperty;

  var _is = _interopRequireDefault$6(is_1);

  function _interopRequireDefault$6(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function assert$1(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) {
      throw new Error(
        `Expected type "${type}" with option ${JSON.stringify(opts)}, ` +
          `but instead got "${node.type}".`,
      );
    }
  }

  function assertArrayExpression(node, opts) {
    assert$1('ArrayExpression', node, opts);
  }

  function assertAssignmentExpression(node, opts) {
    assert$1('AssignmentExpression', node, opts);
  }

  function assertBinaryExpression(node, opts) {
    assert$1('BinaryExpression', node, opts);
  }

  function assertInterpreterDirective(node, opts) {
    assert$1('InterpreterDirective', node, opts);
  }

  function assertDirective(node, opts) {
    assert$1('Directive', node, opts);
  }

  function assertDirectiveLiteral(node, opts) {
    assert$1('DirectiveLiteral', node, opts);
  }

  function assertBlockStatement(node, opts) {
    assert$1('BlockStatement', node, opts);
  }

  function assertBreakStatement(node, opts) {
    assert$1('BreakStatement', node, opts);
  }

  function assertCallExpression(node, opts) {
    assert$1('CallExpression', node, opts);
  }

  function assertCatchClause(node, opts) {
    assert$1('CatchClause', node, opts);
  }

  function assertConditionalExpression(node, opts) {
    assert$1('ConditionalExpression', node, opts);
  }

  function assertContinueStatement(node, opts) {
    assert$1('ContinueStatement', node, opts);
  }

  function assertDebuggerStatement(node, opts) {
    assert$1('DebuggerStatement', node, opts);
  }

  function assertDoWhileStatement(node, opts) {
    assert$1('DoWhileStatement', node, opts);
  }

  function assertEmptyStatement(node, opts) {
    assert$1('EmptyStatement', node, opts);
  }

  function assertExpressionStatement(node, opts) {
    assert$1('ExpressionStatement', node, opts);
  }

  function assertFile(node, opts) {
    assert$1('File', node, opts);
  }

  function assertForInStatement(node, opts) {
    assert$1('ForInStatement', node, opts);
  }

  function assertForStatement(node, opts) {
    assert$1('ForStatement', node, opts);
  }

  function assertFunctionDeclaration(node, opts) {
    assert$1('FunctionDeclaration', node, opts);
  }

  function assertFunctionExpression(node, opts) {
    assert$1('FunctionExpression', node, opts);
  }

  function assertIdentifier(node, opts) {
    assert$1('Identifier', node, opts);
  }

  function assertIfStatement(node, opts) {
    assert$1('IfStatement', node, opts);
  }

  function assertLabeledStatement(node, opts) {
    assert$1('LabeledStatement', node, opts);
  }

  function assertStringLiteral(node, opts) {
    assert$1('StringLiteral', node, opts);
  }

  function assertNumericLiteral(node, opts) {
    assert$1('NumericLiteral', node, opts);
  }

  function assertNullLiteral(node, opts) {
    assert$1('NullLiteral', node, opts);
  }

  function assertBooleanLiteral(node, opts) {
    assert$1('BooleanLiteral', node, opts);
  }

  function assertRegExpLiteral(node, opts) {
    assert$1('RegExpLiteral', node, opts);
  }

  function assertLogicalExpression(node, opts) {
    assert$1('LogicalExpression', node, opts);
  }

  function assertMemberExpression(node, opts) {
    assert$1('MemberExpression', node, opts);
  }

  function assertNewExpression(node, opts) {
    assert$1('NewExpression', node, opts);
  }

  function assertProgram(node, opts) {
    assert$1('Program', node, opts);
  }

  function assertObjectExpression(node, opts) {
    assert$1('ObjectExpression', node, opts);
  }

  function assertObjectMethod(node, opts) {
    assert$1('ObjectMethod', node, opts);
  }

  function assertObjectProperty(node, opts) {
    assert$1('ObjectProperty', node, opts);
  }

  function assertRestElement(node, opts) {
    assert$1('RestElement', node, opts);
  }

  function assertReturnStatement(node, opts) {
    assert$1('ReturnStatement', node, opts);
  }

  function assertSequenceExpression(node, opts) {
    assert$1('SequenceExpression', node, opts);
  }

  function assertParenthesizedExpression(node, opts) {
    assert$1('ParenthesizedExpression', node, opts);
  }

  function assertSwitchCase(node, opts) {
    assert$1('SwitchCase', node, opts);
  }

  function assertSwitchStatement(node, opts) {
    assert$1('SwitchStatement', node, opts);
  }

  function assertThisExpression(node, opts) {
    assert$1('ThisExpression', node, opts);
  }

  function assertThrowStatement(node, opts) {
    assert$1('ThrowStatement', node, opts);
  }

  function assertTryStatement(node, opts) {
    assert$1('TryStatement', node, opts);
  }

  function assertUnaryExpression(node, opts) {
    assert$1('UnaryExpression', node, opts);
  }

  function assertUpdateExpression(node, opts) {
    assert$1('UpdateExpression', node, opts);
  }

  function assertVariableDeclaration(node, opts) {
    assert$1('VariableDeclaration', node, opts);
  }

  function assertVariableDeclarator(node, opts) {
    assert$1('VariableDeclarator', node, opts);
  }

  function assertWhileStatement(node, opts) {
    assert$1('WhileStatement', node, opts);
  }

  function assertWithStatement(node, opts) {
    assert$1('WithStatement', node, opts);
  }

  function assertAssignmentPattern(node, opts) {
    assert$1('AssignmentPattern', node, opts);
  }

  function assertArrayPattern(node, opts) {
    assert$1('ArrayPattern', node, opts);
  }

  function assertArrowFunctionExpression(node, opts) {
    assert$1('ArrowFunctionExpression', node, opts);
  }

  function assertClassBody(node, opts) {
    assert$1('ClassBody', node, opts);
  }

  function assertClassExpression(node, opts) {
    assert$1('ClassExpression', node, opts);
  }

  function assertClassDeclaration(node, opts) {
    assert$1('ClassDeclaration', node, opts);
  }

  function assertExportAllDeclaration(node, opts) {
    assert$1('ExportAllDeclaration', node, opts);
  }

  function assertExportDefaultDeclaration(node, opts) {
    assert$1('ExportDefaultDeclaration', node, opts);
  }

  function assertExportNamedDeclaration(node, opts) {
    assert$1('ExportNamedDeclaration', node, opts);
  }

  function assertExportSpecifier(node, opts) {
    assert$1('ExportSpecifier', node, opts);
  }

  function assertForOfStatement(node, opts) {
    assert$1('ForOfStatement', node, opts);
  }

  function assertImportDeclaration(node, opts) {
    assert$1('ImportDeclaration', node, opts);
  }

  function assertImportDefaultSpecifier(node, opts) {
    assert$1('ImportDefaultSpecifier', node, opts);
  }

  function assertImportNamespaceSpecifier(node, opts) {
    assert$1('ImportNamespaceSpecifier', node, opts);
  }

  function assertImportSpecifier(node, opts) {
    assert$1('ImportSpecifier', node, opts);
  }

  function assertMetaProperty(node, opts) {
    assert$1('MetaProperty', node, opts);
  }

  function assertClassMethod(node, opts) {
    assert$1('ClassMethod', node, opts);
  }

  function assertObjectPattern(node, opts) {
    assert$1('ObjectPattern', node, opts);
  }

  function assertSpreadElement(node, opts) {
    assert$1('SpreadElement', node, opts);
  }

  function assertSuper(node, opts) {
    assert$1('Super', node, opts);
  }

  function assertTaggedTemplateExpression(node, opts) {
    assert$1('TaggedTemplateExpression', node, opts);
  }

  function assertTemplateElement(node, opts) {
    assert$1('TemplateElement', node, opts);
  }

  function assertTemplateLiteral(node, opts) {
    assert$1('TemplateLiteral', node, opts);
  }

  function assertYieldExpression(node, opts) {
    assert$1('YieldExpression', node, opts);
  }

  function assertAwaitExpression(node, opts) {
    assert$1('AwaitExpression', node, opts);
  }

  function assertImport(node, opts) {
    assert$1('Import', node, opts);
  }

  function assertBigIntLiteral(node, opts) {
    assert$1('BigIntLiteral', node, opts);
  }

  function assertExportNamespaceSpecifier(node, opts) {
    assert$1('ExportNamespaceSpecifier', node, opts);
  }

  function assertOptionalMemberExpression(node, opts) {
    assert$1('OptionalMemberExpression', node, opts);
  }

  function assertOptionalCallExpression(node, opts) {
    assert$1('OptionalCallExpression', node, opts);
  }

  function assertAnyTypeAnnotation(node, opts) {
    assert$1('AnyTypeAnnotation', node, opts);
  }

  function assertArrayTypeAnnotation(node, opts) {
    assert$1('ArrayTypeAnnotation', node, opts);
  }

  function assertBooleanTypeAnnotation(node, opts) {
    assert$1('BooleanTypeAnnotation', node, opts);
  }

  function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert$1('BooleanLiteralTypeAnnotation', node, opts);
  }

  function assertNullLiteralTypeAnnotation(node, opts) {
    assert$1('NullLiteralTypeAnnotation', node, opts);
  }

  function assertClassImplements(node, opts) {
    assert$1('ClassImplements', node, opts);
  }

  function assertDeclareClass(node, opts) {
    assert$1('DeclareClass', node, opts);
  }

  function assertDeclareFunction(node, opts) {
    assert$1('DeclareFunction', node, opts);
  }

  function assertDeclareInterface(node, opts) {
    assert$1('DeclareInterface', node, opts);
  }

  function assertDeclareModule(node, opts) {
    assert$1('DeclareModule', node, opts);
  }

  function assertDeclareModuleExports(node, opts) {
    assert$1('DeclareModuleExports', node, opts);
  }

  function assertDeclareTypeAlias(node, opts) {
    assert$1('DeclareTypeAlias', node, opts);
  }

  function assertDeclareOpaqueType(node, opts) {
    assert$1('DeclareOpaqueType', node, opts);
  }

  function assertDeclareVariable(node, opts) {
    assert$1('DeclareVariable', node, opts);
  }

  function assertDeclareExportDeclaration(node, opts) {
    assert$1('DeclareExportDeclaration', node, opts);
  }

  function assertDeclareExportAllDeclaration(node, opts) {
    assert$1('DeclareExportAllDeclaration', node, opts);
  }

  function assertDeclaredPredicate(node, opts) {
    assert$1('DeclaredPredicate', node, opts);
  }

  function assertExistsTypeAnnotation(node, opts) {
    assert$1('ExistsTypeAnnotation', node, opts);
  }

  function assertFunctionTypeAnnotation(node, opts) {
    assert$1('FunctionTypeAnnotation', node, opts);
  }

  function assertFunctionTypeParam(node, opts) {
    assert$1('FunctionTypeParam', node, opts);
  }

  function assertGenericTypeAnnotation(node, opts) {
    assert$1('GenericTypeAnnotation', node, opts);
  }

  function assertInferredPredicate(node, opts) {
    assert$1('InferredPredicate', node, opts);
  }

  function assertInterfaceExtends(node, opts) {
    assert$1('InterfaceExtends', node, opts);
  }

  function assertInterfaceDeclaration(node, opts) {
    assert$1('InterfaceDeclaration', node, opts);
  }

  function assertInterfaceTypeAnnotation(node, opts) {
    assert$1('InterfaceTypeAnnotation', node, opts);
  }

  function assertIntersectionTypeAnnotation(node, opts) {
    assert$1('IntersectionTypeAnnotation', node, opts);
  }

  function assertMixedTypeAnnotation(node, opts) {
    assert$1('MixedTypeAnnotation', node, opts);
  }

  function assertEmptyTypeAnnotation(node, opts) {
    assert$1('EmptyTypeAnnotation', node, opts);
  }

  function assertNullableTypeAnnotation(node, opts) {
    assert$1('NullableTypeAnnotation', node, opts);
  }

  function assertNumberLiteralTypeAnnotation(node, opts) {
    assert$1('NumberLiteralTypeAnnotation', node, opts);
  }

  function assertNumberTypeAnnotation(node, opts) {
    assert$1('NumberTypeAnnotation', node, opts);
  }

  function assertObjectTypeAnnotation(node, opts) {
    assert$1('ObjectTypeAnnotation', node, opts);
  }

  function assertObjectTypeInternalSlot(node, opts) {
    assert$1('ObjectTypeInternalSlot', node, opts);
  }

  function assertObjectTypeCallProperty(node, opts) {
    assert$1('ObjectTypeCallProperty', node, opts);
  }

  function assertObjectTypeIndexer(node, opts) {
    assert$1('ObjectTypeIndexer', node, opts);
  }

  function assertObjectTypeProperty(node, opts) {
    assert$1('ObjectTypeProperty', node, opts);
  }

  function assertObjectTypeSpreadProperty(node, opts) {
    assert$1('ObjectTypeSpreadProperty', node, opts);
  }

  function assertOpaqueType(node, opts) {
    assert$1('OpaqueType', node, opts);
  }

  function assertQualifiedTypeIdentifier(node, opts) {
    assert$1('QualifiedTypeIdentifier', node, opts);
  }

  function assertStringLiteralTypeAnnotation(node, opts) {
    assert$1('StringLiteralTypeAnnotation', node, opts);
  }

  function assertStringTypeAnnotation(node, opts) {
    assert$1('StringTypeAnnotation', node, opts);
  }

  function assertSymbolTypeAnnotation(node, opts) {
    assert$1('SymbolTypeAnnotation', node, opts);
  }

  function assertThisTypeAnnotation(node, opts) {
    assert$1('ThisTypeAnnotation', node, opts);
  }

  function assertTupleTypeAnnotation(node, opts) {
    assert$1('TupleTypeAnnotation', node, opts);
  }

  function assertTypeofTypeAnnotation(node, opts) {
    assert$1('TypeofTypeAnnotation', node, opts);
  }

  function assertTypeAlias(node, opts) {
    assert$1('TypeAlias', node, opts);
  }

  function assertTypeAnnotation(node, opts) {
    assert$1('TypeAnnotation', node, opts);
  }

  function assertTypeCastExpression(node, opts) {
    assert$1('TypeCastExpression', node, opts);
  }

  function assertTypeParameter(node, opts) {
    assert$1('TypeParameter', node, opts);
  }

  function assertTypeParameterDeclaration(node, opts) {
    assert$1('TypeParameterDeclaration', node, opts);
  }

  function assertTypeParameterInstantiation(node, opts) {
    assert$1('TypeParameterInstantiation', node, opts);
  }

  function assertUnionTypeAnnotation(node, opts) {
    assert$1('UnionTypeAnnotation', node, opts);
  }

  function assertVariance(node, opts) {
    assert$1('Variance', node, opts);
  }

  function assertVoidTypeAnnotation(node, opts) {
    assert$1('VoidTypeAnnotation', node, opts);
  }

  function assertEnumDeclaration(node, opts) {
    assert$1('EnumDeclaration', node, opts);
  }

  function assertEnumBooleanBody(node, opts) {
    assert$1('EnumBooleanBody', node, opts);
  }

  function assertEnumNumberBody(node, opts) {
    assert$1('EnumNumberBody', node, opts);
  }

  function assertEnumStringBody(node, opts) {
    assert$1('EnumStringBody', node, opts);
  }

  function assertEnumSymbolBody(node, opts) {
    assert$1('EnumSymbolBody', node, opts);
  }

  function assertEnumBooleanMember(node, opts) {
    assert$1('EnumBooleanMember', node, opts);
  }

  function assertEnumNumberMember(node, opts) {
    assert$1('EnumNumberMember', node, opts);
  }

  function assertEnumStringMember(node, opts) {
    assert$1('EnumStringMember', node, opts);
  }

  function assertEnumDefaultedMember(node, opts) {
    assert$1('EnumDefaultedMember', node, opts);
  }

  function assertJSXAttribute(node, opts) {
    assert$1('JSXAttribute', node, opts);
  }

  function assertJSXClosingElement(node, opts) {
    assert$1('JSXClosingElement', node, opts);
  }

  function assertJSXElement(node, opts) {
    assert$1('JSXElement', node, opts);
  }

  function assertJSXEmptyExpression(node, opts) {
    assert$1('JSXEmptyExpression', node, opts);
  }

  function assertJSXExpressionContainer(node, opts) {
    assert$1('JSXExpressionContainer', node, opts);
  }

  function assertJSXSpreadChild(node, opts) {
    assert$1('JSXSpreadChild', node, opts);
  }

  function assertJSXIdentifier(node, opts) {
    assert$1('JSXIdentifier', node, opts);
  }

  function assertJSXMemberExpression(node, opts) {
    assert$1('JSXMemberExpression', node, opts);
  }

  function assertJSXNamespacedName(node, opts) {
    assert$1('JSXNamespacedName', node, opts);
  }

  function assertJSXOpeningElement(node, opts) {
    assert$1('JSXOpeningElement', node, opts);
  }

  function assertJSXSpreadAttribute(node, opts) {
    assert$1('JSXSpreadAttribute', node, opts);
  }

  function assertJSXText(node, opts) {
    assert$1('JSXText', node, opts);
  }

  function assertJSXFragment(node, opts) {
    assert$1('JSXFragment', node, opts);
  }

  function assertJSXOpeningFragment(node, opts) {
    assert$1('JSXOpeningFragment', node, opts);
  }

  function assertJSXClosingFragment(node, opts) {
    assert$1('JSXClosingFragment', node, opts);
  }

  function assertNoop(node, opts) {
    assert$1('Noop', node, opts);
  }

  function assertPlaceholder(node, opts) {
    assert$1('Placeholder', node, opts);
  }

  function assertV8IntrinsicIdentifier(node, opts) {
    assert$1('V8IntrinsicIdentifier', node, opts);
  }

  function assertArgumentPlaceholder(node, opts) {
    assert$1('ArgumentPlaceholder', node, opts);
  }

  function assertBindExpression(node, opts) {
    assert$1('BindExpression', node, opts);
  }

  function assertClassProperty(node, opts) {
    assert$1('ClassProperty', node, opts);
  }

  function assertPipelineTopicExpression(node, opts) {
    assert$1('PipelineTopicExpression', node, opts);
  }

  function assertPipelineBareFunction(node, opts) {
    assert$1('PipelineBareFunction', node, opts);
  }

  function assertPipelinePrimaryTopicReference(node, opts) {
    assert$1('PipelinePrimaryTopicReference', node, opts);
  }

  function assertClassPrivateProperty(node, opts) {
    assert$1('ClassPrivateProperty', node, opts);
  }

  function assertClassPrivateMethod(node, opts) {
    assert$1('ClassPrivateMethod', node, opts);
  }

  function assertImportAttribute(node, opts) {
    assert$1('ImportAttribute', node, opts);
  }

  function assertDecorator(node, opts) {
    assert$1('Decorator', node, opts);
  }

  function assertDoExpression(node, opts) {
    assert$1('DoExpression', node, opts);
  }

  function assertExportDefaultSpecifier(node, opts) {
    assert$1('ExportDefaultSpecifier', node, opts);
  }

  function assertPrivateName(node, opts) {
    assert$1('PrivateName', node, opts);
  }

  function assertRecordExpression(node, opts) {
    assert$1('RecordExpression', node, opts);
  }

  function assertTupleExpression(node, opts) {
    assert$1('TupleExpression', node, opts);
  }

  function assertDecimalLiteral(node, opts) {
    assert$1('DecimalLiteral', node, opts);
  }

  function assertStaticBlock(node, opts) {
    assert$1('StaticBlock', node, opts);
  }

  function assertModuleExpression(node, opts) {
    assert$1('ModuleExpression', node, opts);
  }

  function assertTSParameterProperty(node, opts) {
    assert$1('TSParameterProperty', node, opts);
  }

  function assertTSDeclareFunction(node, opts) {
    assert$1('TSDeclareFunction', node, opts);
  }

  function assertTSDeclareMethod(node, opts) {
    assert$1('TSDeclareMethod', node, opts);
  }

  function assertTSQualifiedName(node, opts) {
    assert$1('TSQualifiedName', node, opts);
  }

  function assertTSCallSignatureDeclaration(node, opts) {
    assert$1('TSCallSignatureDeclaration', node, opts);
  }

  function assertTSConstructSignatureDeclaration(node, opts) {
    assert$1('TSConstructSignatureDeclaration', node, opts);
  }

  function assertTSPropertySignature(node, opts) {
    assert$1('TSPropertySignature', node, opts);
  }

  function assertTSMethodSignature(node, opts) {
    assert$1('TSMethodSignature', node, opts);
  }

  function assertTSIndexSignature(node, opts) {
    assert$1('TSIndexSignature', node, opts);
  }

  function assertTSAnyKeyword(node, opts) {
    assert$1('TSAnyKeyword', node, opts);
  }

  function assertTSBooleanKeyword(node, opts) {
    assert$1('TSBooleanKeyword', node, opts);
  }

  function assertTSBigIntKeyword(node, opts) {
    assert$1('TSBigIntKeyword', node, opts);
  }

  function assertTSIntrinsicKeyword(node, opts) {
    assert$1('TSIntrinsicKeyword', node, opts);
  }

  function assertTSNeverKeyword(node, opts) {
    assert$1('TSNeverKeyword', node, opts);
  }

  function assertTSNullKeyword(node, opts) {
    assert$1('TSNullKeyword', node, opts);
  }

  function assertTSNumberKeyword(node, opts) {
    assert$1('TSNumberKeyword', node, opts);
  }

  function assertTSObjectKeyword(node, opts) {
    assert$1('TSObjectKeyword', node, opts);
  }

  function assertTSStringKeyword(node, opts) {
    assert$1('TSStringKeyword', node, opts);
  }

  function assertTSSymbolKeyword(node, opts) {
    assert$1('TSSymbolKeyword', node, opts);
  }

  function assertTSUndefinedKeyword(node, opts) {
    assert$1('TSUndefinedKeyword', node, opts);
  }

  function assertTSUnknownKeyword(node, opts) {
    assert$1('TSUnknownKeyword', node, opts);
  }

  function assertTSVoidKeyword(node, opts) {
    assert$1('TSVoidKeyword', node, opts);
  }

  function assertTSThisType(node, opts) {
    assert$1('TSThisType', node, opts);
  }

  function assertTSFunctionType(node, opts) {
    assert$1('TSFunctionType', node, opts);
  }

  function assertTSConstructorType(node, opts) {
    assert$1('TSConstructorType', node, opts);
  }

  function assertTSTypeReference(node, opts) {
    assert$1('TSTypeReference', node, opts);
  }

  function assertTSTypePredicate(node, opts) {
    assert$1('TSTypePredicate', node, opts);
  }

  function assertTSTypeQuery(node, opts) {
    assert$1('TSTypeQuery', node, opts);
  }

  function assertTSTypeLiteral(node, opts) {
    assert$1('TSTypeLiteral', node, opts);
  }

  function assertTSArrayType(node, opts) {
    assert$1('TSArrayType', node, opts);
  }

  function assertTSTupleType(node, opts) {
    assert$1('TSTupleType', node, opts);
  }

  function assertTSOptionalType(node, opts) {
    assert$1('TSOptionalType', node, opts);
  }

  function assertTSRestType(node, opts) {
    assert$1('TSRestType', node, opts);
  }

  function assertTSNamedTupleMember(node, opts) {
    assert$1('TSNamedTupleMember', node, opts);
  }

  function assertTSUnionType(node, opts) {
    assert$1('TSUnionType', node, opts);
  }

  function assertTSIntersectionType(node, opts) {
    assert$1('TSIntersectionType', node, opts);
  }

  function assertTSConditionalType(node, opts) {
    assert$1('TSConditionalType', node, opts);
  }

  function assertTSInferType(node, opts) {
    assert$1('TSInferType', node, opts);
  }

  function assertTSParenthesizedType(node, opts) {
    assert$1('TSParenthesizedType', node, opts);
  }

  function assertTSTypeOperator(node, opts) {
    assert$1('TSTypeOperator', node, opts);
  }

  function assertTSIndexedAccessType(node, opts) {
    assert$1('TSIndexedAccessType', node, opts);
  }

  function assertTSMappedType(node, opts) {
    assert$1('TSMappedType', node, opts);
  }

  function assertTSLiteralType(node, opts) {
    assert$1('TSLiteralType', node, opts);
  }

  function assertTSExpressionWithTypeArguments(node, opts) {
    assert$1('TSExpressionWithTypeArguments', node, opts);
  }

  function assertTSInterfaceDeclaration(node, opts) {
    assert$1('TSInterfaceDeclaration', node, opts);
  }

  function assertTSInterfaceBody(node, opts) {
    assert$1('TSInterfaceBody', node, opts);
  }

  function assertTSTypeAliasDeclaration(node, opts) {
    assert$1('TSTypeAliasDeclaration', node, opts);
  }

  function assertTSAsExpression(node, opts) {
    assert$1('TSAsExpression', node, opts);
  }

  function assertTSTypeAssertion(node, opts) {
    assert$1('TSTypeAssertion', node, opts);
  }

  function assertTSEnumDeclaration(node, opts) {
    assert$1('TSEnumDeclaration', node, opts);
  }

  function assertTSEnumMember(node, opts) {
    assert$1('TSEnumMember', node, opts);
  }

  function assertTSModuleDeclaration(node, opts) {
    assert$1('TSModuleDeclaration', node, opts);
  }

  function assertTSModuleBlock(node, opts) {
    assert$1('TSModuleBlock', node, opts);
  }

  function assertTSImportType(node, opts) {
    assert$1('TSImportType', node, opts);
  }

  function assertTSImportEqualsDeclaration(node, opts) {
    assert$1('TSImportEqualsDeclaration', node, opts);
  }

  function assertTSExternalModuleReference(node, opts) {
    assert$1('TSExternalModuleReference', node, opts);
  }

  function assertTSNonNullExpression(node, opts) {
    assert$1('TSNonNullExpression', node, opts);
  }

  function assertTSExportAssignment(node, opts) {
    assert$1('TSExportAssignment', node, opts);
  }

  function assertTSNamespaceExportDeclaration(node, opts) {
    assert$1('TSNamespaceExportDeclaration', node, opts);
  }

  function assertTSTypeAnnotation(node, opts) {
    assert$1('TSTypeAnnotation', node, opts);
  }

  function assertTSTypeParameterInstantiation(node, opts) {
    assert$1('TSTypeParameterInstantiation', node, opts);
  }

  function assertTSTypeParameterDeclaration(node, opts) {
    assert$1('TSTypeParameterDeclaration', node, opts);
  }

  function assertTSTypeParameter(node, opts) {
    assert$1('TSTypeParameter', node, opts);
  }

  function assertExpression(node, opts) {
    assert$1('Expression', node, opts);
  }

  function assertBinary(node, opts) {
    assert$1('Binary', node, opts);
  }

  function assertScopable(node, opts) {
    assert$1('Scopable', node, opts);
  }

  function assertBlockParent(node, opts) {
    assert$1('BlockParent', node, opts);
  }

  function assertBlock(node, opts) {
    assert$1('Block', node, opts);
  }

  function assertStatement(node, opts) {
    assert$1('Statement', node, opts);
  }

  function assertTerminatorless(node, opts) {
    assert$1('Terminatorless', node, opts);
  }

  function assertCompletionStatement(node, opts) {
    assert$1('CompletionStatement', node, opts);
  }

  function assertConditional(node, opts) {
    assert$1('Conditional', node, opts);
  }

  function assertLoop(node, opts) {
    assert$1('Loop', node, opts);
  }

  function assertWhile(node, opts) {
    assert$1('While', node, opts);
  }

  function assertExpressionWrapper(node, opts) {
    assert$1('ExpressionWrapper', node, opts);
  }

  function assertFor(node, opts) {
    assert$1('For', node, opts);
  }

  function assertForXStatement(node, opts) {
    assert$1('ForXStatement', node, opts);
  }

  function assertFunction(node, opts) {
    assert$1('Function', node, opts);
  }

  function assertFunctionParent(node, opts) {
    assert$1('FunctionParent', node, opts);
  }

  function assertPureish(node, opts) {
    assert$1('Pureish', node, opts);
  }

  function assertDeclaration(node, opts) {
    assert$1('Declaration', node, opts);
  }

  function assertPatternLike(node, opts) {
    assert$1('PatternLike', node, opts);
  }

  function assertLVal(node, opts) {
    assert$1('LVal', node, opts);
  }

  function assertTSEntityName(node, opts) {
    assert$1('TSEntityName', node, opts);
  }

  function assertLiteral(node, opts) {
    assert$1('Literal', node, opts);
  }

  function assertImmutable(node, opts) {
    assert$1('Immutable', node, opts);
  }

  function assertUserWhitespacable(node, opts) {
    assert$1('UserWhitespacable', node, opts);
  }

  function assertMethod(node, opts) {
    assert$1('Method', node, opts);
  }

  function assertObjectMember(node, opts) {
    assert$1('ObjectMember', node, opts);
  }

  function assertProperty(node, opts) {
    assert$1('Property', node, opts);
  }

  function assertUnaryLike(node, opts) {
    assert$1('UnaryLike', node, opts);
  }

  function assertPattern(node, opts) {
    assert$1('Pattern', node, opts);
  }

  function assertClass(node, opts) {
    assert$1('Class', node, opts);
  }

  function assertModuleDeclaration(node, opts) {
    assert$1('ModuleDeclaration', node, opts);
  }

  function assertExportDeclaration(node, opts) {
    assert$1('ExportDeclaration', node, opts);
  }

  function assertModuleSpecifier(node, opts) {
    assert$1('ModuleSpecifier', node, opts);
  }

  function assertFlow(node, opts) {
    assert$1('Flow', node, opts);
  }

  function assertFlowType(node, opts) {
    assert$1('FlowType', node, opts);
  }

  function assertFlowBaseAnnotation(node, opts) {
    assert$1('FlowBaseAnnotation', node, opts);
  }

  function assertFlowDeclaration(node, opts) {
    assert$1('FlowDeclaration', node, opts);
  }

  function assertFlowPredicate(node, opts) {
    assert$1('FlowPredicate', node, opts);
  }

  function assertEnumBody(node, opts) {
    assert$1('EnumBody', node, opts);
  }

  function assertEnumMember(node, opts) {
    assert$1('EnumMember', node, opts);
  }

  function assertJSX(node, opts) {
    assert$1('JSX', node, opts);
  }

  function assertPrivate(node, opts) {
    assert$1('Private', node, opts);
  }

  function assertTSTypeElement(node, opts) {
    assert$1('TSTypeElement', node, opts);
  }

  function assertTSType(node, opts) {
    assert$1('TSType', node, opts);
  }

  function assertTSBaseType(node, opts) {
    assert$1('TSBaseType', node, opts);
  }

  function assertNumberLiteral(node, opts) {
    console.trace(
      'The node type NumberLiteral has been renamed to NumericLiteral',
    );
    assert$1('NumberLiteral', node, opts);
  }

  function assertRegexLiteral(node, opts) {
    console.trace(
      'The node type RegexLiteral has been renamed to RegExpLiteral',
    );
    assert$1('RegexLiteral', node, opts);
  }

  function assertRestProperty(node, opts) {
    console.trace('The node type RestProperty has been renamed to RestElement');
    assert$1('RestProperty', node, opts);
  }

  function assertSpreadProperty(node, opts) {
    console.trace(
      'The node type SpreadProperty has been renamed to SpreadElement',
    );
    assert$1('SpreadProperty', node, opts);
  }

  var generated$2 = /*#__PURE__*/ Object.defineProperty(
    {
      assertArrayExpression: assertArrayExpression_1,
      assertAssignmentExpression: assertAssignmentExpression_1,
      assertBinaryExpression: assertBinaryExpression_1,
      assertInterpreterDirective: assertInterpreterDirective_1,
      assertDirective: assertDirective_1,
      assertDirectiveLiteral: assertDirectiveLiteral_1,
      assertBlockStatement: assertBlockStatement_1,
      assertBreakStatement: assertBreakStatement_1,
      assertCallExpression: assertCallExpression_1,
      assertCatchClause: assertCatchClause_1,
      assertConditionalExpression: assertConditionalExpression_1,
      assertContinueStatement: assertContinueStatement_1,
      assertDebuggerStatement: assertDebuggerStatement_1,
      assertDoWhileStatement: assertDoWhileStatement_1,
      assertEmptyStatement: assertEmptyStatement_1,
      assertExpressionStatement: assertExpressionStatement_1,
      assertFile: assertFile_1,
      assertForInStatement: assertForInStatement_1,
      assertForStatement: assertForStatement_1,
      assertFunctionDeclaration: assertFunctionDeclaration_1,
      assertFunctionExpression: assertFunctionExpression_1,
      assertIdentifier: assertIdentifier_1,
      assertIfStatement: assertIfStatement_1,
      assertLabeledStatement: assertLabeledStatement_1,
      assertStringLiteral: assertStringLiteral_1,
      assertNumericLiteral: assertNumericLiteral_1,
      assertNullLiteral: assertNullLiteral_1,
      assertBooleanLiteral: assertBooleanLiteral_1,
      assertRegExpLiteral: assertRegExpLiteral_1,
      assertLogicalExpression: assertLogicalExpression_1,
      assertMemberExpression: assertMemberExpression_1,
      assertNewExpression: assertNewExpression_1,
      assertProgram: assertProgram_1,
      assertObjectExpression: assertObjectExpression_1,
      assertObjectMethod: assertObjectMethod_1,
      assertObjectProperty: assertObjectProperty_1,
      assertRestElement: assertRestElement_1,
      assertReturnStatement: assertReturnStatement_1,
      assertSequenceExpression: assertSequenceExpression_1,
      assertParenthesizedExpression: assertParenthesizedExpression_1,
      assertSwitchCase: assertSwitchCase_1,
      assertSwitchStatement: assertSwitchStatement_1,
      assertThisExpression: assertThisExpression_1,
      assertThrowStatement: assertThrowStatement_1,
      assertTryStatement: assertTryStatement_1,
      assertUnaryExpression: assertUnaryExpression_1,
      assertUpdateExpression: assertUpdateExpression_1,
      assertVariableDeclaration: assertVariableDeclaration_1,
      assertVariableDeclarator: assertVariableDeclarator_1,
      assertWhileStatement: assertWhileStatement_1,
      assertWithStatement: assertWithStatement_1,
      assertAssignmentPattern: assertAssignmentPattern_1,
      assertArrayPattern: assertArrayPattern_1,
      assertArrowFunctionExpression: assertArrowFunctionExpression_1,
      assertClassBody: assertClassBody_1,
      assertClassExpression: assertClassExpression_1,
      assertClassDeclaration: assertClassDeclaration_1,
      assertExportAllDeclaration: assertExportAllDeclaration_1,
      assertExportDefaultDeclaration: assertExportDefaultDeclaration_1,
      assertExportNamedDeclaration: assertExportNamedDeclaration_1,
      assertExportSpecifier: assertExportSpecifier_1,
      assertForOfStatement: assertForOfStatement_1,
      assertImportDeclaration: assertImportDeclaration_1,
      assertImportDefaultSpecifier: assertImportDefaultSpecifier_1,
      assertImportNamespaceSpecifier: assertImportNamespaceSpecifier_1,
      assertImportSpecifier: assertImportSpecifier_1,
      assertMetaProperty: assertMetaProperty_1,
      assertClassMethod: assertClassMethod_1,
      assertObjectPattern: assertObjectPattern_1,
      assertSpreadElement: assertSpreadElement_1,
      assertSuper: assertSuper_1,
      assertTaggedTemplateExpression: assertTaggedTemplateExpression_1,
      assertTemplateElement: assertTemplateElement_1,
      assertTemplateLiteral: assertTemplateLiteral_1,
      assertYieldExpression: assertYieldExpression_1,
      assertAwaitExpression: assertAwaitExpression_1,
      assertImport: assertImport_1,
      assertBigIntLiteral: assertBigIntLiteral_1,
      assertExportNamespaceSpecifier: assertExportNamespaceSpecifier_1,
      assertOptionalMemberExpression: assertOptionalMemberExpression_1,
      assertOptionalCallExpression: assertOptionalCallExpression_1,
      assertAnyTypeAnnotation: assertAnyTypeAnnotation_1,
      assertArrayTypeAnnotation: assertArrayTypeAnnotation_1,
      assertBooleanTypeAnnotation: assertBooleanTypeAnnotation_1,
      assertBooleanLiteralTypeAnnotation: assertBooleanLiteralTypeAnnotation_1,
      assertNullLiteralTypeAnnotation: assertNullLiteralTypeAnnotation_1,
      assertClassImplements: assertClassImplements_1,
      assertDeclareClass: assertDeclareClass_1,
      assertDeclareFunction: assertDeclareFunction_1,
      assertDeclareInterface: assertDeclareInterface_1,
      assertDeclareModule: assertDeclareModule_1,
      assertDeclareModuleExports: assertDeclareModuleExports_1,
      assertDeclareTypeAlias: assertDeclareTypeAlias_1,
      assertDeclareOpaqueType: assertDeclareOpaqueType_1,
      assertDeclareVariable: assertDeclareVariable_1,
      assertDeclareExportDeclaration: assertDeclareExportDeclaration_1,
      assertDeclareExportAllDeclaration: assertDeclareExportAllDeclaration_1,
      assertDeclaredPredicate: assertDeclaredPredicate_1,
      assertExistsTypeAnnotation: assertExistsTypeAnnotation_1,
      assertFunctionTypeAnnotation: assertFunctionTypeAnnotation_1,
      assertFunctionTypeParam: assertFunctionTypeParam_1,
      assertGenericTypeAnnotation: assertGenericTypeAnnotation_1,
      assertInferredPredicate: assertInferredPredicate_1,
      assertInterfaceExtends: assertInterfaceExtends_1,
      assertInterfaceDeclaration: assertInterfaceDeclaration_1,
      assertInterfaceTypeAnnotation: assertInterfaceTypeAnnotation_1,
      assertIntersectionTypeAnnotation: assertIntersectionTypeAnnotation_1,
      assertMixedTypeAnnotation: assertMixedTypeAnnotation_1,
      assertEmptyTypeAnnotation: assertEmptyTypeAnnotation_1,
      assertNullableTypeAnnotation: assertNullableTypeAnnotation_1,
      assertNumberLiteralTypeAnnotation: assertNumberLiteralTypeAnnotation_1,
      assertNumberTypeAnnotation: assertNumberTypeAnnotation_1,
      assertObjectTypeAnnotation: assertObjectTypeAnnotation_1,
      assertObjectTypeInternalSlot: assertObjectTypeInternalSlot_1,
      assertObjectTypeCallProperty: assertObjectTypeCallProperty_1,
      assertObjectTypeIndexer: assertObjectTypeIndexer_1,
      assertObjectTypeProperty: assertObjectTypeProperty_1,
      assertObjectTypeSpreadProperty: assertObjectTypeSpreadProperty_1,
      assertOpaqueType: assertOpaqueType_1,
      assertQualifiedTypeIdentifier: assertQualifiedTypeIdentifier_1,
      assertStringLiteralTypeAnnotation: assertStringLiteralTypeAnnotation_1,
      assertStringTypeAnnotation: assertStringTypeAnnotation_1,
      assertSymbolTypeAnnotation: assertSymbolTypeAnnotation_1,
      assertThisTypeAnnotation: assertThisTypeAnnotation_1,
      assertTupleTypeAnnotation: assertTupleTypeAnnotation_1,
      assertTypeofTypeAnnotation: assertTypeofTypeAnnotation_1,
      assertTypeAlias: assertTypeAlias_1,
      assertTypeAnnotation: assertTypeAnnotation_1,
      assertTypeCastExpression: assertTypeCastExpression_1,
      assertTypeParameter: assertTypeParameter_1,
      assertTypeParameterDeclaration: assertTypeParameterDeclaration_1,
      assertTypeParameterInstantiation: assertTypeParameterInstantiation_1,
      assertUnionTypeAnnotation: assertUnionTypeAnnotation_1,
      assertVariance: assertVariance_1,
      assertVoidTypeAnnotation: assertVoidTypeAnnotation_1,
      assertEnumDeclaration: assertEnumDeclaration_1,
      assertEnumBooleanBody: assertEnumBooleanBody_1,
      assertEnumNumberBody: assertEnumNumberBody_1,
      assertEnumStringBody: assertEnumStringBody_1,
      assertEnumSymbolBody: assertEnumSymbolBody_1,
      assertEnumBooleanMember: assertEnumBooleanMember_1,
      assertEnumNumberMember: assertEnumNumberMember_1,
      assertEnumStringMember: assertEnumStringMember_1,
      assertEnumDefaultedMember: assertEnumDefaultedMember_1,
      assertJSXAttribute: assertJSXAttribute_1,
      assertJSXClosingElement: assertJSXClosingElement_1,
      assertJSXElement: assertJSXElement_1,
      assertJSXEmptyExpression: assertJSXEmptyExpression_1,
      assertJSXExpressionContainer: assertJSXExpressionContainer_1,
      assertJSXSpreadChild: assertJSXSpreadChild_1,
      assertJSXIdentifier: assertJSXIdentifier_1,
      assertJSXMemberExpression: assertJSXMemberExpression_1,
      assertJSXNamespacedName: assertJSXNamespacedName_1,
      assertJSXOpeningElement: assertJSXOpeningElement_1,
      assertJSXSpreadAttribute: assertJSXSpreadAttribute_1,
      assertJSXText: assertJSXText_1,
      assertJSXFragment: assertJSXFragment_1,
      assertJSXOpeningFragment: assertJSXOpeningFragment_1,
      assertJSXClosingFragment: assertJSXClosingFragment_1,
      assertNoop: assertNoop_1,
      assertPlaceholder: assertPlaceholder_1,
      assertV8IntrinsicIdentifier: assertV8IntrinsicIdentifier_1,
      assertArgumentPlaceholder: assertArgumentPlaceholder_1,
      assertBindExpression: assertBindExpression_1,
      assertClassProperty: assertClassProperty_1,
      assertPipelineTopicExpression: assertPipelineTopicExpression_1,
      assertPipelineBareFunction: assertPipelineBareFunction_1,
      assertPipelinePrimaryTopicReference: assertPipelinePrimaryTopicReference_1,
      assertClassPrivateProperty: assertClassPrivateProperty_1,
      assertClassPrivateMethod: assertClassPrivateMethod_1,
      assertImportAttribute: assertImportAttribute_1,
      assertDecorator: assertDecorator_1,
      assertDoExpression: assertDoExpression_1,
      assertExportDefaultSpecifier: assertExportDefaultSpecifier_1,
      assertPrivateName: assertPrivateName_1,
      assertRecordExpression: assertRecordExpression_1,
      assertTupleExpression: assertTupleExpression_1,
      assertDecimalLiteral: assertDecimalLiteral_1,
      assertStaticBlock: assertStaticBlock_1,
      assertModuleExpression: assertModuleExpression_1,
      assertTSParameterProperty: assertTSParameterProperty_1,
      assertTSDeclareFunction: assertTSDeclareFunction_1,
      assertTSDeclareMethod: assertTSDeclareMethod_1,
      assertTSQualifiedName: assertTSQualifiedName_1,
      assertTSCallSignatureDeclaration: assertTSCallSignatureDeclaration_1,
      assertTSConstructSignatureDeclaration: assertTSConstructSignatureDeclaration_1,
      assertTSPropertySignature: assertTSPropertySignature_1,
      assertTSMethodSignature: assertTSMethodSignature_1,
      assertTSIndexSignature: assertTSIndexSignature_1,
      assertTSAnyKeyword: assertTSAnyKeyword_1,
      assertTSBooleanKeyword: assertTSBooleanKeyword_1,
      assertTSBigIntKeyword: assertTSBigIntKeyword_1,
      assertTSIntrinsicKeyword: assertTSIntrinsicKeyword_1,
      assertTSNeverKeyword: assertTSNeverKeyword_1,
      assertTSNullKeyword: assertTSNullKeyword_1,
      assertTSNumberKeyword: assertTSNumberKeyword_1,
      assertTSObjectKeyword: assertTSObjectKeyword_1,
      assertTSStringKeyword: assertTSStringKeyword_1,
      assertTSSymbolKeyword: assertTSSymbolKeyword_1,
      assertTSUndefinedKeyword: assertTSUndefinedKeyword_1,
      assertTSUnknownKeyword: assertTSUnknownKeyword_1,
      assertTSVoidKeyword: assertTSVoidKeyword_1,
      assertTSThisType: assertTSThisType_1,
      assertTSFunctionType: assertTSFunctionType_1,
      assertTSConstructorType: assertTSConstructorType_1,
      assertTSTypeReference: assertTSTypeReference_1,
      assertTSTypePredicate: assertTSTypePredicate_1,
      assertTSTypeQuery: assertTSTypeQuery_1,
      assertTSTypeLiteral: assertTSTypeLiteral_1,
      assertTSArrayType: assertTSArrayType_1,
      assertTSTupleType: assertTSTupleType_1,
      assertTSOptionalType: assertTSOptionalType_1,
      assertTSRestType: assertTSRestType_1,
      assertTSNamedTupleMember: assertTSNamedTupleMember_1,
      assertTSUnionType: assertTSUnionType_1,
      assertTSIntersectionType: assertTSIntersectionType_1,
      assertTSConditionalType: assertTSConditionalType_1,
      assertTSInferType: assertTSInferType_1,
      assertTSParenthesizedType: assertTSParenthesizedType_1,
      assertTSTypeOperator: assertTSTypeOperator_1,
      assertTSIndexedAccessType: assertTSIndexedAccessType_1,
      assertTSMappedType: assertTSMappedType_1,
      assertTSLiteralType: assertTSLiteralType_1,
      assertTSExpressionWithTypeArguments: assertTSExpressionWithTypeArguments_1,
      assertTSInterfaceDeclaration: assertTSInterfaceDeclaration_1,
      assertTSInterfaceBody: assertTSInterfaceBody_1,
      assertTSTypeAliasDeclaration: assertTSTypeAliasDeclaration_1,
      assertTSAsExpression: assertTSAsExpression_1,
      assertTSTypeAssertion: assertTSTypeAssertion_1,
      assertTSEnumDeclaration: assertTSEnumDeclaration_1,
      assertTSEnumMember: assertTSEnumMember_1,
      assertTSModuleDeclaration: assertTSModuleDeclaration_1,
      assertTSModuleBlock: assertTSModuleBlock_1,
      assertTSImportType: assertTSImportType_1,
      assertTSImportEqualsDeclaration: assertTSImportEqualsDeclaration_1,
      assertTSExternalModuleReference: assertTSExternalModuleReference_1,
      assertTSNonNullExpression: assertTSNonNullExpression_1,
      assertTSExportAssignment: assertTSExportAssignment_1,
      assertTSNamespaceExportDeclaration: assertTSNamespaceExportDeclaration_1,
      assertTSTypeAnnotation: assertTSTypeAnnotation_1,
      assertTSTypeParameterInstantiation: assertTSTypeParameterInstantiation_1,
      assertTSTypeParameterDeclaration: assertTSTypeParameterDeclaration_1,
      assertTSTypeParameter: assertTSTypeParameter_1,
      assertExpression: assertExpression_1,
      assertBinary: assertBinary_1,
      assertScopable: assertScopable_1,
      assertBlockParent: assertBlockParent_1,
      assertBlock: assertBlock_1,
      assertStatement: assertStatement_1,
      assertTerminatorless: assertTerminatorless_1,
      assertCompletionStatement: assertCompletionStatement_1,
      assertConditional: assertConditional_1,
      assertLoop: assertLoop_1,
      assertWhile: assertWhile_1,
      assertExpressionWrapper: assertExpressionWrapper_1,
      assertFor: assertFor_1,
      assertForXStatement: assertForXStatement_1,
      assertFunction: assertFunction_1,
      assertFunctionParent: assertFunctionParent_1,
      assertPureish: assertPureish_1,
      assertDeclaration: assertDeclaration_1,
      assertPatternLike: assertPatternLike_1,
      assertLVal: assertLVal_1,
      assertTSEntityName: assertTSEntityName_1,
      assertLiteral: assertLiteral_1,
      assertImmutable: assertImmutable_1,
      assertUserWhitespacable: assertUserWhitespacable_1,
      assertMethod: assertMethod_1,
      assertObjectMember: assertObjectMember_1,
      assertProperty: assertProperty_1,
      assertUnaryLike: assertUnaryLike_1,
      assertPattern: assertPattern_1,
      assertClass: assertClass_1,
      assertModuleDeclaration: assertModuleDeclaration_1,
      assertExportDeclaration: assertExportDeclaration_1,
      assertModuleSpecifier: assertModuleSpecifier_1,
      assertFlow: assertFlow_1,
      assertFlowType: assertFlowType_1,
      assertFlowBaseAnnotation: assertFlowBaseAnnotation_1,
      assertFlowDeclaration: assertFlowDeclaration_1,
      assertFlowPredicate: assertFlowPredicate_1,
      assertEnumBody: assertEnumBody_1,
      assertEnumMember: assertEnumMember_1,
      assertJSX: assertJSX_1,
      assertPrivate: assertPrivate_1,
      assertTSTypeElement: assertTSTypeElement_1,
      assertTSType: assertTSType_1,
      assertTSBaseType: assertTSBaseType_1,
      assertNumberLiteral: assertNumberLiteral_1,
      assertRegexLiteral: assertRegexLiteral_1,
      assertRestProperty: assertRestProperty_1,
      assertSpreadProperty: assertSpreadProperty_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$e = createTypeAnnotationBasedOnTypeof;

  function createTypeAnnotationBasedOnTypeof(type) {
    if (type === 'string') {
      return (0, generated$1.stringTypeAnnotation)();
    } else if (type === 'number') {
      return (0, generated$1.numberTypeAnnotation)();
    } else if (type === 'undefined') {
      return (0, generated$1.voidTypeAnnotation)();
    } else if (type === 'boolean') {
      return (0, generated$1.booleanTypeAnnotation)();
    } else if (type === 'function') {
      return (0, generated$1.genericTypeAnnotation)(
        (0, generated$1.identifier)('Function'),
      );
    } else if (type === 'object') {
      return (0, generated$1.genericTypeAnnotation)(
        (0, generated$1.identifier)('Object'),
      );
    } else if (type === 'symbol') {
      return (0, generated$1.genericTypeAnnotation)(
        (0, generated$1.identifier)('Symbol'),
      );
    } else if (type === 'bigint') {
      return (0, generated$1.anyTypeAnnotation)();
    } else {
      throw new Error('Invalid typeof value: ' + type);
    }
  }

  var createTypeAnnotationBasedOnTypeof_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$e,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$f = removeTypeDuplicates;

  function getQualifiedName(node) {
    return (0, generated.isIdentifier)(node)
      ? node.name
      : `${node.id.name}.${getQualifiedName(node.qualification)}`;
  }

  function removeTypeDuplicates(nodes) {
    const generics = {};
    const bases = {};
    const typeGroups = [];
    const types = [];

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if ((0, generated.isAnyTypeAnnotation)(node)) {
        return [node];
      }

      if ((0, generated.isFlowBaseAnnotation)(node)) {
        bases[node.type] = node;
        continue;
      }

      if ((0, generated.isUnionTypeAnnotation)(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      if ((0, generated.isGenericTypeAnnotation)(node)) {
        const name = getQualifiedName(node.id);

        if (generics[name]) {
          let existing = generics[name];

          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params = removeTypeDuplicates(
                existing.typeParameters.params.concat(
                  node.typeParameters.params,
                ),
              );
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics[name] = node;
        }

        continue;
      }

      types.push(node);
    }

    for (const type of Object.keys(bases)) {
      types.push(bases[type]);
    }

    for (const name of Object.keys(generics)) {
      types.push(generics[name]);
    }

    return types;
  }

  var removeTypeDuplicates_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$f,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$g = createFlowUnionType;

  var _removeTypeDuplicates = _interopRequireDefault$7(removeTypeDuplicates_1);

  function _interopRequireDefault$7(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function createFlowUnionType(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, generated$1.unionTypeAnnotation)(flattened);
    }
  }

  var createFlowUnionType_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$g,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$h = removeTypeDuplicates$1;

  function removeTypeDuplicates$1(nodes) {
    const generics = {};
    const bases = {};
    const typeGroups = [];
    const types = [];

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if ((0, generated.isTSAnyKeyword)(node)) {
        return [node];
      }

      if ((0, generated.isTSBaseType)(node)) {
        bases[node.type] = node;
        continue;
      }

      if ((0, generated.isTSUnionType)(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      types.push(node);
    }

    for (const type of Object.keys(bases)) {
      types.push(bases[type]);
    }

    for (const name of Object.keys(generics)) {
      types.push(generics[name]);
    }

    return types;
  }

  var removeTypeDuplicates_1$1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$h,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$i = createTSUnionType;

  var _removeTypeDuplicates$1 = _interopRequireDefault$8(
    removeTypeDuplicates_1$1,
  );

  function _interopRequireDefault$8(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function createTSUnionType(typeAnnotations) {
    const types = typeAnnotations.map((type) => type.typeAnnotation);
    const flattened = (0, _removeTypeDuplicates$1.default)(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, generated$1.tsUnionType)(flattened);
    }
  }

  var createTSUnionType_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$i,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var uppercase = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'ArrayExpression', {
      enumerable: true,
      get: function () {
        return generated$1.arrayExpression;
      },
    });
    Object.defineProperty(exports, 'AssignmentExpression', {
      enumerable: true,
      get: function () {
        return generated$1.assignmentExpression;
      },
    });
    Object.defineProperty(exports, 'BinaryExpression', {
      enumerable: true,
      get: function () {
        return generated$1.binaryExpression;
      },
    });
    Object.defineProperty(exports, 'InterpreterDirective', {
      enumerable: true,
      get: function () {
        return generated$1.interpreterDirective;
      },
    });
    Object.defineProperty(exports, 'Directive', {
      enumerable: true,
      get: function () {
        return generated$1.directive;
      },
    });
    Object.defineProperty(exports, 'DirectiveLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.directiveLiteral;
      },
    });
    Object.defineProperty(exports, 'BlockStatement', {
      enumerable: true,
      get: function () {
        return generated$1.blockStatement;
      },
    });
    Object.defineProperty(exports, 'BreakStatement', {
      enumerable: true,
      get: function () {
        return generated$1.breakStatement;
      },
    });
    Object.defineProperty(exports, 'CallExpression', {
      enumerable: true,
      get: function () {
        return generated$1.callExpression;
      },
    });
    Object.defineProperty(exports, 'CatchClause', {
      enumerable: true,
      get: function () {
        return generated$1.catchClause;
      },
    });
    Object.defineProperty(exports, 'ConditionalExpression', {
      enumerable: true,
      get: function () {
        return generated$1.conditionalExpression;
      },
    });
    Object.defineProperty(exports, 'ContinueStatement', {
      enumerable: true,
      get: function () {
        return generated$1.continueStatement;
      },
    });
    Object.defineProperty(exports, 'DebuggerStatement', {
      enumerable: true,
      get: function () {
        return generated$1.debuggerStatement;
      },
    });
    Object.defineProperty(exports, 'DoWhileStatement', {
      enumerable: true,
      get: function () {
        return generated$1.doWhileStatement;
      },
    });
    Object.defineProperty(exports, 'EmptyStatement', {
      enumerable: true,
      get: function () {
        return generated$1.emptyStatement;
      },
    });
    Object.defineProperty(exports, 'ExpressionStatement', {
      enumerable: true,
      get: function () {
        return generated$1.expressionStatement;
      },
    });
    Object.defineProperty(exports, 'File', {
      enumerable: true,
      get: function () {
        return generated$1.file;
      },
    });
    Object.defineProperty(exports, 'ForInStatement', {
      enumerable: true,
      get: function () {
        return generated$1.forInStatement;
      },
    });
    Object.defineProperty(exports, 'ForStatement', {
      enumerable: true,
      get: function () {
        return generated$1.forStatement;
      },
    });
    Object.defineProperty(exports, 'FunctionDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.functionDeclaration;
      },
    });
    Object.defineProperty(exports, 'FunctionExpression', {
      enumerable: true,
      get: function () {
        return generated$1.functionExpression;
      },
    });
    Object.defineProperty(exports, 'Identifier', {
      enumerable: true,
      get: function () {
        return generated$1.identifier;
      },
    });
    Object.defineProperty(exports, 'IfStatement', {
      enumerable: true,
      get: function () {
        return generated$1.ifStatement;
      },
    });
    Object.defineProperty(exports, 'LabeledStatement', {
      enumerable: true,
      get: function () {
        return generated$1.labeledStatement;
      },
    });
    Object.defineProperty(exports, 'StringLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.stringLiteral;
      },
    });
    Object.defineProperty(exports, 'NumericLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.numericLiteral;
      },
    });
    Object.defineProperty(exports, 'NullLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.nullLiteral;
      },
    });
    Object.defineProperty(exports, 'BooleanLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.booleanLiteral;
      },
    });
    Object.defineProperty(exports, 'RegExpLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.regExpLiteral;
      },
    });
    Object.defineProperty(exports, 'LogicalExpression', {
      enumerable: true,
      get: function () {
        return generated$1.logicalExpression;
      },
    });
    Object.defineProperty(exports, 'MemberExpression', {
      enumerable: true,
      get: function () {
        return generated$1.memberExpression;
      },
    });
    Object.defineProperty(exports, 'NewExpression', {
      enumerable: true,
      get: function () {
        return generated$1.newExpression;
      },
    });
    Object.defineProperty(exports, 'Program', {
      enumerable: true,
      get: function () {
        return generated$1.program;
      },
    });
    Object.defineProperty(exports, 'ObjectExpression', {
      enumerable: true,
      get: function () {
        return generated$1.objectExpression;
      },
    });
    Object.defineProperty(exports, 'ObjectMethod', {
      enumerable: true,
      get: function () {
        return generated$1.objectMethod;
      },
    });
    Object.defineProperty(exports, 'ObjectProperty', {
      enumerable: true,
      get: function () {
        return generated$1.objectProperty;
      },
    });
    Object.defineProperty(exports, 'RestElement', {
      enumerable: true,
      get: function () {
        return generated$1.restElement;
      },
    });
    Object.defineProperty(exports, 'ReturnStatement', {
      enumerable: true,
      get: function () {
        return generated$1.returnStatement;
      },
    });
    Object.defineProperty(exports, 'SequenceExpression', {
      enumerable: true,
      get: function () {
        return generated$1.sequenceExpression;
      },
    });
    Object.defineProperty(exports, 'ParenthesizedExpression', {
      enumerable: true,
      get: function () {
        return generated$1.parenthesizedExpression;
      },
    });
    Object.defineProperty(exports, 'SwitchCase', {
      enumerable: true,
      get: function () {
        return generated$1.switchCase;
      },
    });
    Object.defineProperty(exports, 'SwitchStatement', {
      enumerable: true,
      get: function () {
        return generated$1.switchStatement;
      },
    });
    Object.defineProperty(exports, 'ThisExpression', {
      enumerable: true,
      get: function () {
        return generated$1.thisExpression;
      },
    });
    Object.defineProperty(exports, 'ThrowStatement', {
      enumerable: true,
      get: function () {
        return generated$1.throwStatement;
      },
    });
    Object.defineProperty(exports, 'TryStatement', {
      enumerable: true,
      get: function () {
        return generated$1.tryStatement;
      },
    });
    Object.defineProperty(exports, 'UnaryExpression', {
      enumerable: true,
      get: function () {
        return generated$1.unaryExpression;
      },
    });
    Object.defineProperty(exports, 'UpdateExpression', {
      enumerable: true,
      get: function () {
        return generated$1.updateExpression;
      },
    });
    Object.defineProperty(exports, 'VariableDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.variableDeclaration;
      },
    });
    Object.defineProperty(exports, 'VariableDeclarator', {
      enumerable: true,
      get: function () {
        return generated$1.variableDeclarator;
      },
    });
    Object.defineProperty(exports, 'WhileStatement', {
      enumerable: true,
      get: function () {
        return generated$1.whileStatement;
      },
    });
    Object.defineProperty(exports, 'WithStatement', {
      enumerable: true,
      get: function () {
        return generated$1.withStatement;
      },
    });
    Object.defineProperty(exports, 'AssignmentPattern', {
      enumerable: true,
      get: function () {
        return generated$1.assignmentPattern;
      },
    });
    Object.defineProperty(exports, 'ArrayPattern', {
      enumerable: true,
      get: function () {
        return generated$1.arrayPattern;
      },
    });
    Object.defineProperty(exports, 'ArrowFunctionExpression', {
      enumerable: true,
      get: function () {
        return generated$1.arrowFunctionExpression;
      },
    });
    Object.defineProperty(exports, 'ClassBody', {
      enumerable: true,
      get: function () {
        return generated$1.classBody;
      },
    });
    Object.defineProperty(exports, 'ClassExpression', {
      enumerable: true,
      get: function () {
        return generated$1.classExpression;
      },
    });
    Object.defineProperty(exports, 'ClassDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.classDeclaration;
      },
    });
    Object.defineProperty(exports, 'ExportAllDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.exportAllDeclaration;
      },
    });
    Object.defineProperty(exports, 'ExportDefaultDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.exportDefaultDeclaration;
      },
    });
    Object.defineProperty(exports, 'ExportNamedDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.exportNamedDeclaration;
      },
    });
    Object.defineProperty(exports, 'ExportSpecifier', {
      enumerable: true,
      get: function () {
        return generated$1.exportSpecifier;
      },
    });
    Object.defineProperty(exports, 'ForOfStatement', {
      enumerable: true,
      get: function () {
        return generated$1.forOfStatement;
      },
    });
    Object.defineProperty(exports, 'ImportDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.importDeclaration;
      },
    });
    Object.defineProperty(exports, 'ImportDefaultSpecifier', {
      enumerable: true,
      get: function () {
        return generated$1.importDefaultSpecifier;
      },
    });
    Object.defineProperty(exports, 'ImportNamespaceSpecifier', {
      enumerable: true,
      get: function () {
        return generated$1.importNamespaceSpecifier;
      },
    });
    Object.defineProperty(exports, 'ImportSpecifier', {
      enumerable: true,
      get: function () {
        return generated$1.importSpecifier;
      },
    });
    Object.defineProperty(exports, 'MetaProperty', {
      enumerable: true,
      get: function () {
        return generated$1.metaProperty;
      },
    });
    Object.defineProperty(exports, 'ClassMethod', {
      enumerable: true,
      get: function () {
        return generated$1.classMethod;
      },
    });
    Object.defineProperty(exports, 'ObjectPattern', {
      enumerable: true,
      get: function () {
        return generated$1.objectPattern;
      },
    });
    Object.defineProperty(exports, 'SpreadElement', {
      enumerable: true,
      get: function () {
        return generated$1.spreadElement;
      },
    });
    Object.defineProperty(exports, 'Super', {
      enumerable: true,
      get: function () {
        return generated$1.super;
      },
    });
    Object.defineProperty(exports, 'TaggedTemplateExpression', {
      enumerable: true,
      get: function () {
        return generated$1.taggedTemplateExpression;
      },
    });
    Object.defineProperty(exports, 'TemplateElement', {
      enumerable: true,
      get: function () {
        return generated$1.templateElement;
      },
    });
    Object.defineProperty(exports, 'TemplateLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.templateLiteral;
      },
    });
    Object.defineProperty(exports, 'YieldExpression', {
      enumerable: true,
      get: function () {
        return generated$1.yieldExpression;
      },
    });
    Object.defineProperty(exports, 'AwaitExpression', {
      enumerable: true,
      get: function () {
        return generated$1.awaitExpression;
      },
    });
    Object.defineProperty(exports, 'Import', {
      enumerable: true,
      get: function () {
        return generated$1.import;
      },
    });
    Object.defineProperty(exports, 'BigIntLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.bigIntLiteral;
      },
    });
    Object.defineProperty(exports, 'ExportNamespaceSpecifier', {
      enumerable: true,
      get: function () {
        return generated$1.exportNamespaceSpecifier;
      },
    });
    Object.defineProperty(exports, 'OptionalMemberExpression', {
      enumerable: true,
      get: function () {
        return generated$1.optionalMemberExpression;
      },
    });
    Object.defineProperty(exports, 'OptionalCallExpression', {
      enumerable: true,
      get: function () {
        return generated$1.optionalCallExpression;
      },
    });
    Object.defineProperty(exports, 'AnyTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.anyTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'ArrayTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.arrayTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'BooleanTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.booleanTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'BooleanLiteralTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.booleanLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'NullLiteralTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.nullLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'ClassImplements', {
      enumerable: true,
      get: function () {
        return generated$1.classImplements;
      },
    });
    Object.defineProperty(exports, 'DeclareClass', {
      enumerable: true,
      get: function () {
        return generated$1.declareClass;
      },
    });
    Object.defineProperty(exports, 'DeclareFunction', {
      enumerable: true,
      get: function () {
        return generated$1.declareFunction;
      },
    });
    Object.defineProperty(exports, 'DeclareInterface', {
      enumerable: true,
      get: function () {
        return generated$1.declareInterface;
      },
    });
    Object.defineProperty(exports, 'DeclareModule', {
      enumerable: true,
      get: function () {
        return generated$1.declareModule;
      },
    });
    Object.defineProperty(exports, 'DeclareModuleExports', {
      enumerable: true,
      get: function () {
        return generated$1.declareModuleExports;
      },
    });
    Object.defineProperty(exports, 'DeclareTypeAlias', {
      enumerable: true,
      get: function () {
        return generated$1.declareTypeAlias;
      },
    });
    Object.defineProperty(exports, 'DeclareOpaqueType', {
      enumerable: true,
      get: function () {
        return generated$1.declareOpaqueType;
      },
    });
    Object.defineProperty(exports, 'DeclareVariable', {
      enumerable: true,
      get: function () {
        return generated$1.declareVariable;
      },
    });
    Object.defineProperty(exports, 'DeclareExportDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.declareExportDeclaration;
      },
    });
    Object.defineProperty(exports, 'DeclareExportAllDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.declareExportAllDeclaration;
      },
    });
    Object.defineProperty(exports, 'DeclaredPredicate', {
      enumerable: true,
      get: function () {
        return generated$1.declaredPredicate;
      },
    });
    Object.defineProperty(exports, 'ExistsTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.existsTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'FunctionTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.functionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'FunctionTypeParam', {
      enumerable: true,
      get: function () {
        return generated$1.functionTypeParam;
      },
    });
    Object.defineProperty(exports, 'GenericTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.genericTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'InferredPredicate', {
      enumerable: true,
      get: function () {
        return generated$1.inferredPredicate;
      },
    });
    Object.defineProperty(exports, 'InterfaceExtends', {
      enumerable: true,
      get: function () {
        return generated$1.interfaceExtends;
      },
    });
    Object.defineProperty(exports, 'InterfaceDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.interfaceDeclaration;
      },
    });
    Object.defineProperty(exports, 'InterfaceTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.interfaceTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'IntersectionTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.intersectionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'MixedTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.mixedTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'EmptyTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.emptyTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'NullableTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.nullableTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'NumberLiteralTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.numberLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'NumberTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.numberTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'ObjectTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.objectTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'ObjectTypeInternalSlot', {
      enumerable: true,
      get: function () {
        return generated$1.objectTypeInternalSlot;
      },
    });
    Object.defineProperty(exports, 'ObjectTypeCallProperty', {
      enumerable: true,
      get: function () {
        return generated$1.objectTypeCallProperty;
      },
    });
    Object.defineProperty(exports, 'ObjectTypeIndexer', {
      enumerable: true,
      get: function () {
        return generated$1.objectTypeIndexer;
      },
    });
    Object.defineProperty(exports, 'ObjectTypeProperty', {
      enumerable: true,
      get: function () {
        return generated$1.objectTypeProperty;
      },
    });
    Object.defineProperty(exports, 'ObjectTypeSpreadProperty', {
      enumerable: true,
      get: function () {
        return generated$1.objectTypeSpreadProperty;
      },
    });
    Object.defineProperty(exports, 'OpaqueType', {
      enumerable: true,
      get: function () {
        return generated$1.opaqueType;
      },
    });
    Object.defineProperty(exports, 'QualifiedTypeIdentifier', {
      enumerable: true,
      get: function () {
        return generated$1.qualifiedTypeIdentifier;
      },
    });
    Object.defineProperty(exports, 'StringLiteralTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.stringLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'StringTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.stringTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'SymbolTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.symbolTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'ThisTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.thisTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'TupleTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.tupleTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'TypeofTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.typeofTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'TypeAlias', {
      enumerable: true,
      get: function () {
        return generated$1.typeAlias;
      },
    });
    Object.defineProperty(exports, 'TypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.typeAnnotation;
      },
    });
    Object.defineProperty(exports, 'TypeCastExpression', {
      enumerable: true,
      get: function () {
        return generated$1.typeCastExpression;
      },
    });
    Object.defineProperty(exports, 'TypeParameter', {
      enumerable: true,
      get: function () {
        return generated$1.typeParameter;
      },
    });
    Object.defineProperty(exports, 'TypeParameterDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.typeParameterDeclaration;
      },
    });
    Object.defineProperty(exports, 'TypeParameterInstantiation', {
      enumerable: true,
      get: function () {
        return generated$1.typeParameterInstantiation;
      },
    });
    Object.defineProperty(exports, 'UnionTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.unionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'Variance', {
      enumerable: true,
      get: function () {
        return generated$1.variance;
      },
    });
    Object.defineProperty(exports, 'VoidTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.voidTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'EnumDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.enumDeclaration;
      },
    });
    Object.defineProperty(exports, 'EnumBooleanBody', {
      enumerable: true,
      get: function () {
        return generated$1.enumBooleanBody;
      },
    });
    Object.defineProperty(exports, 'EnumNumberBody', {
      enumerable: true,
      get: function () {
        return generated$1.enumNumberBody;
      },
    });
    Object.defineProperty(exports, 'EnumStringBody', {
      enumerable: true,
      get: function () {
        return generated$1.enumStringBody;
      },
    });
    Object.defineProperty(exports, 'EnumSymbolBody', {
      enumerable: true,
      get: function () {
        return generated$1.enumSymbolBody;
      },
    });
    Object.defineProperty(exports, 'EnumBooleanMember', {
      enumerable: true,
      get: function () {
        return generated$1.enumBooleanMember;
      },
    });
    Object.defineProperty(exports, 'EnumNumberMember', {
      enumerable: true,
      get: function () {
        return generated$1.enumNumberMember;
      },
    });
    Object.defineProperty(exports, 'EnumStringMember', {
      enumerable: true,
      get: function () {
        return generated$1.enumStringMember;
      },
    });
    Object.defineProperty(exports, 'EnumDefaultedMember', {
      enumerable: true,
      get: function () {
        return generated$1.enumDefaultedMember;
      },
    });
    Object.defineProperty(exports, 'JSXAttribute', {
      enumerable: true,
      get: function () {
        return generated$1.jsxAttribute;
      },
    });
    Object.defineProperty(exports, 'JSXClosingElement', {
      enumerable: true,
      get: function () {
        return generated$1.jsxClosingElement;
      },
    });
    Object.defineProperty(exports, 'JSXElement', {
      enumerable: true,
      get: function () {
        return generated$1.jsxElement;
      },
    });
    Object.defineProperty(exports, 'JSXEmptyExpression', {
      enumerable: true,
      get: function () {
        return generated$1.jsxEmptyExpression;
      },
    });
    Object.defineProperty(exports, 'JSXExpressionContainer', {
      enumerable: true,
      get: function () {
        return generated$1.jsxExpressionContainer;
      },
    });
    Object.defineProperty(exports, 'JSXSpreadChild', {
      enumerable: true,
      get: function () {
        return generated$1.jsxSpreadChild;
      },
    });
    Object.defineProperty(exports, 'JSXIdentifier', {
      enumerable: true,
      get: function () {
        return generated$1.jsxIdentifier;
      },
    });
    Object.defineProperty(exports, 'JSXMemberExpression', {
      enumerable: true,
      get: function () {
        return generated$1.jsxMemberExpression;
      },
    });
    Object.defineProperty(exports, 'JSXNamespacedName', {
      enumerable: true,
      get: function () {
        return generated$1.jsxNamespacedName;
      },
    });
    Object.defineProperty(exports, 'JSXOpeningElement', {
      enumerable: true,
      get: function () {
        return generated$1.jsxOpeningElement;
      },
    });
    Object.defineProperty(exports, 'JSXSpreadAttribute', {
      enumerable: true,
      get: function () {
        return generated$1.jsxSpreadAttribute;
      },
    });
    Object.defineProperty(exports, 'JSXText', {
      enumerable: true,
      get: function () {
        return generated$1.jsxText;
      },
    });
    Object.defineProperty(exports, 'JSXFragment', {
      enumerable: true,
      get: function () {
        return generated$1.jsxFragment;
      },
    });
    Object.defineProperty(exports, 'JSXOpeningFragment', {
      enumerable: true,
      get: function () {
        return generated$1.jsxOpeningFragment;
      },
    });
    Object.defineProperty(exports, 'JSXClosingFragment', {
      enumerable: true,
      get: function () {
        return generated$1.jsxClosingFragment;
      },
    });
    Object.defineProperty(exports, 'Noop', {
      enumerable: true,
      get: function () {
        return generated$1.noop;
      },
    });
    Object.defineProperty(exports, 'Placeholder', {
      enumerable: true,
      get: function () {
        return generated$1.placeholder;
      },
    });
    Object.defineProperty(exports, 'V8IntrinsicIdentifier', {
      enumerable: true,
      get: function () {
        return generated$1.v8IntrinsicIdentifier;
      },
    });
    Object.defineProperty(exports, 'ArgumentPlaceholder', {
      enumerable: true,
      get: function () {
        return generated$1.argumentPlaceholder;
      },
    });
    Object.defineProperty(exports, 'BindExpression', {
      enumerable: true,
      get: function () {
        return generated$1.bindExpression;
      },
    });
    Object.defineProperty(exports, 'ClassProperty', {
      enumerable: true,
      get: function () {
        return generated$1.classProperty;
      },
    });
    Object.defineProperty(exports, 'PipelineTopicExpression', {
      enumerable: true,
      get: function () {
        return generated$1.pipelineTopicExpression;
      },
    });
    Object.defineProperty(exports, 'PipelineBareFunction', {
      enumerable: true,
      get: function () {
        return generated$1.pipelineBareFunction;
      },
    });
    Object.defineProperty(exports, 'PipelinePrimaryTopicReference', {
      enumerable: true,
      get: function () {
        return generated$1.pipelinePrimaryTopicReference;
      },
    });
    Object.defineProperty(exports, 'ClassPrivateProperty', {
      enumerable: true,
      get: function () {
        return generated$1.classPrivateProperty;
      },
    });
    Object.defineProperty(exports, 'ClassPrivateMethod', {
      enumerable: true,
      get: function () {
        return generated$1.classPrivateMethod;
      },
    });
    Object.defineProperty(exports, 'ImportAttribute', {
      enumerable: true,
      get: function () {
        return generated$1.importAttribute;
      },
    });
    Object.defineProperty(exports, 'Decorator', {
      enumerable: true,
      get: function () {
        return generated$1.decorator;
      },
    });
    Object.defineProperty(exports, 'DoExpression', {
      enumerable: true,
      get: function () {
        return generated$1.doExpression;
      },
    });
    Object.defineProperty(exports, 'ExportDefaultSpecifier', {
      enumerable: true,
      get: function () {
        return generated$1.exportDefaultSpecifier;
      },
    });
    Object.defineProperty(exports, 'PrivateName', {
      enumerable: true,
      get: function () {
        return generated$1.privateName;
      },
    });
    Object.defineProperty(exports, 'RecordExpression', {
      enumerable: true,
      get: function () {
        return generated$1.recordExpression;
      },
    });
    Object.defineProperty(exports, 'TupleExpression', {
      enumerable: true,
      get: function () {
        return generated$1.tupleExpression;
      },
    });
    Object.defineProperty(exports, 'DecimalLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.decimalLiteral;
      },
    });
    Object.defineProperty(exports, 'StaticBlock', {
      enumerable: true,
      get: function () {
        return generated$1.staticBlock;
      },
    });
    Object.defineProperty(exports, 'ModuleExpression', {
      enumerable: true,
      get: function () {
        return generated$1.moduleExpression;
      },
    });
    Object.defineProperty(exports, 'TSParameterProperty', {
      enumerable: true,
      get: function () {
        return generated$1.tsParameterProperty;
      },
    });
    Object.defineProperty(exports, 'TSDeclareFunction', {
      enumerable: true,
      get: function () {
        return generated$1.tsDeclareFunction;
      },
    });
    Object.defineProperty(exports, 'TSDeclareMethod', {
      enumerable: true,
      get: function () {
        return generated$1.tsDeclareMethod;
      },
    });
    Object.defineProperty(exports, 'TSQualifiedName', {
      enumerable: true,
      get: function () {
        return generated$1.tsQualifiedName;
      },
    });
    Object.defineProperty(exports, 'TSCallSignatureDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsCallSignatureDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSConstructSignatureDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsConstructSignatureDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSPropertySignature', {
      enumerable: true,
      get: function () {
        return generated$1.tsPropertySignature;
      },
    });
    Object.defineProperty(exports, 'TSMethodSignature', {
      enumerable: true,
      get: function () {
        return generated$1.tsMethodSignature;
      },
    });
    Object.defineProperty(exports, 'TSIndexSignature', {
      enumerable: true,
      get: function () {
        return generated$1.tsIndexSignature;
      },
    });
    Object.defineProperty(exports, 'TSAnyKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsAnyKeyword;
      },
    });
    Object.defineProperty(exports, 'TSBooleanKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsBooleanKeyword;
      },
    });
    Object.defineProperty(exports, 'TSBigIntKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsBigIntKeyword;
      },
    });
    Object.defineProperty(exports, 'TSIntrinsicKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsIntrinsicKeyword;
      },
    });
    Object.defineProperty(exports, 'TSNeverKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsNeverKeyword;
      },
    });
    Object.defineProperty(exports, 'TSNullKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsNullKeyword;
      },
    });
    Object.defineProperty(exports, 'TSNumberKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsNumberKeyword;
      },
    });
    Object.defineProperty(exports, 'TSObjectKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsObjectKeyword;
      },
    });
    Object.defineProperty(exports, 'TSStringKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsStringKeyword;
      },
    });
    Object.defineProperty(exports, 'TSSymbolKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsSymbolKeyword;
      },
    });
    Object.defineProperty(exports, 'TSUndefinedKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsUndefinedKeyword;
      },
    });
    Object.defineProperty(exports, 'TSUnknownKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsUnknownKeyword;
      },
    });
    Object.defineProperty(exports, 'TSVoidKeyword', {
      enumerable: true,
      get: function () {
        return generated$1.tsVoidKeyword;
      },
    });
    Object.defineProperty(exports, 'TSThisType', {
      enumerable: true,
      get: function () {
        return generated$1.tsThisType;
      },
    });
    Object.defineProperty(exports, 'TSFunctionType', {
      enumerable: true,
      get: function () {
        return generated$1.tsFunctionType;
      },
    });
    Object.defineProperty(exports, 'TSConstructorType', {
      enumerable: true,
      get: function () {
        return generated$1.tsConstructorType;
      },
    });
    Object.defineProperty(exports, 'TSTypeReference', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeReference;
      },
    });
    Object.defineProperty(exports, 'TSTypePredicate', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypePredicate;
      },
    });
    Object.defineProperty(exports, 'TSTypeQuery', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeQuery;
      },
    });
    Object.defineProperty(exports, 'TSTypeLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeLiteral;
      },
    });
    Object.defineProperty(exports, 'TSArrayType', {
      enumerable: true,
      get: function () {
        return generated$1.tsArrayType;
      },
    });
    Object.defineProperty(exports, 'TSTupleType', {
      enumerable: true,
      get: function () {
        return generated$1.tsTupleType;
      },
    });
    Object.defineProperty(exports, 'TSOptionalType', {
      enumerable: true,
      get: function () {
        return generated$1.tsOptionalType;
      },
    });
    Object.defineProperty(exports, 'TSRestType', {
      enumerable: true,
      get: function () {
        return generated$1.tsRestType;
      },
    });
    Object.defineProperty(exports, 'TSNamedTupleMember', {
      enumerable: true,
      get: function () {
        return generated$1.tsNamedTupleMember;
      },
    });
    Object.defineProperty(exports, 'TSUnionType', {
      enumerable: true,
      get: function () {
        return generated$1.tsUnionType;
      },
    });
    Object.defineProperty(exports, 'TSIntersectionType', {
      enumerable: true,
      get: function () {
        return generated$1.tsIntersectionType;
      },
    });
    Object.defineProperty(exports, 'TSConditionalType', {
      enumerable: true,
      get: function () {
        return generated$1.tsConditionalType;
      },
    });
    Object.defineProperty(exports, 'TSInferType', {
      enumerable: true,
      get: function () {
        return generated$1.tsInferType;
      },
    });
    Object.defineProperty(exports, 'TSParenthesizedType', {
      enumerable: true,
      get: function () {
        return generated$1.tsParenthesizedType;
      },
    });
    Object.defineProperty(exports, 'TSTypeOperator', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeOperator;
      },
    });
    Object.defineProperty(exports, 'TSIndexedAccessType', {
      enumerable: true,
      get: function () {
        return generated$1.tsIndexedAccessType;
      },
    });
    Object.defineProperty(exports, 'TSMappedType', {
      enumerable: true,
      get: function () {
        return generated$1.tsMappedType;
      },
    });
    Object.defineProperty(exports, 'TSLiteralType', {
      enumerable: true,
      get: function () {
        return generated$1.tsLiteralType;
      },
    });
    Object.defineProperty(exports, 'TSExpressionWithTypeArguments', {
      enumerable: true,
      get: function () {
        return generated$1.tsExpressionWithTypeArguments;
      },
    });
    Object.defineProperty(exports, 'TSInterfaceDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsInterfaceDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSInterfaceBody', {
      enumerable: true,
      get: function () {
        return generated$1.tsInterfaceBody;
      },
    });
    Object.defineProperty(exports, 'TSTypeAliasDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeAliasDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSAsExpression', {
      enumerable: true,
      get: function () {
        return generated$1.tsAsExpression;
      },
    });
    Object.defineProperty(exports, 'TSTypeAssertion', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeAssertion;
      },
    });
    Object.defineProperty(exports, 'TSEnumDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsEnumDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSEnumMember', {
      enumerable: true,
      get: function () {
        return generated$1.tsEnumMember;
      },
    });
    Object.defineProperty(exports, 'TSModuleDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsModuleDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSModuleBlock', {
      enumerable: true,
      get: function () {
        return generated$1.tsModuleBlock;
      },
    });
    Object.defineProperty(exports, 'TSImportType', {
      enumerable: true,
      get: function () {
        return generated$1.tsImportType;
      },
    });
    Object.defineProperty(exports, 'TSImportEqualsDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsImportEqualsDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSExternalModuleReference', {
      enumerable: true,
      get: function () {
        return generated$1.tsExternalModuleReference;
      },
    });
    Object.defineProperty(exports, 'TSNonNullExpression', {
      enumerable: true,
      get: function () {
        return generated$1.tsNonNullExpression;
      },
    });
    Object.defineProperty(exports, 'TSExportAssignment', {
      enumerable: true,
      get: function () {
        return generated$1.tsExportAssignment;
      },
    });
    Object.defineProperty(exports, 'TSNamespaceExportDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsNamespaceExportDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSTypeAnnotation', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeAnnotation;
      },
    });
    Object.defineProperty(exports, 'TSTypeParameterInstantiation', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeParameterInstantiation;
      },
    });
    Object.defineProperty(exports, 'TSTypeParameterDeclaration', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeParameterDeclaration;
      },
    });
    Object.defineProperty(exports, 'TSTypeParameter', {
      enumerable: true,
      get: function () {
        return generated$1.tsTypeParameter;
      },
    });
    Object.defineProperty(exports, 'NumberLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.numberLiteral;
      },
    });
    Object.defineProperty(exports, 'RegexLiteral', {
      enumerable: true,
      get: function () {
        return generated$1.regexLiteral;
      },
    });
    Object.defineProperty(exports, 'RestProperty', {
      enumerable: true,
      get: function () {
        return generated$1.restProperty;
      },
    });
    Object.defineProperty(exports, 'SpreadProperty', {
      enumerable: true,
      get: function () {
        return generated$1.spreadProperty;
      },
    });
  });

  var _default$j = cloneNode;
  const has = Function.call.bind(Object.prototype.hasOwnProperty);

  function cloneIfNode(obj, deep, withoutLoc) {
    if (obj && typeof obj.type === 'string') {
      return cloneNode(obj, deep, withoutLoc);
    }

    return obj;
  }

  function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    if (Array.isArray(obj)) {
      return obj.map((node) => cloneIfNode(node, deep, withoutLoc));
    }

    return cloneIfNode(obj, deep, withoutLoc);
  }

  function cloneNode(node, deep = true, withoutLoc = false) {
    if (!node) return node;
    const {type} = node;
    const newNode = {
      type: node.type,
    };

    if ((0, generated.isIdentifier)(node)) {
      newNode.name = node.name;

      if (has(node, 'optional') && typeof node.optional === 'boolean') {
        newNode.optional = node.optional;
      }

      if (has(node, 'typeAnnotation')) {
        newNode.typeAnnotation = deep
          ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc)
          : node.typeAnnotation;
      }
    } else if (!has(definitions.NODE_FIELDS, type)) {
      throw new Error(`Unknown node type: "${type}"`);
    } else {
      for (const field of Object.keys(definitions.NODE_FIELDS[type])) {
        if (has(node, field)) {
          if (deep) {
            newNode[field] =
              (0, generated.isFile)(node) && field === 'comments'
                ? maybeCloneComments(node.comments, deep, withoutLoc)
                : cloneIfNodeOrArray(node[field], true, withoutLoc);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }

    if (has(node, 'loc')) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }

    if (has(node, 'leadingComments')) {
      newNode.leadingComments = maybeCloneComments(
        node.leadingComments,
        deep,
        withoutLoc,
      );
    }

    if (has(node, 'innerComments')) {
      newNode.innerComments = maybeCloneComments(
        node.innerComments,
        deep,
        withoutLoc,
      );
    }

    if (has(node, 'trailingComments')) {
      newNode.trailingComments = maybeCloneComments(
        node.trailingComments,
        deep,
        withoutLoc,
      );
    }

    if (has(node, 'extra')) {
      newNode.extra = Object.assign({}, node.extra);
    }

    return newNode;
  }

  function maybeCloneComments(comments, deep, withoutLoc) {
    if (!comments || !deep) {
      return comments;
    }

    return comments.map(({type, value, loc}) => {
      if (withoutLoc) {
        return {
          type,
          value,
          loc: null,
        };
      }

      return {
        type,
        value,
        loc,
      };
    });
  }

  var cloneNode_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$j,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$k = clone;

  var _cloneNode = _interopRequireDefault$9(cloneNode_1);

  function _interopRequireDefault$9(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function clone(node) {
    return (0, _cloneNode.default)(node, false);
  }

  var clone_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$k,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$l = cloneDeep;

  var _cloneNode$1 = _interopRequireDefault$a(cloneNode_1);

  function _interopRequireDefault$a(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function cloneDeep(node) {
    return (0, _cloneNode$1.default)(node);
  }

  var cloneDeep_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$l,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$m = cloneDeepWithoutLoc;

  var _cloneNode$2 = _interopRequireDefault$b(cloneNode_1);

  function _interopRequireDefault$b(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function cloneDeepWithoutLoc(node) {
    return (0, _cloneNode$2.default)(node, true, true);
  }

  var cloneDeepWithoutLoc_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$m,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$n = cloneWithoutLoc;

  var _cloneNode$3 = _interopRequireDefault$c(cloneNode_1);

  function _interopRequireDefault$c(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function cloneWithoutLoc(node) {
    return (0, _cloneNode$3.default)(node, false, true);
  }

  var cloneWithoutLoc_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$n,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$o = addComments;

  function addComments(node, type, comments) {
    if (!comments || !node) return node;
    const key = `${type}Comments`;

    if (node[key]) {
      if (type === 'leading') {
        node[key] = comments.concat(node[key]);
      } else {
        node[key] = node[key].concat(comments);
      }
    } else {
      node[key] = comments;
    }

    return node;
  }

  var addComments_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$o,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$p = addComment;

  var _addComments = _interopRequireDefault$d(addComments_1);

  function _interopRequireDefault$d(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function addComment(node, type, content, line) {
    return (0, _addComments.default)(node, type, [
      {
        type: line ? 'CommentLine' : 'CommentBlock',
        value: content,
      },
    ]);
  }

  var addComment_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$p,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$q = inherit;

  function inherit(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(
        new Set([].concat(child[key], parent[key]).filter(Boolean)),
      );
    }
  }

  var inherit_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$q,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$r = inheritInnerComments;

  var _inherit = _interopRequireDefault$e(inherit_1);

  function _interopRequireDefault$e(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function inheritInnerComments(child, parent) {
    (0, _inherit.default)('innerComments', child, parent);
  }

  var inheritInnerComments_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$r,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$s = inheritLeadingComments;

  var _inherit$1 = _interopRequireDefault$f(inherit_1);

  function _interopRequireDefault$f(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function inheritLeadingComments(child, parent) {
    (0, _inherit$1.default)('leadingComments', child, parent);
  }

  var inheritLeadingComments_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$s,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$t = inheritTrailingComments;

  var _inherit$2 = _interopRequireDefault$g(inherit_1);

  function _interopRequireDefault$g(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function inheritTrailingComments(child, parent) {
    (0, _inherit$2.default)('trailingComments', child, parent);
  }

  var inheritTrailingComments_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$t,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$u = inheritsComments;

  var _inheritTrailingComments = _interopRequireDefault$h(
    inheritTrailingComments_1,
  );

  var _inheritLeadingComments = _interopRequireDefault$h(
    inheritLeadingComments_1,
  );

  var _inheritInnerComments = _interopRequireDefault$h(inheritInnerComments_1);

  function _interopRequireDefault$h(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function inheritsComments(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
  }

  var inheritsComments_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$u,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$v = removeComments;

  function removeComments(node) {
    constants.COMMENT_KEYS.forEach((key) => {
      node[key] = null;
    });

    return node;
  }

  var removeComments_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$v,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var generated$3 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.TSBASETYPE_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;
    const EXPRESSION_TYPES = definitions.FLIPPED_ALIAS_KEYS['Expression'];
    exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
    const BINARY_TYPES = definitions.FLIPPED_ALIAS_KEYS['Binary'];
    exports.BINARY_TYPES = BINARY_TYPES;
    const SCOPABLE_TYPES = definitions.FLIPPED_ALIAS_KEYS['Scopable'];
    exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
    const BLOCKPARENT_TYPES = definitions.FLIPPED_ALIAS_KEYS['BlockParent'];
    exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
    const BLOCK_TYPES = definitions.FLIPPED_ALIAS_KEYS['Block'];
    exports.BLOCK_TYPES = BLOCK_TYPES;
    const STATEMENT_TYPES = definitions.FLIPPED_ALIAS_KEYS['Statement'];
    exports.STATEMENT_TYPES = STATEMENT_TYPES;
    const TERMINATORLESS_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['Terminatorless'];
    exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
    const COMPLETIONSTATEMENT_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['CompletionStatement'];
    exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
    const CONDITIONAL_TYPES = definitions.FLIPPED_ALIAS_KEYS['Conditional'];
    exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
    const LOOP_TYPES = definitions.FLIPPED_ALIAS_KEYS['Loop'];
    exports.LOOP_TYPES = LOOP_TYPES;
    const WHILE_TYPES = definitions.FLIPPED_ALIAS_KEYS['While'];
    exports.WHILE_TYPES = WHILE_TYPES;
    const EXPRESSIONWRAPPER_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['ExpressionWrapper'];
    exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
    const FOR_TYPES = definitions.FLIPPED_ALIAS_KEYS['For'];
    exports.FOR_TYPES = FOR_TYPES;
    const FORXSTATEMENT_TYPES = definitions.FLIPPED_ALIAS_KEYS['ForXStatement'];
    exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
    const FUNCTION_TYPES = definitions.FLIPPED_ALIAS_KEYS['Function'];
    exports.FUNCTION_TYPES = FUNCTION_TYPES;
    const FUNCTIONPARENT_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['FunctionParent'];
    exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
    const PUREISH_TYPES = definitions.FLIPPED_ALIAS_KEYS['Pureish'];
    exports.PUREISH_TYPES = PUREISH_TYPES;
    const DECLARATION_TYPES = definitions.FLIPPED_ALIAS_KEYS['Declaration'];
    exports.DECLARATION_TYPES = DECLARATION_TYPES;
    const PATTERNLIKE_TYPES = definitions.FLIPPED_ALIAS_KEYS['PatternLike'];
    exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
    const LVAL_TYPES = definitions.FLIPPED_ALIAS_KEYS['LVal'];
    exports.LVAL_TYPES = LVAL_TYPES;
    const TSENTITYNAME_TYPES = definitions.FLIPPED_ALIAS_KEYS['TSEntityName'];
    exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
    const LITERAL_TYPES = definitions.FLIPPED_ALIAS_KEYS['Literal'];
    exports.LITERAL_TYPES = LITERAL_TYPES;
    const IMMUTABLE_TYPES = definitions.FLIPPED_ALIAS_KEYS['Immutable'];
    exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
    const USERWHITESPACABLE_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['UserWhitespacable'];
    exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
    const METHOD_TYPES = definitions.FLIPPED_ALIAS_KEYS['Method'];
    exports.METHOD_TYPES = METHOD_TYPES;
    const OBJECTMEMBER_TYPES = definitions.FLIPPED_ALIAS_KEYS['ObjectMember'];
    exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
    const PROPERTY_TYPES = definitions.FLIPPED_ALIAS_KEYS['Property'];
    exports.PROPERTY_TYPES = PROPERTY_TYPES;
    const UNARYLIKE_TYPES = definitions.FLIPPED_ALIAS_KEYS['UnaryLike'];
    exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
    const PATTERN_TYPES = definitions.FLIPPED_ALIAS_KEYS['Pattern'];
    exports.PATTERN_TYPES = PATTERN_TYPES;
    const CLASS_TYPES = definitions.FLIPPED_ALIAS_KEYS['Class'];
    exports.CLASS_TYPES = CLASS_TYPES;
    const MODULEDECLARATION_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['ModuleDeclaration'];
    exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
    const EXPORTDECLARATION_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['ExportDeclaration'];
    exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
    const MODULESPECIFIER_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['ModuleSpecifier'];
    exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
    const FLOW_TYPES = definitions.FLIPPED_ALIAS_KEYS['Flow'];
    exports.FLOW_TYPES = FLOW_TYPES;
    const FLOWTYPE_TYPES = definitions.FLIPPED_ALIAS_KEYS['FlowType'];
    exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
    const FLOWBASEANNOTATION_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['FlowBaseAnnotation'];
    exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
    const FLOWDECLARATION_TYPES =
      definitions.FLIPPED_ALIAS_KEYS['FlowDeclaration'];
    exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
    const FLOWPREDICATE_TYPES = definitions.FLIPPED_ALIAS_KEYS['FlowPredicate'];
    exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
    const ENUMBODY_TYPES = definitions.FLIPPED_ALIAS_KEYS['EnumBody'];
    exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
    const ENUMMEMBER_TYPES = definitions.FLIPPED_ALIAS_KEYS['EnumMember'];
    exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
    const JSX_TYPES = definitions.FLIPPED_ALIAS_KEYS['JSX'];
    exports.JSX_TYPES = JSX_TYPES;
    const PRIVATE_TYPES = definitions.FLIPPED_ALIAS_KEYS['Private'];
    exports.PRIVATE_TYPES = PRIVATE_TYPES;
    const TSTYPEELEMENT_TYPES = definitions.FLIPPED_ALIAS_KEYS['TSTypeElement'];
    exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
    const TSTYPE_TYPES = definitions.FLIPPED_ALIAS_KEYS['TSType'];
    exports.TSTYPE_TYPES = TSTYPE_TYPES;
    const TSBASETYPE_TYPES = definitions.FLIPPED_ALIAS_KEYS['TSBaseType'];
    exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
  });

  var _default$w = toBlock;

  function toBlock(node, parent) {
    if ((0, generated.isBlockStatement)(node)) {
      return node;
    }

    let blockNodes = [];

    if ((0, generated.isEmptyStatement)(node)) {
      blockNodes = [];
    } else {
      if (!(0, generated.isStatement)(node)) {
        if ((0, generated.isFunction)(parent)) {
          node = (0, generated$1.returnStatement)(node);
        } else {
          node = (0, generated$1.expressionStatement)(node);
        }
      }

      blockNodes = [node];
    }

    return (0, generated$1.blockStatement)(blockNodes);
  }

  var toBlock_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$w,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$x = ensureBlock;

  var _toBlock = _interopRequireDefault$i(toBlock_1);

  function _interopRequireDefault$i(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function ensureBlock(node, key = 'body') {
    return (node[key] = (0, _toBlock.default)(node[key], node));
  }

  var ensureBlock_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$x,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$y = toIdentifier;

  var _isValidIdentifier = _interopRequireDefault$j(isValidIdentifier_1);

  function _interopRequireDefault$j(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function toIdentifier(input) {
    input = input + '';
    let name = '';

    for (const c of input) {
      name += (0, lib$1.isIdentifierChar)(c.codePointAt(0)) ? c : '-';
    }

    name = name.replace(/^[-0-9]+/, '');
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : '';
    });

    if (!(0, _isValidIdentifier.default)(name)) {
      name = `_${name}`;
    }

    return name || '_';
  }

  var toIdentifier_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$y,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$z = toBindingIdentifierName;

  var _toIdentifier = _interopRequireDefault$k(toIdentifier_1);

  function _interopRequireDefault$k(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function toBindingIdentifierName(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === 'eval' || name === 'arguments') name = '_' + name;
    return name;
  }

  var toBindingIdentifierName_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$z,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$A = toComputedKey;

  function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && (0, generated.isIdentifier)(key))
      key = (0, generated$1.stringLiteral)(key.name);
    return key;
  }

  var toComputedKey_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$A,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var toExpression_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _default = toExpression;
    exports.default = _default;

    function toExpression(node) {
      if ((0, generated.isExpressionStatement)(node)) {
        node = node.expression;
      }

      if ((0, generated.isExpression)(node)) {
        return node;
      }

      if ((0, generated.isClass)(node)) {
        node.type = 'ClassExpression';
      } else if ((0, generated.isFunction)(node)) {
        node.type = 'FunctionExpression';
      }

      if (!(0, generated.isExpression)(node)) {
        throw new Error(`cannot turn ${node.type} to an expression`);
      }

      return node;
    }
  });

  var _default$B = traverseFast;

  function traverseFast(node, enter, opts) {
    if (!node) return;
    const keys = definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);

    for (const key of keys) {
      const subNode = node[key];

      if (Array.isArray(subNode)) {
        for (const node of subNode) {
          traverseFast(node, enter, opts);
        }
      } else {
        traverseFast(subNode, enter, opts);
      }
    }
  }

  var traverseFast_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$B,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$C = removeProperties;
  const CLEAR_KEYS = ['tokens', 'start', 'end', 'loc', 'raw', 'rawValue'];

  const CLEAR_KEYS_PLUS_COMMENTS = constants.COMMENT_KEYS.concat([
    'comments',
  ]).concat(CLEAR_KEYS);

  function removeProperties(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

    for (const key of map) {
      if (node[key] != null) node[key] = undefined;
    }

    for (const key of Object.keys(node)) {
      if (key[0] === '_' && node[key] != null) node[key] = undefined;
    }

    const symbols = Object.getOwnPropertySymbols(node);

    for (const sym of symbols) {
      node[sym] = null;
    }
  }

  var removeProperties_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$C,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$D = removePropertiesDeep;

  var _traverseFast = _interopRequireDefault$l(traverseFast_1);

  var _removeProperties = _interopRequireDefault$l(removeProperties_1);

  function _interopRequireDefault$l(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function removePropertiesDeep(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
  }

  var removePropertiesDeep_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$D,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$E = toKeyAlias;

  var _cloneNode$4 = _interopRequireDefault$m(cloneNode_1);

  var _removePropertiesDeep = _interopRequireDefault$m(removePropertiesDeep_1);

  function _interopRequireDefault$m(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function toKeyAlias(node, key = node.key) {
    let alias;

    if (node.kind === 'method') {
      return toKeyAlias.increment() + '';
    } else if ((0, generated.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, generated.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify(
        (0, _removePropertiesDeep.default)((0, _cloneNode$4.default)(key)),
      );
    }

    if (node.computed) {
      alias = `[${alias}]`;
    }

    if (node.static) {
      alias = `static:${alias}`;
    }

    return alias;
  }

  toKeyAlias.uid = 0;

  toKeyAlias.increment = function () {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return (toKeyAlias.uid = 0);
    } else {
      return toKeyAlias.uid++;
    }
  };

  var toKeyAlias_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$E,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$F = getBindingIdentifiers;

  function getBindingIdentifiers(node, duplicates, outerOnly) {
    let search = [].concat(node);
    const ids = Object.create(null);

    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      const keys = getBindingIdentifiers.keys[id.type];

      if ((0, generated.isIdentifier)(id)) {
        if (duplicates) {
          const _ids = (ids[id.name] = ids[id.name] || []);

          _ids.push(id);
        } else {
          ids[id.name] = id;
        }

        continue;
      }

      if (
        (0, generated.isExportDeclaration)(id) &&
        !(0, generated.isExportAllDeclaration)(id)
      ) {
        if ((0, generated.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }

        continue;
      }

      if (outerOnly) {
        if ((0, generated.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }

        if ((0, generated.isFunctionExpression)(id)) {
          continue;
        }
      }

      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];

          if (id[key]) {
            search = search.concat(id[key]);
          }
        }
      }
    }

    return ids;
  }

  getBindingIdentifiers.keys = {
    DeclareClass: ['id'],
    DeclareFunction: ['id'],
    DeclareModule: ['id'],
    DeclareVariable: ['id'],
    DeclareInterface: ['id'],
    DeclareTypeAlias: ['id'],
    DeclareOpaqueType: ['id'],
    InterfaceDeclaration: ['id'],
    TypeAlias: ['id'],
    OpaqueType: ['id'],
    CatchClause: ['param'],
    LabeledStatement: ['label'],
    UnaryExpression: ['argument'],
    AssignmentExpression: ['left'],
    ImportSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportDefaultSpecifier: ['local'],
    ImportDeclaration: ['specifiers'],
    ExportSpecifier: ['exported'],
    ExportNamespaceSpecifier: ['exported'],
    ExportDefaultSpecifier: ['exported'],
    FunctionDeclaration: ['id', 'params'],
    FunctionExpression: ['id', 'params'],
    ArrowFunctionExpression: ['params'],
    ObjectMethod: ['params'],
    ClassMethod: ['params'],
    ForInStatement: ['left'],
    ForOfStatement: ['left'],
    ClassDeclaration: ['id'],
    ClassExpression: ['id'],
    RestElement: ['argument'],
    UpdateExpression: ['argument'],
    ObjectProperty: ['value'],
    AssignmentPattern: ['left'],
    ArrayPattern: ['elements'],
    ObjectPattern: ['properties'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id'],
  };
  var getBindingIdentifiers_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$F,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$G = gatherSequenceExpressions;

  var _getBindingIdentifiers = _interopRequireDefault$n(
    getBindingIdentifiers_1,
  );

  var _cloneNode$5 = _interopRequireDefault$n(cloneNode_1);

  function _interopRequireDefault$n(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function gatherSequenceExpressions(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;

    for (const node of nodes) {
      if (!(0, generated.isEmptyStatement)(node)) {
        ensureLastUndefined = false;
      }

      if ((0, generated.isExpression)(node)) {
        exprs.push(node);
      } else if ((0, generated.isExpressionStatement)(node)) {
        exprs.push(node.expression);
      } else if ((0, generated.isVariableDeclaration)(node)) {
        if (node.kind !== 'var') return;

        for (const declar of node.declarations) {
          const bindings = (0, _getBindingIdentifiers.default)(declar);

          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node.kind,
              id: (0, _cloneNode$5.default)(bindings[key]),
            });
          }

          if (declar.init) {
            exprs.push(
              (0, generated$1.assignmentExpression)(
                '=',
                declar.id,
                declar.init,
              ),
            );
          }
        }

        ensureLastUndefined = true;
      } else if ((0, generated.isIfStatement)(node)) {
        const consequent = node.consequent
          ? gatherSequenceExpressions([node.consequent], scope, declars)
          : scope.buildUndefinedNode();
        const alternate = node.alternate
          ? gatherSequenceExpressions([node.alternate], scope, declars)
          : scope.buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push(
          (0, generated$1.conditionalExpression)(
            node.test,
            consequent,
            alternate,
          ),
        );
      } else if ((0, generated.isBlockStatement)(node)) {
        const body = gatherSequenceExpressions(node.body, scope, declars);
        if (!body) return;
        exprs.push(body);
      } else if ((0, generated.isEmptyStatement)(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }

    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }

    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, generated$1.sequenceExpression)(exprs);
    }
  }

  var gatherSequenceExpressions_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$G,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$H = toSequenceExpression;

  var _gatherSequenceExpressions = _interopRequireDefault$o(
    gatherSequenceExpressions_1,
  );

  function _interopRequireDefault$o(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(
      nodes,
      scope,
      declars,
    );
    if (!result) return;

    for (const declar of declars) {
      scope.push(declar);
    }

    return result;
  }

  var toSequenceExpression_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$H,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var toStatement_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    var _default = toStatement;
    exports.default = _default;

    function toStatement(node, ignore) {
      if ((0, generated.isStatement)(node)) {
        return node;
      }

      let mustHaveId = false;
      let newType;

      if ((0, generated.isClass)(node)) {
        mustHaveId = true;
        newType = 'ClassDeclaration';
      } else if ((0, generated.isFunction)(node)) {
        mustHaveId = true;
        newType = 'FunctionDeclaration';
      } else if ((0, generated.isAssignmentExpression)(node)) {
        return (0, generated$1.expressionStatement)(node);
      }

      if (mustHaveId && !node.id) {
        newType = false;
      }

      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error(`cannot turn ${node.type} to a statement`);
        }
      }

      node.type = newType;
      return node;
    }
  });

  var valueToNode_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    var _isValidIdentifier = _interopRequireDefault(isValidIdentifier_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    var _default = valueToNode;
    exports.default = _default;
    const objectToString = Function.call.bind(Object.prototype.toString);

    function isRegExp(value) {
      return objectToString(value) === '[object RegExp]';
    }

    function isPlainObject(value) {
      if (typeof value !== 'object' || value === null) {
        return false;
      }

      const proto = Object.getPrototypeOf(value);
      return proto === null || proto === Object.prototype;
    }

    function valueToNode(value) {
      if (value === undefined) {
        return (0, generated$1.identifier)('undefined');
      }

      if (value === true || value === false) {
        return (0, generated$1.booleanLiteral)(value);
      }

      if (value === null) {
        return (0, generated$1.nullLiteral)();
      }

      if (typeof value === 'string') {
        return (0, generated$1.stringLiteral)(value);
      }

      if (typeof value === 'number') {
        let result;

        if (Number.isFinite(value)) {
          result = (0, generated$1.numericLiteral)(Math.abs(value));
        } else {
          let numerator;

          if (Number.isNaN(value)) {
            numerator = (0, generated$1.numericLiteral)(0);
          } else {
            numerator = (0, generated$1.numericLiteral)(1);
          }

          result = (0, generated$1.binaryExpression)(
            '/',
            numerator,
            (0, generated$1.numericLiteral)(0),
          );
        }

        if (value < 0 || Object.is(value, -0)) {
          result = (0, generated$1.unaryExpression)('-', result);
        }

        return result;
      }

      if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, generated$1.regExpLiteral)(pattern, flags);
      }

      if (Array.isArray(value)) {
        return (0, generated$1.arrayExpression)(value.map(valueToNode));
      }

      if (isPlainObject(value)) {
        const props = [];

        for (const key of Object.keys(value)) {
          let nodeKey;

          if ((0, _isValidIdentifier.default)(key)) {
            nodeKey = (0, generated$1.identifier)(key);
          } else {
            nodeKey = (0, generated$1.stringLiteral)(key);
          }

          props.push(
            (0, generated$1.objectProperty)(nodeKey, valueToNode(value[key])),
          );
        }

        return (0, generated$1.objectExpression)(props);
      }

      throw new Error("don't know how to turn this value into a node");
    }
  });

  var _default$I = appendToMemberExpression;

  function appendToMemberExpression(member, append, computed = false) {
    member.object = (0, generated$1.memberExpression)(
      member.object,
      member.property,
      member.computed,
    );
    member.property = append;
    member.computed = !!computed;
    return member;
  }

  var appendToMemberExpression_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$I,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$J = inherits;

  var _inheritsComments = _interopRequireDefault$p(inheritsComments_1);

  function _interopRequireDefault$p(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function inherits(child, parent) {
    if (!child || !parent) return child;

    for (const key of constants.INHERIT_KEYS.optional) {
      if (child[key] == null) {
        child[key] = parent[key];
      }
    }

    for (const key of Object.keys(parent)) {
      if (key[0] === '_' && key !== '__clone') child[key] = parent[key];
    }

    for (const key of constants.INHERIT_KEYS.force) {
      child[key] = parent[key];
    }

    (0, _inheritsComments.default)(child, parent);
    return child;
  }

  var inherits_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$J,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$K = prependToMemberExpression;

  function prependToMemberExpression(member, prepend) {
    member.object = (0, generated$1.memberExpression)(prepend, member.object);
    return member;
  }

  var prependToMemberExpression_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$K,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var getOuterBindingIdentifiers_1 = createCommonjsModule(function (
    module,
    exports,
  ) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    var _getBindingIdentifiers = _interopRequireDefault(
      getBindingIdentifiers_1,
    );

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    var _default = getOuterBindingIdentifiers;
    exports.default = _default;

    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers.default)(node, duplicates, true);
    }
  });

  var _default$L = traverse;

  function traverse(node, handlers, state) {
    if (typeof handlers === 'function') {
      handlers = {
        enter: handlers,
      };
    }

    const {enter, exit} = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
  }

  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys = definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);

    for (const key of keys) {
      const subNode = node[key];

      if (Array.isArray(subNode)) {
        for (let i = 0; i < subNode.length; i++) {
          const child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node,
            key,
            index: i,
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node,
          key,
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }

    if (exit) exit(node, ancestors, state);
  }

  var traverse_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$L,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$M = isBinding;

  var _getBindingIdentifiers$1 = _interopRequireDefault$q(
    getBindingIdentifiers_1,
  );

  function _interopRequireDefault$q(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function isBinding(node, parent, grandparent) {
    if (
      grandparent &&
      node.type === 'Identifier' &&
      parent.type === 'ObjectProperty' &&
      grandparent.type === 'ObjectExpression'
    ) {
      return false;
    }

    const keys = _getBindingIdentifiers$1.default.keys[parent.type];

    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const val = parent[key];

        if (Array.isArray(val)) {
          if (val.indexOf(node) >= 0) return true;
        } else {
          if (val === node) return true;
        }
      }
    }

    return false;
  }

  var isBinding_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$M,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$N = isLet;

  function isLet(node) {
    return (
      (0, generated.isVariableDeclaration)(node) &&
      (node.kind !== 'var' || node[constants.BLOCK_SCOPED_SYMBOL])
    );
  }

  var isLet_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$N,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$O = isBlockScoped;

  var _isLet = _interopRequireDefault$r(isLet_1);

  function _interopRequireDefault$r(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function isBlockScoped(node) {
    return (
      (0, generated.isFunctionDeclaration)(node) ||
      (0, generated.isClassDeclaration)(node) ||
      (0, _isLet.default)(node)
    );
  }

  var isBlockScoped_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$O,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$P = isImmutable$1;

  var _isType$1 = _interopRequireDefault$s(isType_1);

  function _interopRequireDefault$s(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function isImmutable$1(node) {
    if ((0, _isType$1.default)(node.type, 'Immutable')) return true;

    if ((0, generated.isIdentifier)(node)) {
      if (node.name === 'undefined') {
        return true;
      } else {
        return false;
      }
    }

    return false;
  }

  var isImmutable_1$1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$P,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$Q = isNodesEquivalent;

  function isNodesEquivalent(a, b) {
    if (
      typeof a !== 'object' ||
      typeof b !== 'object' ||
      a == null ||
      b == null
    ) {
      return a === b;
    }

    if (a.type !== b.type) {
      return false;
    }

    const fields = Object.keys(definitions.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = definitions.VISITOR_KEYS[a.type];

    for (const field of fields) {
      if (typeof a[field] !== typeof b[field]) {
        return false;
      }

      if (a[field] == null && b[field] == null) {
        continue;
      } else if (a[field] == null || b[field] == null) {
        return false;
      }

      if (Array.isArray(a[field])) {
        if (!Array.isArray(b[field])) {
          return false;
        }

        if (a[field].length !== b[field].length) {
          return false;
        }

        for (let i = 0; i < a[field].length; i++) {
          if (!isNodesEquivalent(a[field][i], b[field][i])) {
            return false;
          }
        }

        continue;
      }

      if (
        typeof a[field] === 'object' &&
        !(visitorKeys != null && visitorKeys.includes(field))
      ) {
        for (const key of Object.keys(a[field])) {
          if (a[field][key] !== b[field][key]) {
            return false;
          }
        }

        continue;
      }

      if (!isNodesEquivalent(a[field], b[field])) {
        return false;
      }
    }

    return true;
  }

  var isNodesEquivalent_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$Q,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$R = isReferenced;

  function isReferenced(node, parent, grandparent) {
    switch (parent.type) {
      case 'MemberExpression':
      case 'JSXMemberExpression':
      case 'OptionalMemberExpression':
        if (parent.property === node) {
          return !!parent.computed;
        }

        return parent.object === node;

      case 'VariableDeclarator':
        return parent.init === node;

      case 'ArrowFunctionExpression':
        return parent.body === node;

      case 'PrivateName':
        return false;

      case 'ClassMethod':
      case 'ClassPrivateMethod':
      case 'ObjectMethod':
        if (parent.params.includes(node)) {
          return false;
        }

      case 'ObjectProperty':
      case 'ClassProperty':
      case 'ClassPrivateProperty':
        if (parent.key === node) {
          return !!parent.computed;
        }

        if (parent.value === node) {
          return !grandparent || grandparent.type !== 'ObjectPattern';
        }

        return true;

      case 'ClassDeclaration':
      case 'ClassExpression':
        return parent.superClass === node;

      case 'AssignmentExpression':
        return parent.right === node;

      case 'AssignmentPattern':
        return parent.right === node;

      case 'LabeledStatement':
        return false;

      case 'CatchClause':
        return false;

      case 'RestElement':
        return false;

      case 'BreakStatement':
      case 'ContinueStatement':
        return false;

      case 'FunctionDeclaration':
      case 'FunctionExpression':
        return false;

      case 'ExportNamespaceSpecifier':
      case 'ExportDefaultSpecifier':
        return false;

      case 'ExportSpecifier':
        if (grandparent != null && grandparent.source) {
          return false;
        }

        return parent.local === node;

      case 'ImportDefaultSpecifier':
      case 'ImportNamespaceSpecifier':
      case 'ImportSpecifier':
        return false;

      case 'JSXAttribute':
        return false;

      case 'ObjectPattern':
      case 'ArrayPattern':
        return false;

      case 'MetaProperty':
        return false;

      case 'ObjectTypeProperty':
        return parent.key !== node;

      case 'TSEnumMember':
        return parent.id !== node;

      case 'TSPropertySignature':
        if (parent.key === node) {
          return !!parent.computed;
        }

        return true;
    }

    return true;
  }

  var isReferenced_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$R,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$S = isScope;

  function isScope(node, parent) {
    if (
      (0, generated.isBlockStatement)(node) &&
      ((0, generated.isFunction)(parent) ||
        (0, generated.isCatchClause)(parent))
    ) {
      return false;
    }

    if (
      (0, generated.isPattern)(node) &&
      ((0, generated.isFunction)(parent) ||
        (0, generated.isCatchClause)(parent))
    ) {
      return true;
    }

    return (0, generated.isScopable)(node);
  }

  var isScope_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$S,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$T = isSpecifierDefault;

  function isSpecifierDefault(specifier) {
    return (
      (0, generated.isImportDefaultSpecifier)(specifier) ||
      (0, generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: 'default',
      })
    );
  }

  var isSpecifierDefault_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$T,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$U = isValidES3Identifier;

  var _isValidIdentifier$1 = _interopRequireDefault$t(isValidIdentifier_1);

  function _interopRequireDefault$t(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  const RESERVED_WORDS_ES3_ONLY = new Set([
    'abstract',
    'boolean',
    'byte',
    'char',
    'double',
    'enum',
    'final',
    'float',
    'goto',
    'implements',
    'int',
    'interface',
    'long',
    'native',
    'package',
    'private',
    'protected',
    'public',
    'short',
    'static',
    'synchronized',
    'throws',
    'transient',
    'volatile',
  ]);

  function isValidES3Identifier(name) {
    return (
      (0, _isValidIdentifier$1.default)(name) &&
      !RESERVED_WORDS_ES3_ONLY.has(name)
    );
  }

  var isValidES3Identifier_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$U,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$V = isVar;

  function isVar(node) {
    return (
      (0, generated.isVariableDeclaration)(node, {
        kind: 'var',
      }) && !node[constants.BLOCK_SCOPED_SYMBOL]
    );
  }

  var isVar_1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$V,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var generated$4 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
  });

  var _generated5 = /*@__PURE__*/ getAugmentedNamespace(generated$4);

  var lib$2 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toSequenceExpression: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
    };
    Object.defineProperty(exports, 'assertNode', {
      enumerable: true,
      get: function () {
        return _assertNode.default;
      },
    });
    Object.defineProperty(exports, 'createTypeAnnotationBasedOnTypeof', {
      enumerable: true,
      get: function () {
        return _createTypeAnnotationBasedOnTypeof.default;
      },
    });
    Object.defineProperty(exports, 'createUnionTypeAnnotation', {
      enumerable: true,
      get: function () {
        return _createFlowUnionType.default;
      },
    });
    Object.defineProperty(exports, 'createFlowUnionType', {
      enumerable: true,
      get: function () {
        return _createFlowUnionType.default;
      },
    });
    Object.defineProperty(exports, 'createTSUnionType', {
      enumerable: true,
      get: function () {
        return _createTSUnionType.default;
      },
    });
    Object.defineProperty(exports, 'cloneNode', {
      enumerable: true,
      get: function () {
        return _cloneNode.default;
      },
    });
    Object.defineProperty(exports, 'clone', {
      enumerable: true,
      get: function () {
        return _clone.default;
      },
    });
    Object.defineProperty(exports, 'cloneDeep', {
      enumerable: true,
      get: function () {
        return _cloneDeep.default;
      },
    });
    Object.defineProperty(exports, 'cloneDeepWithoutLoc', {
      enumerable: true,
      get: function () {
        return _cloneDeepWithoutLoc.default;
      },
    });
    Object.defineProperty(exports, 'cloneWithoutLoc', {
      enumerable: true,
      get: function () {
        return _cloneWithoutLoc.default;
      },
    });
    Object.defineProperty(exports, 'addComment', {
      enumerable: true,
      get: function () {
        return _addComment.default;
      },
    });
    Object.defineProperty(exports, 'addComments', {
      enumerable: true,
      get: function () {
        return _addComments.default;
      },
    });
    Object.defineProperty(exports, 'inheritInnerComments', {
      enumerable: true,
      get: function () {
        return _inheritInnerComments.default;
      },
    });
    Object.defineProperty(exports, 'inheritLeadingComments', {
      enumerable: true,
      get: function () {
        return _inheritLeadingComments.default;
      },
    });
    Object.defineProperty(exports, 'inheritsComments', {
      enumerable: true,
      get: function () {
        return _inheritsComments.default;
      },
    });
    Object.defineProperty(exports, 'inheritTrailingComments', {
      enumerable: true,
      get: function () {
        return _inheritTrailingComments.default;
      },
    });
    Object.defineProperty(exports, 'removeComments', {
      enumerable: true,
      get: function () {
        return _removeComments.default;
      },
    });
    Object.defineProperty(exports, 'ensureBlock', {
      enumerable: true,
      get: function () {
        return _ensureBlock.default;
      },
    });
    Object.defineProperty(exports, 'toBindingIdentifierName', {
      enumerable: true,
      get: function () {
        return _toBindingIdentifierName.default;
      },
    });
    Object.defineProperty(exports, 'toBlock', {
      enumerable: true,
      get: function () {
        return _toBlock.default;
      },
    });
    Object.defineProperty(exports, 'toComputedKey', {
      enumerable: true,
      get: function () {
        return _toComputedKey.default;
      },
    });
    Object.defineProperty(exports, 'toExpression', {
      enumerable: true,
      get: function () {
        return _toExpression.default;
      },
    });
    Object.defineProperty(exports, 'toIdentifier', {
      enumerable: true,
      get: function () {
        return _toIdentifier.default;
      },
    });
    Object.defineProperty(exports, 'toKeyAlias', {
      enumerable: true,
      get: function () {
        return _toKeyAlias.default;
      },
    });
    Object.defineProperty(exports, 'toSequenceExpression', {
      enumerable: true,
      get: function () {
        return _toSequenceExpression.default;
      },
    });
    Object.defineProperty(exports, 'toStatement', {
      enumerable: true,
      get: function () {
        return _toStatement.default;
      },
    });
    Object.defineProperty(exports, 'valueToNode', {
      enumerable: true,
      get: function () {
        return _valueToNode.default;
      },
    });
    Object.defineProperty(exports, 'appendToMemberExpression', {
      enumerable: true,
      get: function () {
        return _appendToMemberExpression.default;
      },
    });
    Object.defineProperty(exports, 'inherits', {
      enumerable: true,
      get: function () {
        return _inherits.default;
      },
    });
    Object.defineProperty(exports, 'prependToMemberExpression', {
      enumerable: true,
      get: function () {
        return _prependToMemberExpression.default;
      },
    });
    Object.defineProperty(exports, 'removeProperties', {
      enumerable: true,
      get: function () {
        return _removeProperties.default;
      },
    });
    Object.defineProperty(exports, 'removePropertiesDeep', {
      enumerable: true,
      get: function () {
        return _removePropertiesDeep.default;
      },
    });
    Object.defineProperty(exports, 'removeTypeDuplicates', {
      enumerable: true,
      get: function () {
        return _removeTypeDuplicates.default;
      },
    });
    Object.defineProperty(exports, 'getBindingIdentifiers', {
      enumerable: true,
      get: function () {
        return _getBindingIdentifiers.default;
      },
    });
    Object.defineProperty(exports, 'getOuterBindingIdentifiers', {
      enumerable: true,
      get: function () {
        return _getOuterBindingIdentifiers.default;
      },
    });
    Object.defineProperty(exports, 'traverse', {
      enumerable: true,
      get: function () {
        return _traverse.default;
      },
    });
    Object.defineProperty(exports, 'traverseFast', {
      enumerable: true,
      get: function () {
        return _traverseFast.default;
      },
    });
    Object.defineProperty(exports, 'shallowEqual', {
      enumerable: true,
      get: function () {
        return _shallowEqual.default;
      },
    });
    Object.defineProperty(exports, 'is', {
      enumerable: true,
      get: function () {
        return _is.default;
      },
    });
    Object.defineProperty(exports, 'isBinding', {
      enumerable: true,
      get: function () {
        return _isBinding.default;
      },
    });
    Object.defineProperty(exports, 'isBlockScoped', {
      enumerable: true,
      get: function () {
        return _isBlockScoped.default;
      },
    });
    Object.defineProperty(exports, 'isImmutable', {
      enumerable: true,
      get: function () {
        return _isImmutable.default;
      },
    });
    Object.defineProperty(exports, 'isLet', {
      enumerable: true,
      get: function () {
        return _isLet.default;
      },
    });
    Object.defineProperty(exports, 'isNode', {
      enumerable: true,
      get: function () {
        return _isNode.default;
      },
    });
    Object.defineProperty(exports, 'isNodesEquivalent', {
      enumerable: true,
      get: function () {
        return _isNodesEquivalent.default;
      },
    });
    Object.defineProperty(exports, 'isPlaceholderType', {
      enumerable: true,
      get: function () {
        return _isPlaceholderType.default;
      },
    });
    Object.defineProperty(exports, 'isReferenced', {
      enumerable: true,
      get: function () {
        return _isReferenced.default;
      },
    });
    Object.defineProperty(exports, 'isScope', {
      enumerable: true,
      get: function () {
        return _isScope.default;
      },
    });
    Object.defineProperty(exports, 'isSpecifierDefault', {
      enumerable: true,
      get: function () {
        return _isSpecifierDefault.default;
      },
    });
    Object.defineProperty(exports, 'isType', {
      enumerable: true,
      get: function () {
        return _isType.default;
      },
    });
    Object.defineProperty(exports, 'isValidES3Identifier', {
      enumerable: true,
      get: function () {
        return _isValidES3Identifier.default;
      },
    });
    Object.defineProperty(exports, 'isValidIdentifier', {
      enumerable: true,
      get: function () {
        return _isValidIdentifier.default;
      },
    });
    Object.defineProperty(exports, 'isVar', {
      enumerable: true,
      get: function () {
        return _isVar.default;
      },
    });
    Object.defineProperty(exports, 'matchesPattern', {
      enumerable: true,
      get: function () {
        return _matchesPattern.default;
      },
    });
    Object.defineProperty(exports, 'validate', {
      enumerable: true,
      get: function () {
        return _validate.default;
      },
    });
    Object.defineProperty(exports, 'buildMatchMemberExpression', {
      enumerable: true,
      get: function () {
        return _buildMatchMemberExpression.default;
      },
    });
    exports.react = void 0;

    var _isReactComponent = _interopRequireDefault(isReactComponent_1);

    var _isCompatTag = _interopRequireDefault(isCompatTag_1);

    var _buildChildren = _interopRequireDefault(buildChildren_1);

    var _assertNode = _interopRequireDefault(assertNode_1);

    Object.keys(generated$2).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === generated$2[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return generated$2[key];
        },
      });
    });

    var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(
      createTypeAnnotationBasedOnTypeof_1,
    );

    var _createFlowUnionType = _interopRequireDefault(createFlowUnionType_1);

    var _createTSUnionType = _interopRequireDefault(createTSUnionType_1);

    Object.keys(generated$1).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === generated$1[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return generated$1[key];
        },
      });
    });
    Object.keys(uppercase).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === uppercase[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return uppercase[key];
        },
      });
    });

    var _cloneNode = _interopRequireDefault(cloneNode_1);

    var _clone = _interopRequireDefault(clone_1);

    var _cloneDeep = _interopRequireDefault(cloneDeep_1);

    var _cloneDeepWithoutLoc = _interopRequireDefault(cloneDeepWithoutLoc_1);

    var _cloneWithoutLoc = _interopRequireDefault(cloneWithoutLoc_1);

    var _addComment = _interopRequireDefault(addComment_1);

    var _addComments = _interopRequireDefault(addComments_1);

    var _inheritInnerComments = _interopRequireDefault(inheritInnerComments_1);

    var _inheritLeadingComments = _interopRequireDefault(
      inheritLeadingComments_1,
    );

    var _inheritsComments = _interopRequireDefault(inheritsComments_1);

    var _inheritTrailingComments = _interopRequireDefault(
      inheritTrailingComments_1,
    );

    var _removeComments = _interopRequireDefault(removeComments_1);

    Object.keys(generated$3).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === generated$3[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return generated$3[key];
        },
      });
    });
    Object.keys(constants).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === constants[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return constants[key];
        },
      });
    });

    var _ensureBlock = _interopRequireDefault(ensureBlock_1);

    var _toBindingIdentifierName = _interopRequireDefault(
      toBindingIdentifierName_1,
    );

    var _toBlock = _interopRequireDefault(toBlock_1);

    var _toComputedKey = _interopRequireDefault(toComputedKey_1);

    var _toExpression = _interopRequireDefault(toExpression_1);

    var _toIdentifier = _interopRequireDefault(toIdentifier_1);

    var _toKeyAlias = _interopRequireDefault(toKeyAlias_1);

    var _toSequenceExpression = _interopRequireDefault(toSequenceExpression_1);

    var _toStatement = _interopRequireDefault(toStatement_1);

    var _valueToNode = _interopRequireDefault(valueToNode_1);

    Object.keys(definitions).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === definitions[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return definitions[key];
        },
      });
    });

    var _appendToMemberExpression = _interopRequireDefault(
      appendToMemberExpression_1,
    );

    var _inherits = _interopRequireDefault(inherits_1);

    var _prependToMemberExpression = _interopRequireDefault(
      prependToMemberExpression_1,
    );

    var _removeProperties = _interopRequireDefault(removeProperties_1);

    var _removePropertiesDeep = _interopRequireDefault(removePropertiesDeep_1);

    var _removeTypeDuplicates = _interopRequireDefault(removeTypeDuplicates_1);

    var _getBindingIdentifiers = _interopRequireDefault(
      getBindingIdentifiers_1,
    );

    var _getOuterBindingIdentifiers = _interopRequireDefault(
      getOuterBindingIdentifiers_1,
    );

    var _traverse = _interopRequireWildcard(traverse_1);

    Object.keys(_traverse).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _traverse[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _traverse[key];
        },
      });
    });

    var _traverseFast = _interopRequireDefault(traverseFast_1);

    var _shallowEqual = _interopRequireDefault(shallowEqual_1);

    var _is = _interopRequireDefault(is_1);

    var _isBinding = _interopRequireDefault(isBinding_1);

    var _isBlockScoped = _interopRequireDefault(isBlockScoped_1);

    var _isImmutable = _interopRequireDefault(isImmutable_1$1);

    var _isLet = _interopRequireDefault(isLet_1);

    var _isNode = _interopRequireDefault(isNode_1);

    var _isNodesEquivalent = _interopRequireDefault(isNodesEquivalent_1);

    var _isPlaceholderType = _interopRequireDefault(isPlaceholderType_1);

    var _isReferenced = _interopRequireDefault(isReferenced_1);

    var _isScope = _interopRequireDefault(isScope_1);

    var _isSpecifierDefault = _interopRequireDefault(isSpecifierDefault_1);

    var _isType = _interopRequireDefault(isType_1);

    var _isValidES3Identifier = _interopRequireDefault(isValidES3Identifier_1);

    var _isValidIdentifier = _interopRequireDefault(isValidIdentifier_1);

    var _isVar = _interopRequireDefault(isVar_1);

    var _matchesPattern = _interopRequireDefault(matchesPattern_1);

    var _validate = _interopRequireDefault(validate_1);

    var _buildMatchMemberExpression = _interopRequireDefault(
      buildMatchMemberExpression_1,
    );

    Object.keys(generated).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === generated[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return generated[key];
        },
      });
    });
    Object.keys(_generated5).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated5[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated5[key];
        },
      });
    });

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    const react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default,
    };
    exports.react = react;
  });

  var virtualTypes = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    const ReferencedIdentifier = {
      types: ['Identifier', 'JSXIdentifier'],

      checkPath(path, opts) {
        const {node, parent} = path;

        if (
          !t.isIdentifier(node, opts) &&
          !t.isJSXMemberExpression(parent, opts)
        ) {
          if (t.isJSXIdentifier(node, opts)) {
            if (t.react.isCompatTag(node.name)) return false;
          } else {
            return false;
          }
        }

        return t.isReferenced(node, parent, path.parentPath.parent);
      },
    };
    exports.ReferencedIdentifier = ReferencedIdentifier;
    const ReferencedMemberExpression = {
      types: ['MemberExpression'],

      checkPath({node, parent}) {
        return t.isMemberExpression(node) && t.isReferenced(node, parent);
      },
    };
    exports.ReferencedMemberExpression = ReferencedMemberExpression;
    const BindingIdentifier = {
      types: ['Identifier'],

      checkPath(path) {
        const {node, parent} = path;
        const grandparent = path.parentPath.parent;
        return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);
      },
    };
    exports.BindingIdentifier = BindingIdentifier;
    const Statement = {
      types: ['Statement'],

      checkPath({node, parent}) {
        if (t.isStatement(node)) {
          if (t.isVariableDeclaration(node)) {
            if (
              t.isForXStatement(parent, {
                left: node,
              })
            )
              return false;
            if (
              t.isForStatement(parent, {
                init: node,
              })
            )
              return false;
          }

          return true;
        } else {
          return false;
        }
      },
    };
    exports.Statement = Statement;
    const Expression = {
      types: ['Expression'],

      checkPath(path) {
        if (path.isIdentifier()) {
          return path.isReferencedIdentifier();
        } else {
          return t.isExpression(path.node);
        }
      },
    };
    exports.Expression = Expression;
    const Scope = {
      types: ['Scopable', 'Pattern'],

      checkPath(path) {
        return t.isScope(path.node, path.parent);
      },
    };
    exports.Scope = Scope;
    const Referenced = {
      checkPath(path) {
        return t.isReferenced(path.node, path.parent);
      },
    };
    exports.Referenced = Referenced;
    const BlockScoped = {
      checkPath(path) {
        return t.isBlockScoped(path.node);
      },
    };
    exports.BlockScoped = BlockScoped;
    const Var = {
      types: ['VariableDeclaration'],

      checkPath(path) {
        return t.isVar(path.node);
      },
    };
    exports.Var = Var;
    const User = {
      checkPath(path) {
        return path.node && !!path.node.loc;
      },
    };
    exports.User = User;
    const Generated = {
      checkPath(path) {
        return !path.isUser();
      },
    };
    exports.Generated = Generated;
    const Pure = {
      checkPath(path, opts) {
        return path.scope.isPure(path.node, opts);
      },
    };
    exports.Pure = Pure;
    const Flow = {
      types: [
        'Flow',
        'ImportDeclaration',
        'ExportDeclaration',
        'ImportSpecifier',
      ],

      checkPath({node}) {
        if (t.isFlow(node)) {
          return true;
        } else if (t.isImportDeclaration(node)) {
          return node.importKind === 'type' || node.importKind === 'typeof';
        } else if (t.isExportDeclaration(node)) {
          return node.exportKind === 'type';
        } else if (t.isImportSpecifier(node)) {
          return node.importKind === 'type' || node.importKind === 'typeof';
        } else {
          return false;
        }
      },
    };
    exports.Flow = Flow;
    const RestProperty = {
      types: ['RestElement'],

      checkPath(path) {
        return path.parentPath && path.parentPath.isObjectPattern();
      },
    };
    exports.RestProperty = RestProperty;
    const SpreadProperty = {
      types: ['RestElement'],

      checkPath(path) {
        return path.parentPath && path.parentPath.isObjectExpression();
      },
    };
    exports.SpreadProperty = SpreadProperty;
    const ExistentialTypeParam = {
      types: ['ExistsTypeAnnotation'],
    };
    exports.ExistentialTypeParam = ExistentialTypeParam;
    const NumericLiteralTypeAnnotation = {
      types: ['NumberLiteralTypeAnnotation'],
    };
    exports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
    const ForAwaitStatement = {
      types: ['ForOfStatement'],

      checkPath({node}) {
        return node.await === true;
      },
    };
    exports.ForAwaitStatement = ForAwaitStatement;
  });

  var binding$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    class Binding {
      constructor({identifier, scope, path, kind}) {
        this.identifier = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.kind = void 0;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.identifier = identifier;
        this.scope = scope;
        this.path = path;
        this.kind = kind;
        this.clearValue();
      }

      deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }

      setValue(value) {
        if (this.hasDeoptedValue) return;
        this.hasValue = true;
        this.value = value;
      }

      clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }

      reassign(path) {
        this.constant = false;

        if (this.constantViolations.indexOf(path) !== -1) {
          return;
        }

        this.constantViolations.push(path);
      }

      reference(path) {
        if (this.referencePaths.indexOf(path) !== -1) {
          return;
        }

        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      }

      dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    }

    exports.default = Binding;
  });

  var _default$W = splitExportDeclaration;

  var t = _interopRequireWildcard$5(lib$2);

  function _getRequireWildcardCache$5() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$5 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$5(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$5();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function splitExportDeclaration(exportDeclaration) {
    if (!exportDeclaration.isExportDeclaration()) {
      throw new Error('Only export declarations can be split.');
    }

    const isDefault = exportDeclaration.isExportDefaultDeclaration();
    const declaration = exportDeclaration.get('declaration');
    const isClassDeclaration = declaration.isClassDeclaration();

    if (isDefault) {
      const standaloneDeclaration =
        declaration.isFunctionDeclaration() || isClassDeclaration;
      const scope = declaration.isScope()
        ? declaration.scope.parent
        : declaration.scope;
      let id = declaration.node.id;
      let needBindingRegistration = false;

      if (!id) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier('default');

        if (
          standaloneDeclaration ||
          declaration.isFunctionExpression() ||
          declaration.isClassExpression()
        ) {
          declaration.node.id = t.cloneNode(id);
        }
      }

      const updatedDeclaration = standaloneDeclaration
        ? declaration
        : t.variableDeclaration('var', [
            t.variableDeclarator(t.cloneNode(id), declaration.node),
          ]);
      const updatedExportDeclaration = t.exportNamedDeclaration(null, [
        t.exportSpecifier(t.cloneNode(id), t.identifier('default')),
      ]);
      exportDeclaration.insertAfter(updatedExportDeclaration);
      exportDeclaration.replaceWith(updatedDeclaration);

      if (needBindingRegistration) {
        scope.registerDeclaration(exportDeclaration);
      }

      return exportDeclaration;
    }

    if (exportDeclaration.get('specifiers').length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }

    const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    const specifiers = Object.keys(bindingIdentifiers).map((name) => {
      return t.exportSpecifier(t.identifier(name), t.identifier(name));
    });
    const aliasDeclar = t.exportNamedDeclaration(null, specifiers);
    exportDeclaration.insertAfter(aliasDeclar);
    exportDeclaration.replaceWith(declaration.node);
    return exportDeclaration;
  }

  var lib$3 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$W,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var renamer = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    _interopRequireDefault(binding$1);

    var _helperSplitExportDeclaration = _interopRequireDefault(lib$3);

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    const renameVisitor = {
      ReferencedIdentifier({node}, state) {
        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      },

      Scope(path, state) {
        if (
          !path.scope.bindingIdentifierEquals(
            state.oldName,
            state.binding.identifier,
          )
        ) {
          skipAllButComputedMethodKey(path);
        }
      },

      'AssignmentExpression|Declaration|VariableDeclarator'(path, state) {
        if (path.isVariableDeclaration()) return;
        const ids = path.getOuterBindingIdentifiers();

        for (const name in ids) {
          if (name === state.oldName) ids[name].name = state.newName;
        }
      },
    };

    class Renamer {
      constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }

      maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;

        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }

        if (
          maybeExportDeclar.isExportDefaultDeclaration() &&
          !maybeExportDeclar.get('declaration').node.id
        ) {
          return;
        }

        (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
      }

      maybeConvertFromClassFunctionDeclaration(path) {
        return;
      }

      maybeConvertFromClassFunctionExpression(path) {
        return;
      }

      rename(block) {
        const {binding, oldName, newName} = this;
        const {scope, path} = binding;
        const parentDeclar = path.find(
          (path) =>
            path.isDeclaration() ||
            path.isFunctionExpression() ||
            path.isClassExpression(),
        );

        if (parentDeclar) {
          const bindingIds = parentDeclar.getOuterBindingIdentifiers();

          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }

        const blockToTraverse = block || scope.block;

        if (
          (blockToTraverse == null ? void 0 : blockToTraverse.type) ===
          'SwitchStatement'
        ) {
          blockToTraverse.cases.forEach((c) => {
            scope.traverse(c, renameVisitor, this);
          });
        } else {
          scope.traverse(blockToTraverse, renameVisitor, this);
        }

        if (!block) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }

        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
          this.maybeConvertFromClassFunctionExpression(parentDeclar);
        }
      }
    }

    exports.default = Renamer;

    function skipAllButComputedMethodKey(path) {
      if (!path.isMethod() || !path.node.computed) {
        path.skip();
        return;
      }

      const keys = t.VISITOR_KEYS[path.type];

      for (const key of keys) {
        if (key !== 'key') path.skipKey(key);
      }
    }
  });

  var cache = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.clear = clear;
    exports.clearPath = clearPath;
    exports.clearScope = clearScope;
    exports.scope = exports.path = void 0;
    let path = new WeakMap();
    exports.path = path;
    let scope = new WeakMap();
    exports.scope = scope;

    function clear() {
      clearPath();
      clearScope();
    }

    function clearPath() {
      exports.path = path = new WeakMap();
    }

    function clearScope() {
      exports.scope = scope = new WeakMap();
    }
  });

  var builtin = {
    Array: false,
    ArrayBuffer: false,
    Atomics: false,
    BigInt: false,
    BigInt64Array: false,
    BigUint64Array: false,
    Boolean: false,
    constructor: false,
    DataView: false,
    Date: false,
    decodeURI: false,
    decodeURIComponent: false,
    encodeURI: false,
    encodeURIComponent: false,
    Error: false,
    escape: false,
    eval: false,
    EvalError: false,
    Float32Array: false,
    Float64Array: false,
    Function: false,
    globalThis: false,
    hasOwnProperty: false,
    Infinity: false,
    Int16Array: false,
    Int32Array: false,
    Int8Array: false,
    isFinite: false,
    isNaN: false,
    isPrototypeOf: false,
    JSON: false,
    Map: false,
    Math: false,
    NaN: false,
    Number: false,
    Object: false,
    parseFloat: false,
    parseInt: false,
    Promise: false,
    propertyIsEnumerable: false,
    Proxy: false,
    RangeError: false,
    ReferenceError: false,
    Reflect: false,
    RegExp: false,
    Set: false,
    SharedArrayBuffer: false,
    String: false,
    Symbol: false,
    SyntaxError: false,
    toLocaleString: false,
    toString: false,
    TypeError: false,
    Uint16Array: false,
    Uint32Array: false,
    Uint8Array: false,
    Uint8ClampedArray: false,
    undefined: false,
    unescape: false,
    URIError: false,
    valueOf: false,
    WeakMap: false,
    WeakSet: false,
  };
  var es5 = {
    Array: false,
    Boolean: false,
    constructor: false,
    Date: false,
    decodeURI: false,
    decodeURIComponent: false,
    encodeURI: false,
    encodeURIComponent: false,
    Error: false,
    escape: false,
    eval: false,
    EvalError: false,
    Function: false,
    hasOwnProperty: false,
    Infinity: false,
    isFinite: false,
    isNaN: false,
    isPrototypeOf: false,
    JSON: false,
    Math: false,
    NaN: false,
    Number: false,
    Object: false,
    parseFloat: false,
    parseInt: false,
    propertyIsEnumerable: false,
    RangeError: false,
    ReferenceError: false,
    RegExp: false,
    String: false,
    SyntaxError: false,
    toLocaleString: false,
    toString: false,
    TypeError: false,
    undefined: false,
    unescape: false,
    URIError: false,
    valueOf: false,
  };
  var es2015 = {
    Array: false,
    ArrayBuffer: false,
    Boolean: false,
    constructor: false,
    DataView: false,
    Date: false,
    decodeURI: false,
    decodeURIComponent: false,
    encodeURI: false,
    encodeURIComponent: false,
    Error: false,
    escape: false,
    eval: false,
    EvalError: false,
    Float32Array: false,
    Float64Array: false,
    Function: false,
    hasOwnProperty: false,
    Infinity: false,
    Int16Array: false,
    Int32Array: false,
    Int8Array: false,
    isFinite: false,
    isNaN: false,
    isPrototypeOf: false,
    JSON: false,
    Map: false,
    Math: false,
    NaN: false,
    Number: false,
    Object: false,
    parseFloat: false,
    parseInt: false,
    Promise: false,
    propertyIsEnumerable: false,
    Proxy: false,
    RangeError: false,
    ReferenceError: false,
    Reflect: false,
    RegExp: false,
    Set: false,
    String: false,
    Symbol: false,
    SyntaxError: false,
    toLocaleString: false,
    toString: false,
    TypeError: false,
    Uint16Array: false,
    Uint32Array: false,
    Uint8Array: false,
    Uint8ClampedArray: false,
    undefined: false,
    unescape: false,
    URIError: false,
    valueOf: false,
    WeakMap: false,
    WeakSet: false,
  };
  var es2017 = {
    Array: false,
    ArrayBuffer: false,
    Atomics: false,
    Boolean: false,
    constructor: false,
    DataView: false,
    Date: false,
    decodeURI: false,
    decodeURIComponent: false,
    encodeURI: false,
    encodeURIComponent: false,
    Error: false,
    escape: false,
    eval: false,
    EvalError: false,
    Float32Array: false,
    Float64Array: false,
    Function: false,
    hasOwnProperty: false,
    Infinity: false,
    Int16Array: false,
    Int32Array: false,
    Int8Array: false,
    isFinite: false,
    isNaN: false,
    isPrototypeOf: false,
    JSON: false,
    Map: false,
    Math: false,
    NaN: false,
    Number: false,
    Object: false,
    parseFloat: false,
    parseInt: false,
    Promise: false,
    propertyIsEnumerable: false,
    Proxy: false,
    RangeError: false,
    ReferenceError: false,
    Reflect: false,
    RegExp: false,
    Set: false,
    SharedArrayBuffer: false,
    String: false,
    Symbol: false,
    SyntaxError: false,
    toLocaleString: false,
    toString: false,
    TypeError: false,
    Uint16Array: false,
    Uint32Array: false,
    Uint8Array: false,
    Uint8ClampedArray: false,
    undefined: false,
    unescape: false,
    URIError: false,
    valueOf: false,
    WeakMap: false,
    WeakSet: false,
  };
  var browser$2 = {
    AbortController: false,
    AbortSignal: false,
    addEventListener: false,
    alert: false,
    AnalyserNode: false,
    Animation: false,
    AnimationEffectReadOnly: false,
    AnimationEffectTiming: false,
    AnimationEffectTimingReadOnly: false,
    AnimationEvent: false,
    AnimationPlaybackEvent: false,
    AnimationTimeline: false,
    applicationCache: false,
    ApplicationCache: false,
    ApplicationCacheErrorEvent: false,
    atob: false,
    Attr: false,
    Audio: false,
    AudioBuffer: false,
    AudioBufferSourceNode: false,
    AudioContext: false,
    AudioDestinationNode: false,
    AudioListener: false,
    AudioNode: false,
    AudioParam: false,
    AudioProcessingEvent: false,
    AudioScheduledSourceNode: false,
    'AudioWorkletGlobalScope ': false,
    AudioWorkletNode: false,
    AudioWorkletProcessor: false,
    BarProp: false,
    BaseAudioContext: false,
    BatteryManager: false,
    BeforeUnloadEvent: false,
    BiquadFilterNode: false,
    Blob: false,
    BlobEvent: false,
    blur: false,
    BroadcastChannel: false,
    btoa: false,
    BudgetService: false,
    ByteLengthQueuingStrategy: false,
    Cache: false,
    caches: false,
    CacheStorage: false,
    cancelAnimationFrame: false,
    cancelIdleCallback: false,
    CanvasCaptureMediaStreamTrack: false,
    CanvasGradient: false,
    CanvasPattern: false,
    CanvasRenderingContext2D: false,
    ChannelMergerNode: false,
    ChannelSplitterNode: false,
    CharacterData: false,
    clearInterval: false,
    clearTimeout: false,
    clientInformation: false,
    ClipboardEvent: false,
    close: false,
    closed: false,
    CloseEvent: false,
    Comment: false,
    CompositionEvent: false,
    confirm: false,
    console: false,
    ConstantSourceNode: false,
    ConvolverNode: false,
    CountQueuingStrategy: false,
    createImageBitmap: false,
    Credential: false,
    CredentialsContainer: false,
    crypto: false,
    Crypto: false,
    CryptoKey: false,
    CSS: false,
    CSSConditionRule: false,
    CSSFontFaceRule: false,
    CSSGroupingRule: false,
    CSSImportRule: false,
    CSSKeyframeRule: false,
    CSSKeyframesRule: false,
    CSSMediaRule: false,
    CSSNamespaceRule: false,
    CSSPageRule: false,
    CSSRule: false,
    CSSRuleList: false,
    CSSStyleDeclaration: false,
    CSSStyleRule: false,
    CSSStyleSheet: false,
    CSSSupportsRule: false,
    CustomElementRegistry: false,
    customElements: false,
    CustomEvent: false,
    DataTransfer: false,
    DataTransferItem: false,
    DataTransferItemList: false,
    defaultstatus: false,
    defaultStatus: false,
    DelayNode: false,
    DeviceMotionEvent: false,
    DeviceOrientationEvent: false,
    devicePixelRatio: false,
    dispatchEvent: false,
    document: false,
    Document: false,
    DocumentFragment: false,
    DocumentType: false,
    DOMError: false,
    DOMException: false,
    DOMImplementation: false,
    DOMMatrix: false,
    DOMMatrixReadOnly: false,
    DOMParser: false,
    DOMPoint: false,
    DOMPointReadOnly: false,
    DOMQuad: false,
    DOMRect: false,
    DOMRectReadOnly: false,
    DOMStringList: false,
    DOMStringMap: false,
    DOMTokenList: false,
    DragEvent: false,
    DynamicsCompressorNode: false,
    Element: false,
    ErrorEvent: false,
    event: false,
    Event: false,
    EventSource: false,
    EventTarget: false,
    external: false,
    fetch: false,
    File: false,
    FileList: false,
    FileReader: false,
    find: false,
    focus: false,
    FocusEvent: false,
    FontFace: false,
    FontFaceSetLoadEvent: false,
    FormData: false,
    frameElement: false,
    frames: false,
    GainNode: false,
    Gamepad: false,
    GamepadButton: false,
    GamepadEvent: false,
    getComputedStyle: false,
    getSelection: false,
    HashChangeEvent: false,
    Headers: false,
    history: false,
    History: false,
    HTMLAllCollection: false,
    HTMLAnchorElement: false,
    HTMLAreaElement: false,
    HTMLAudioElement: false,
    HTMLBaseElement: false,
    HTMLBodyElement: false,
    HTMLBRElement: false,
    HTMLButtonElement: false,
    HTMLCanvasElement: false,
    HTMLCollection: false,
    HTMLContentElement: false,
    HTMLDataElement: false,
    HTMLDataListElement: false,
    HTMLDetailsElement: false,
    HTMLDialogElement: false,
    HTMLDirectoryElement: false,
    HTMLDivElement: false,
    HTMLDListElement: false,
    HTMLDocument: false,
    HTMLElement: false,
    HTMLEmbedElement: false,
    HTMLFieldSetElement: false,
    HTMLFontElement: false,
    HTMLFormControlsCollection: false,
    HTMLFormElement: false,
    HTMLFrameElement: false,
    HTMLFrameSetElement: false,
    HTMLHeadElement: false,
    HTMLHeadingElement: false,
    HTMLHRElement: false,
    HTMLHtmlElement: false,
    HTMLIFrameElement: false,
    HTMLImageElement: false,
    HTMLInputElement: false,
    HTMLLabelElement: false,
    HTMLLegendElement: false,
    HTMLLIElement: false,
    HTMLLinkElement: false,
    HTMLMapElement: false,
    HTMLMarqueeElement: false,
    HTMLMediaElement: false,
    HTMLMenuElement: false,
    HTMLMetaElement: false,
    HTMLMeterElement: false,
    HTMLModElement: false,
    HTMLObjectElement: false,
    HTMLOListElement: false,
    HTMLOptGroupElement: false,
    HTMLOptionElement: false,
    HTMLOptionsCollection: false,
    HTMLOutputElement: false,
    HTMLParagraphElement: false,
    HTMLParamElement: false,
    HTMLPictureElement: false,
    HTMLPreElement: false,
    HTMLProgressElement: false,
    HTMLQuoteElement: false,
    HTMLScriptElement: false,
    HTMLSelectElement: false,
    HTMLShadowElement: false,
    HTMLSlotElement: false,
    HTMLSourceElement: false,
    HTMLSpanElement: false,
    HTMLStyleElement: false,
    HTMLTableCaptionElement: false,
    HTMLTableCellElement: false,
    HTMLTableColElement: false,
    HTMLTableElement: false,
    HTMLTableRowElement: false,
    HTMLTableSectionElement: false,
    HTMLTemplateElement: false,
    HTMLTextAreaElement: false,
    HTMLTimeElement: false,
    HTMLTitleElement: false,
    HTMLTrackElement: false,
    HTMLUListElement: false,
    HTMLUnknownElement: false,
    HTMLVideoElement: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    IdleDeadline: false,
    IIRFilterNode: false,
    Image: false,
    ImageBitmap: false,
    ImageBitmapRenderingContext: false,
    ImageCapture: false,
    ImageData: false,
    indexedDB: false,
    innerHeight: false,
    innerWidth: false,
    InputEvent: false,
    IntersectionObserver: false,
    IntersectionObserverEntry: false,
    Intl: false,
    isSecureContext: false,
    KeyboardEvent: false,
    KeyframeEffect: false,
    KeyframeEffectReadOnly: false,
    length: false,
    localStorage: false,
    location: true,
    Location: false,
    locationbar: false,
    matchMedia: false,
    MediaDeviceInfo: false,
    MediaDevices: false,
    MediaElementAudioSourceNode: false,
    MediaEncryptedEvent: false,
    MediaError: false,
    MediaKeyMessageEvent: false,
    MediaKeySession: false,
    MediaKeyStatusMap: false,
    MediaKeySystemAccess: false,
    MediaList: false,
    MediaQueryList: false,
    MediaQueryListEvent: false,
    MediaRecorder: false,
    MediaSettingsRange: false,
    MediaSource: false,
    MediaStream: false,
    MediaStreamAudioDestinationNode: false,
    MediaStreamAudioSourceNode: false,
    MediaStreamEvent: false,
    MediaStreamTrack: false,
    MediaStreamTrackEvent: false,
    menubar: false,
    MessageChannel: false,
    MessageEvent: false,
    MessagePort: false,
    MIDIAccess: false,
    MIDIConnectionEvent: false,
    MIDIInput: false,
    MIDIInputMap: false,
    MIDIMessageEvent: false,
    MIDIOutput: false,
    MIDIOutputMap: false,
    MIDIPort: false,
    MimeType: false,
    MimeTypeArray: false,
    MouseEvent: false,
    moveBy: false,
    moveTo: false,
    MutationEvent: false,
    MutationObserver: false,
    MutationRecord: false,
    name: false,
    NamedNodeMap: false,
    NavigationPreloadManager: false,
    navigator: false,
    Navigator: false,
    NetworkInformation: false,
    Node: false,
    NodeFilter: false,
    NodeIterator: false,
    NodeList: false,
    Notification: false,
    OfflineAudioCompletionEvent: false,
    OfflineAudioContext: false,
    offscreenBuffering: false,
    OffscreenCanvas: true,
    onabort: true,
    onafterprint: true,
    onanimationend: true,
    onanimationiteration: true,
    onanimationstart: true,
    onappinstalled: true,
    onauxclick: true,
    onbeforeinstallprompt: true,
    onbeforeprint: true,
    onbeforeunload: true,
    onblur: true,
    oncancel: true,
    oncanplay: true,
    oncanplaythrough: true,
    onchange: true,
    onclick: true,
    onclose: true,
    oncontextmenu: true,
    oncuechange: true,
    ondblclick: true,
    ondevicemotion: true,
    ondeviceorientation: true,
    ondeviceorientationabsolute: true,
    ondrag: true,
    ondragend: true,
    ondragenter: true,
    ondragleave: true,
    ondragover: true,
    ondragstart: true,
    ondrop: true,
    ondurationchange: true,
    onemptied: true,
    onended: true,
    onerror: true,
    onfocus: true,
    ongotpointercapture: true,
    onhashchange: true,
    oninput: true,
    oninvalid: true,
    onkeydown: true,
    onkeypress: true,
    onkeyup: true,
    onlanguagechange: true,
    onload: true,
    onloadeddata: true,
    onloadedmetadata: true,
    onloadstart: true,
    onlostpointercapture: true,
    onmessage: true,
    onmessageerror: true,
    onmousedown: true,
    onmouseenter: true,
    onmouseleave: true,
    onmousemove: true,
    onmouseout: true,
    onmouseover: true,
    onmouseup: true,
    onmousewheel: true,
    onoffline: true,
    ononline: true,
    onpagehide: true,
    onpageshow: true,
    onpause: true,
    onplay: true,
    onplaying: true,
    onpointercancel: true,
    onpointerdown: true,
    onpointerenter: true,
    onpointerleave: true,
    onpointermove: true,
    onpointerout: true,
    onpointerover: true,
    onpointerup: true,
    onpopstate: true,
    onprogress: true,
    onratechange: true,
    onrejectionhandled: true,
    onreset: true,
    onresize: true,
    onscroll: true,
    onsearch: true,
    onseeked: true,
    onseeking: true,
    onselect: true,
    onstalled: true,
    onstorage: true,
    onsubmit: true,
    onsuspend: true,
    ontimeupdate: true,
    ontoggle: true,
    ontransitionend: true,
    onunhandledrejection: true,
    onunload: true,
    onvolumechange: true,
    onwaiting: true,
    onwheel: true,
    open: false,
    openDatabase: false,
    opener: false,
    Option: false,
    origin: false,
    OscillatorNode: false,
    outerHeight: false,
    outerWidth: false,
    PageTransitionEvent: false,
    pageXOffset: false,
    pageYOffset: false,
    PannerNode: false,
    parent: false,
    Path2D: false,
    PaymentAddress: false,
    PaymentRequest: false,
    PaymentRequestUpdateEvent: false,
    PaymentResponse: false,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceLongTaskTiming: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceNavigationTiming: false,
    PerformanceObserver: false,
    PerformanceObserverEntryList: false,
    PerformancePaintTiming: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    PeriodicWave: false,
    Permissions: false,
    PermissionStatus: false,
    personalbar: false,
    PhotoCapabilities: false,
    Plugin: false,
    PluginArray: false,
    PointerEvent: false,
    PopStateEvent: false,
    postMessage: false,
    Presentation: false,
    PresentationAvailability: false,
    PresentationConnection: false,
    PresentationConnectionAvailableEvent: false,
    PresentationConnectionCloseEvent: false,
    PresentationConnectionList: false,
    PresentationReceiver: false,
    PresentationRequest: false,
    print: false,
    ProcessingInstruction: false,
    ProgressEvent: false,
    PromiseRejectionEvent: false,
    prompt: false,
    PushManager: false,
    PushSubscription: false,
    PushSubscriptionOptions: false,
    queueMicrotask: false,
    RadioNodeList: false,
    Range: false,
    ReadableStream: false,
    registerProcessor: false,
    RemotePlayback: false,
    removeEventListener: false,
    Request: false,
    requestAnimationFrame: false,
    requestIdleCallback: false,
    resizeBy: false,
    ResizeObserver: false,
    ResizeObserverEntry: false,
    resizeTo: false,
    Response: false,
    RTCCertificate: false,
    RTCDataChannel: false,
    RTCDataChannelEvent: false,
    RTCDtlsTransport: false,
    RTCIceCandidate: false,
    RTCIceGatherer: false,
    RTCIceTransport: false,
    RTCPeerConnection: false,
    RTCPeerConnectionIceEvent: false,
    RTCRtpContributingSource: false,
    RTCRtpReceiver: false,
    RTCRtpSender: false,
    RTCSctpTransport: false,
    RTCSessionDescription: false,
    RTCStatsReport: false,
    RTCTrackEvent: false,
    screen: false,
    Screen: false,
    screenLeft: false,
    ScreenOrientation: false,
    screenTop: false,
    screenX: false,
    screenY: false,
    ScriptProcessorNode: false,
    scroll: false,
    scrollbars: false,
    scrollBy: false,
    scrollTo: false,
    scrollX: false,
    scrollY: false,
    SecurityPolicyViolationEvent: false,
    Selection: false,
    self: false,
    ServiceWorker: false,
    ServiceWorkerContainer: false,
    ServiceWorkerRegistration: false,
    sessionStorage: false,
    setInterval: false,
    setTimeout: false,
    ShadowRoot: false,
    SharedWorker: false,
    SourceBuffer: false,
    SourceBufferList: false,
    speechSynthesis: false,
    SpeechSynthesisEvent: false,
    SpeechSynthesisUtterance: false,
    StaticRange: false,
    status: false,
    statusbar: false,
    StereoPannerNode: false,
    stop: false,
    Storage: false,
    StorageEvent: false,
    StorageManager: false,
    styleMedia: false,
    StyleSheet: false,
    StyleSheetList: false,
    SubtleCrypto: false,
    SVGAElement: false,
    SVGAngle: false,
    SVGAnimatedAngle: false,
    SVGAnimatedBoolean: false,
    SVGAnimatedEnumeration: false,
    SVGAnimatedInteger: false,
    SVGAnimatedLength: false,
    SVGAnimatedLengthList: false,
    SVGAnimatedNumber: false,
    SVGAnimatedNumberList: false,
    SVGAnimatedPreserveAspectRatio: false,
    SVGAnimatedRect: false,
    SVGAnimatedString: false,
    SVGAnimatedTransformList: false,
    SVGAnimateElement: false,
    SVGAnimateMotionElement: false,
    SVGAnimateTransformElement: false,
    SVGAnimationElement: false,
    SVGCircleElement: false,
    SVGClipPathElement: false,
    SVGComponentTransferFunctionElement: false,
    SVGDefsElement: false,
    SVGDescElement: false,
    SVGDiscardElement: false,
    SVGElement: false,
    SVGEllipseElement: false,
    SVGFEBlendElement: false,
    SVGFEColorMatrixElement: false,
    SVGFEComponentTransferElement: false,
    SVGFECompositeElement: false,
    SVGFEConvolveMatrixElement: false,
    SVGFEDiffuseLightingElement: false,
    SVGFEDisplacementMapElement: false,
    SVGFEDistantLightElement: false,
    SVGFEDropShadowElement: false,
    SVGFEFloodElement: false,
    SVGFEFuncAElement: false,
    SVGFEFuncBElement: false,
    SVGFEFuncGElement: false,
    SVGFEFuncRElement: false,
    SVGFEGaussianBlurElement: false,
    SVGFEImageElement: false,
    SVGFEMergeElement: false,
    SVGFEMergeNodeElement: false,
    SVGFEMorphologyElement: false,
    SVGFEOffsetElement: false,
    SVGFEPointLightElement: false,
    SVGFESpecularLightingElement: false,
    SVGFESpotLightElement: false,
    SVGFETileElement: false,
    SVGFETurbulenceElement: false,
    SVGFilterElement: false,
    SVGForeignObjectElement: false,
    SVGGElement: false,
    SVGGeometryElement: false,
    SVGGradientElement: false,
    SVGGraphicsElement: false,
    SVGImageElement: false,
    SVGLength: false,
    SVGLengthList: false,
    SVGLinearGradientElement: false,
    SVGLineElement: false,
    SVGMarkerElement: false,
    SVGMaskElement: false,
    SVGMatrix: false,
    SVGMetadataElement: false,
    SVGMPathElement: false,
    SVGNumber: false,
    SVGNumberList: false,
    SVGPathElement: false,
    SVGPatternElement: false,
    SVGPoint: false,
    SVGPointList: false,
    SVGPolygonElement: false,
    SVGPolylineElement: false,
    SVGPreserveAspectRatio: false,
    SVGRadialGradientElement: false,
    SVGRect: false,
    SVGRectElement: false,
    SVGScriptElement: false,
    SVGSetElement: false,
    SVGStopElement: false,
    SVGStringList: false,
    SVGStyleElement: false,
    SVGSVGElement: false,
    SVGSwitchElement: false,
    SVGSymbolElement: false,
    SVGTextContentElement: false,
    SVGTextElement: false,
    SVGTextPathElement: false,
    SVGTextPositioningElement: false,
    SVGTitleElement: false,
    SVGTransform: false,
    SVGTransformList: false,
    SVGTSpanElement: false,
    SVGUnitTypes: false,
    SVGUseElement: false,
    SVGViewElement: false,
    TaskAttributionTiming: false,
    Text: false,
    TextDecoder: false,
    TextEncoder: false,
    TextEvent: false,
    TextMetrics: false,
    TextTrack: false,
    TextTrackCue: false,
    TextTrackCueList: false,
    TextTrackList: false,
    TimeRanges: false,
    toolbar: false,
    top: false,
    Touch: false,
    TouchEvent: false,
    TouchList: false,
    TrackEvent: false,
    TransitionEvent: false,
    TreeWalker: false,
    UIEvent: false,
    URL: false,
    URLSearchParams: false,
    ValidityState: false,
    visualViewport: false,
    VisualViewport: false,
    VTTCue: false,
    WaveShaperNode: false,
    WebAssembly: false,
    WebGL2RenderingContext: false,
    WebGLActiveInfo: false,
    WebGLBuffer: false,
    WebGLContextEvent: false,
    WebGLFramebuffer: false,
    WebGLProgram: false,
    WebGLQuery: false,
    WebGLRenderbuffer: false,
    WebGLRenderingContext: false,
    WebGLSampler: false,
    WebGLShader: false,
    WebGLShaderPrecisionFormat: false,
    WebGLSync: false,
    WebGLTexture: false,
    WebGLTransformFeedback: false,
    WebGLUniformLocation: false,
    WebGLVertexArrayObject: false,
    WebSocket: false,
    WheelEvent: false,
    window: false,
    Window: false,
    Worker: false,
    WritableStream: false,
    XMLDocument: false,
    XMLHttpRequest: false,
    XMLHttpRequestEventTarget: false,
    XMLHttpRequestUpload: false,
    XMLSerializer: false,
    XPathEvaluator: false,
    XPathExpression: false,
    XPathResult: false,
    XSLTProcessor: false,
  };
  var worker = {
    addEventListener: false,
    applicationCache: false,
    atob: false,
    Blob: false,
    BroadcastChannel: false,
    btoa: false,
    Cache: false,
    caches: false,
    clearInterval: false,
    clearTimeout: false,
    close: true,
    console: false,
    fetch: false,
    FileReaderSync: false,
    FormData: false,
    Headers: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    ImageData: false,
    importScripts: true,
    indexedDB: false,
    location: false,
    MessageChannel: false,
    MessagePort: false,
    name: false,
    navigator: false,
    Notification: false,
    onclose: true,
    onconnect: true,
    onerror: true,
    onlanguagechange: true,
    onmessage: true,
    onoffline: true,
    ononline: true,
    onrejectionhandled: true,
    onunhandledrejection: true,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    postMessage: true,
    Promise: false,
    queueMicrotask: false,
    removeEventListener: false,
    Request: false,
    Response: false,
    self: true,
    ServiceWorkerRegistration: false,
    setInterval: false,
    setTimeout: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false,
    WebSocket: false,
    Worker: false,
    WorkerGlobalScope: false,
    XMLHttpRequest: false,
  };
  var node = {
    __dirname: false,
    __filename: false,
    Buffer: false,
    clearImmediate: false,
    clearInterval: false,
    clearTimeout: false,
    console: false,
    exports: true,
    global: false,
    Intl: false,
    module: false,
    process: false,
    queueMicrotask: false,
    require: false,
    setImmediate: false,
    setInterval: false,
    setTimeout: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false,
  };
  var commonjs = {
    exports: true,
    global: false,
    module: false,
    require: false,
  };
  var amd = {
    define: false,
    require: false,
  };
  var mocha = {
    after: false,
    afterEach: false,
    before: false,
    beforeEach: false,
    context: false,
    describe: false,
    it: false,
    mocha: false,
    run: false,
    setup: false,
    specify: false,
    suite: false,
    suiteSetup: false,
    suiteTeardown: false,
    teardown: false,
    test: false,
    xcontext: false,
    xdescribe: false,
    xit: false,
    xspecify: false,
  };
  var jasmine = {
    afterAll: false,
    afterEach: false,
    beforeAll: false,
    beforeEach: false,
    describe: false,
    expect: false,
    fail: false,
    fdescribe: false,
    fit: false,
    it: false,
    jasmine: false,
    pending: false,
    runs: false,
    spyOn: false,
    spyOnProperty: false,
    waits: false,
    waitsFor: false,
    xdescribe: false,
    xit: false,
  };
  var jest = {
    afterAll: false,
    afterEach: false,
    beforeAll: false,
    beforeEach: false,
    describe: false,
    expect: false,
    fdescribe: false,
    fit: false,
    it: false,
    jest: false,
    pit: false,
    require: false,
    test: false,
    xdescribe: false,
    xit: false,
    xtest: false,
  };
  var qunit = {
    asyncTest: false,
    deepEqual: false,
    equal: false,
    expect: false,
    module: false,
    notDeepEqual: false,
    notEqual: false,
    notOk: false,
    notPropEqual: false,
    notStrictEqual: false,
    ok: false,
    propEqual: false,
    QUnit: false,
    raises: false,
    start: false,
    stop: false,
    strictEqual: false,
    test: false,
    throws: false,
  };
  var phantomjs = {
    console: true,
    exports: true,
    phantom: true,
    require: true,
    WebPage: true,
  };
  var couch = {
    emit: false,
    exports: false,
    getRow: false,
    log: false,
    module: false,
    provides: false,
    require: false,
    respond: false,
    send: false,
    start: false,
    sum: false,
  };
  var rhino = {
    defineClass: false,
    deserialize: false,
    gc: false,
    help: false,
    importClass: false,
    importPackage: false,
    java: false,
    load: false,
    loadClass: false,
    Packages: false,
    print: false,
    quit: false,
    readFile: false,
    readUrl: false,
    runCommand: false,
    seal: false,
    serialize: false,
    spawn: false,
    sync: false,
    toint32: false,
    version: false,
  };
  var nashorn = {
    __DIR__: false,
    __FILE__: false,
    __LINE__: false,
    com: false,
    edu: false,
    exit: false,
    java: false,
    Java: false,
    javafx: false,
    JavaImporter: false,
    javax: false,
    JSAdapter: false,
    load: false,
    loadWithNewGlobal: false,
    org: false,
    Packages: false,
    print: false,
    quit: false,
  };
  var wsh = {
    ActiveXObject: true,
    Enumerator: true,
    GetObject: true,
    ScriptEngine: true,
    ScriptEngineBuildVersion: true,
    ScriptEngineMajorVersion: true,
    ScriptEngineMinorVersion: true,
    VBArray: true,
    WScript: true,
    WSH: true,
    XDomainRequest: true,
  };
  var jquery = {
    $: false,
    jQuery: false,
  };
  var yui = {
    YAHOO: false,
    YAHOO_config: false,
    YUI: false,
    YUI_config: false,
  };
  var shelljs = {
    cat: false,
    cd: false,
    chmod: false,
    config: false,
    cp: false,
    dirs: false,
    echo: false,
    env: false,
    error: false,
    exec: false,
    exit: false,
    find: false,
    grep: false,
    ln: false,
    ls: false,
    mkdir: false,
    mv: false,
    popd: false,
    pushd: false,
    pwd: false,
    rm: false,
    sed: false,
    set: false,
    target: false,
    tempdir: false,
    test: false,
    touch: false,
    which: false,
  };
  var prototypejs = {
    $: false,
    $$: false,
    $A: false,
    $break: false,
    $continue: false,
    $F: false,
    $H: false,
    $R: false,
    $w: false,
    Abstract: false,
    Ajax: false,
    Autocompleter: false,
    Builder: false,
    Class: false,
    Control: false,
    Draggable: false,
    Draggables: false,
    Droppables: false,
    Effect: false,
    Element: false,
    Enumerable: false,
    Event: false,
    Field: false,
    Form: false,
    Hash: false,
    Insertion: false,
    ObjectRange: false,
    PeriodicalExecuter: false,
    Position: false,
    Prototype: false,
    Scriptaculous: false,
    Selector: false,
    Sortable: false,
    SortableObserver: false,
    Sound: false,
    Template: false,
    Toggle: false,
    Try: false,
  };
  var meteor = {
    _: false,
    $: false,
    Accounts: false,
    AccountsClient: false,
    AccountsCommon: false,
    AccountsServer: false,
    App: false,
    Assets: false,
    Blaze: false,
    check: false,
    Cordova: false,
    DDP: false,
    DDPRateLimiter: false,
    DDPServer: false,
    Deps: false,
    EJSON: false,
    Email: false,
    HTTP: false,
    Log: false,
    Match: false,
    Meteor: false,
    Mongo: false,
    MongoInternals: false,
    Npm: false,
    Package: false,
    Plugin: false,
    process: false,
    Random: false,
    ReactiveDict: false,
    ReactiveVar: false,
    Router: false,
    ServiceConfiguration: false,
    Session: false,
    share: false,
    Spacebars: false,
    Template: false,
    Tinytest: false,
    Tracker: false,
    UI: false,
    Utils: false,
    WebApp: false,
    WebAppInternals: false,
  };
  var mongo = {
    _isWindows: false,
    _rand: false,
    BulkWriteResult: false,
    cat: false,
    cd: false,
    connect: false,
    db: false,
    getHostName: false,
    getMemInfo: false,
    hostname: false,
    ISODate: false,
    listFiles: false,
    load: false,
    ls: false,
    md5sumFile: false,
    mkdir: false,
    Mongo: false,
    NumberInt: false,
    NumberLong: false,
    ObjectId: false,
    PlanCache: false,
    print: false,
    printjson: false,
    pwd: false,
    quit: false,
    removeFile: false,
    rs: false,
    sh: false,
    UUID: false,
    version: false,
    WriteResult: false,
  };
  var applescript = {
    $: false,
    Application: false,
    Automation: false,
    console: false,
    delay: false,
    Library: false,
    ObjC: false,
    ObjectSpecifier: false,
    Path: false,
    Progress: false,
    Ref: false,
  };
  var serviceworker = {
    addEventListener: false,
    applicationCache: false,
    atob: false,
    Blob: false,
    BroadcastChannel: false,
    btoa: false,
    Cache: false,
    caches: false,
    CacheStorage: false,
    clearInterval: false,
    clearTimeout: false,
    Client: false,
    clients: false,
    Clients: false,
    close: true,
    console: false,
    ExtendableEvent: false,
    ExtendableMessageEvent: false,
    fetch: false,
    FetchEvent: false,
    FileReaderSync: false,
    FormData: false,
    Headers: false,
    IDBCursor: false,
    IDBCursorWithValue: false,
    IDBDatabase: false,
    IDBFactory: false,
    IDBIndex: false,
    IDBKeyRange: false,
    IDBObjectStore: false,
    IDBOpenDBRequest: false,
    IDBRequest: false,
    IDBTransaction: false,
    IDBVersionChangeEvent: false,
    ImageData: false,
    importScripts: false,
    indexedDB: false,
    location: false,
    MessageChannel: false,
    MessagePort: false,
    name: false,
    navigator: false,
    Notification: false,
    onclose: true,
    onconnect: true,
    onerror: true,
    onfetch: true,
    oninstall: true,
    onlanguagechange: true,
    onmessage: true,
    onmessageerror: true,
    onnotificationclick: true,
    onnotificationclose: true,
    onoffline: true,
    ononline: true,
    onpush: true,
    onpushsubscriptionchange: true,
    onrejectionhandled: true,
    onsync: true,
    onunhandledrejection: true,
    performance: false,
    Performance: false,
    PerformanceEntry: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceNavigation: false,
    PerformanceResourceTiming: false,
    PerformanceTiming: false,
    postMessage: true,
    Promise: false,
    queueMicrotask: false,
    registration: false,
    removeEventListener: false,
    Request: false,
    Response: false,
    self: false,
    ServiceWorker: false,
    ServiceWorkerContainer: false,
    ServiceWorkerGlobalScope: false,
    ServiceWorkerMessageEvent: false,
    ServiceWorkerRegistration: false,
    setInterval: false,
    setTimeout: false,
    skipWaiting: false,
    TextDecoder: false,
    TextEncoder: false,
    URL: false,
    URLSearchParams: false,
    WebSocket: false,
    WindowClient: false,
    Worker: false,
    WorkerGlobalScope: false,
    XMLHttpRequest: false,
  };
  var atomtest = {
    advanceClock: false,
    fakeClearInterval: false,
    fakeClearTimeout: false,
    fakeSetInterval: false,
    fakeSetTimeout: false,
    resetTimeouts: false,
    waitsForPromise: false,
  };
  var embertest = {
    andThen: false,
    click: false,
    currentPath: false,
    currentRouteName: false,
    currentURL: false,
    fillIn: false,
    find: false,
    findAll: false,
    findWithAssert: false,
    keyEvent: false,
    pauseTest: false,
    resumeTest: false,
    triggerEvent: false,
    visit: false,
    wait: false,
  };
  var protractor = {
    $: false,
    $$: false,
    browser: false,
    by: false,
    By: false,
    DartObject: false,
    element: false,
    protractor: false,
  };
  var webextensions = {
    browser: false,
    chrome: false,
    opr: false,
  };
  var greasemonkey = {
    cloneInto: false,
    createObjectIn: false,
    exportFunction: false,
    GM: false,
    GM_addStyle: false,
    GM_deleteValue: false,
    GM_getResourceText: false,
    GM_getResourceURL: false,
    GM_getValue: false,
    GM_info: false,
    GM_listValues: false,
    GM_log: false,
    GM_openInTab: false,
    GM_registerMenuCommand: false,
    GM_setClipboard: false,
    GM_setValue: false,
    GM_xmlhttpRequest: false,
    unsafeWindow: false,
  };
  var devtools = {
    $: false,
    $_: false,
    $$: false,
    $0: false,
    $1: false,
    $2: false,
    $3: false,
    $4: false,
    $x: false,
    chrome: false,
    clear: false,
    copy: false,
    debug: false,
    dir: false,
    dirxml: false,
    getEventListeners: false,
    inspect: false,
    keys: false,
    monitor: false,
    monitorEvents: false,
    profile: false,
    profileEnd: false,
    queryObjects: false,
    table: false,
    undebug: false,
    unmonitor: false,
    unmonitorEvents: false,
    values: false,
  };
  var require$$0 = {
    builtin: builtin,
    es5: es5,
    es2015: es2015,
    es2017: es2017,
    browser: browser$2,
    worker: worker,
    node: node,
    commonjs: commonjs,
    amd: amd,
    mocha: mocha,
    jasmine: jasmine,
    jest: jest,
    qunit: qunit,
    phantomjs: phantomjs,
    couch: couch,
    rhino: rhino,
    nashorn: nashorn,
    wsh: wsh,
    jquery: jquery,
    yui: yui,
    shelljs: shelljs,
    prototypejs: prototypejs,
    meteor: meteor,
    mongo: mongo,
    applescript: applescript,
    serviceworker: serviceworker,
    atomtest: atomtest,
    embertest: embertest,
    protractor: protractor,
    'shared-node-browser': {
      clearInterval: false,
      clearTimeout: false,
      console: false,
      setInterval: false,
      setTimeout: false,
      URL: false,
      URLSearchParams: false,
    },
    webextensions: webextensions,
    greasemonkey: greasemonkey,
    devtools: devtools,
  };

  var globals = require$$0;

  var scope = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    var _renamer = _interopRequireDefault(renamer);

    var _index = _interopRequireDefault(lib$a);

    var _binding = _interopRequireDefault(binding$1);

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    function gatherNodeParts(node, parts) {
      switch (node == null ? void 0 : node.type) {
        default:
          if (t.isModuleDeclaration(node)) {
            if (
              (t.isExportAllDeclaration(node) ||
                t.isExportNamedDeclaration(node) ||
                t.isImportDeclaration(node)) &&
              node.source
            ) {
              gatherNodeParts(node.source, parts);
            } else if (
              (t.isExportNamedDeclaration(node) ||
                t.isImportDeclaration(node)) &&
              node.specifiers &&
              node.specifiers.length
            ) {
              for (const e of node.specifiers) gatherNodeParts(e, parts);
            } else if (
              (t.isExportDefaultDeclaration(node) ||
                t.isExportNamedDeclaration(node)) &&
              node.declaration
            ) {
              gatherNodeParts(node.declaration, parts);
            }
          } else if (t.isModuleSpecifier(node)) {
            gatherNodeParts(node.local, parts);
          } else if (t.isLiteral(node)) {
            parts.push(node.value);
          }

          break;

        case 'MemberExpression':
        case 'OptionalMemberExpression':
        case 'JSXMemberExpression':
          gatherNodeParts(node.object, parts);
          gatherNodeParts(node.property, parts);
          break;

        case 'Identifier':
        case 'JSXIdentifier':
          parts.push(node.name);
          break;

        case 'CallExpression':
        case 'OptionalCallExpression':
        case 'NewExpression':
          gatherNodeParts(node.callee, parts);
          break;

        case 'ObjectExpression':
        case 'ObjectPattern':
          for (const e of node.properties) {
            gatherNodeParts(e, parts);
          }

          break;

        case 'SpreadElement':
        case 'RestElement':
          gatherNodeParts(node.argument, parts);
          break;

        case 'ObjectProperty':
        case 'ObjectMethod':
        case 'ClassProperty':
        case 'ClassMethod':
        case 'ClassPrivateProperty':
        case 'ClassPrivateMethod':
          gatherNodeParts(node.key, parts);
          break;

        case 'ThisExpression':
          parts.push('this');
          break;

        case 'Super':
          parts.push('super');
          break;

        case 'Import':
          parts.push('import');
          break;

        case 'DoExpression':
          parts.push('do');
          break;

        case 'YieldExpression':
          parts.push('yield');
          gatherNodeParts(node.argument, parts);
          break;

        case 'AwaitExpression':
          parts.push('await');
          gatherNodeParts(node.argument, parts);
          break;

        case 'AssignmentExpression':
          gatherNodeParts(node.left, parts);
          break;

        case 'VariableDeclarator':
          gatherNodeParts(node.id, parts);
          break;

        case 'FunctionExpression':
        case 'FunctionDeclaration':
        case 'ClassExpression':
        case 'ClassDeclaration':
          gatherNodeParts(node.id, parts);
          break;

        case 'PrivateName':
          gatherNodeParts(node.id, parts);
          break;

        case 'ParenthesizedExpression':
          gatherNodeParts(node.expression, parts);
          break;

        case 'UnaryExpression':
        case 'UpdateExpression':
          gatherNodeParts(node.argument, parts);
          break;

        case 'MetaProperty':
          gatherNodeParts(node.meta, parts);
          gatherNodeParts(node.property, parts);
          break;

        case 'JSXElement':
          gatherNodeParts(node.openingElement, parts);
          break;

        case 'JSXOpeningElement':
          parts.push(node.name);
          break;

        case 'JSXFragment':
          gatherNodeParts(node.openingFragment, parts);
          break;

        case 'JSXOpeningFragment':
          parts.push('Fragment');
          break;

        case 'JSXNamespacedName':
          gatherNodeParts(node.namespace, parts);
          gatherNodeParts(node.name, parts);
          break;
      }
    }

    const collectorVisitor = {
      For(path) {
        for (const key of t.FOR_INIT_KEYS) {
          const declar = path.get(key);

          if (declar.isVar()) {
            const parentScope =
              path.scope.getFunctionParent() || path.scope.getProgramParent();
            parentScope.registerBinding('var', declar);
          }
        }
      },

      Declaration(path) {
        if (path.isBlockScoped()) return;
        if (path.isExportDeclaration()) return;
        const parent =
          path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
      },

      ReferencedIdentifier(path, state) {
        state.references.push(path);
      },

      ForXStatement(path, state) {
        const left = path.get('left');

        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path);
        }
      },

      ExportDeclaration: {
        exit(path) {
          const {node, scope} = path;
          if (t.isExportAllDeclaration(node)) return;
          const declar = node.declaration;

          if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id) return;
            const binding = scope.getBinding(id.name);
            if (binding) binding.reference(path);
          } else if (t.isVariableDeclaration(declar)) {
            for (const decl of declar.declarations) {
              for (const name of Object.keys(t.getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name);
                if (binding) binding.reference(path);
              }
            }
          }
        },
      },

      LabeledStatement(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },

      AssignmentExpression(path, state) {
        state.assignments.push(path);
      },

      UpdateExpression(path, state) {
        state.constantViolations.push(path);
      },

      UnaryExpression(path, state) {
        if (path.node.operator === 'delete') {
          state.constantViolations.push(path);
        }
      },

      BlockScoped(path) {
        let scope = path.scope;
        if (scope.path === path) scope = scope.parent;
        const parent = scope.getBlockParent();
        parent.registerDeclaration(path);

        if (path.isClassDeclaration() && path.node.id) {
          const id = path.node.id;
          const name = id.name;
          path.scope.bindings[name] = path.scope.parent.getBinding(name);
        }
      },

      CatchClause(path) {
        path.scope.registerBinding('let', path);
      },

      Function(path) {
        if (
          path.isFunctionExpression() &&
          path.has('id') &&
          !path.get('id').node[t.NOT_LOCAL_BINDING]
        ) {
          path.scope.registerBinding('local', path.get('id'), path);
        }

        const params = path.get('params');

        for (const param of params) {
          path.scope.registerBinding('param', param);
        }
      },

      ClassExpression(path) {
        if (path.has('id') && !path.get('id').node[t.NOT_LOCAL_BINDING]) {
          path.scope.registerBinding('local', path);
        }
      },
    };
    let uid = 0;

    class Scope {
      constructor(path) {
        this.uid = void 0;
        this.path = void 0;
        this.block = void 0;
        this.labels = void 0;
        this.inited = void 0;
        this.bindings = void 0;
        this.references = void 0;
        this.globals = void 0;
        this.uids = void 0;
        this.data = void 0;
        this.crawling = void 0;
        const {node} = path;

        const cached = cache.scope.get(node);

        if ((cached == null ? void 0 : cached.path) === path) {
          return cached;
        }

        cache.scope.set(node, this);

        this.uid = uid++;
        this.block = node;
        this.path = path;
        this.labels = new Map();
        this.inited = false;
      }

      get parent() {
        var _parent;

        let parent,
          path = this.path;

        do {
          const isKey = path.key === 'key';
          path = path.parentPath;
          if (isKey && path.isMethod()) path = path.parentPath;
          if (path && path.isScope()) parent = path;
        } while (path && !parent);

        return (_parent = parent) == null ? void 0 : _parent.scope;
      }

      get parentBlock() {
        return this.path.parent;
      }

      get hub() {
        return this.path.hub;
      }

      traverse(node, opts, state) {
        (0, _index.default)(node, opts, this, state, this.path);
      }

      generateDeclaredUidIdentifier(name) {
        const id = this.generateUidIdentifier(name);
        this.push({
          id,
        });
        return t.cloneNode(id);
      }

      generateUidIdentifier(name) {
        return t.identifier(this.generateUid(name));
      }

      generateUid(name = 'temp') {
        name = t
          .toIdentifier(name)
          .replace(/^_+/, '')
          .replace(/[0-9]+$/g, '');
        let uid;
        let i = 1;

        do {
          uid = this._generateUid(name, i);
          i++;
        } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

        const program = this.getProgramParent();
        program.references[uid] = true;
        program.uids[uid] = true;
        return uid;
      }

      _generateUid(name, i) {
        let id = name;
        if (i > 1) id += i;
        return `_${id}`;
      }

      generateUidBasedOnNode(node, defaultName) {
        const parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join('$');
        id = id.replace(/^_/, '') || defaultName || 'ref';
        return this.generateUid(id.slice(0, 20));
      }

      generateUidIdentifierBasedOnNode(node, defaultName) {
        return t.identifier(this.generateUidBasedOnNode(node, defaultName));
      }

      isStatic(node) {
        if (t.isThisExpression(node) || t.isSuper(node)) {
          return true;
        }

        if (t.isIdentifier(node)) {
          const binding = this.getBinding(node.name);

          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }

        return false;
      }

      maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          const id = this.generateUidIdentifierBasedOnNode(node);

          if (!dontPush) {
            this.push({
              id,
            });
            return t.cloneNode(id);
          }

          return id;
        }
      }

      checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === 'param') return;
        if (local.kind === 'local') return;
        const duplicate =
          kind === 'let' ||
          local.kind === 'let' ||
          local.kind === 'const' ||
          local.kind === 'module' ||
          (local.kind === 'param' && (kind === 'let' || kind === 'const'));

        if (duplicate) {
          throw this.hub.buildError(
            id,
            `Duplicate declaration "${name}"`,
            TypeError,
          );
        }
      }

      rename(oldName, newName, block) {
        const binding = this.getBinding(oldName);

        if (binding) {
          newName = newName || this.generateUidIdentifier(oldName).name;
          return new _renamer.default(binding, oldName, newName).rename(block);
        }
      }

      _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      }

      dump() {
        const sep = '-'.repeat(60);
        console.log(sep);
        let scope = this;

        do {
          console.log('#', scope.block.type);

          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            console.log(' -', name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind,
            });
          }
        } while ((scope = scope.parent));

        console.log(sep);
      }

      toArray(node, i, arrayLikeIsIterable) {
        if (t.isIdentifier(node)) {
          const binding = this.getBinding(node.name);

          if (
            binding != null &&
            binding.constant &&
            binding.path.isGenericType('Array')
          ) {
            return node;
          }
        }

        if (t.isArrayExpression(node)) {
          return node;
        }

        if (
          t.isIdentifier(node, {
            name: 'arguments',
          })
        ) {
          return t.callExpression(
            t.memberExpression(
              t.memberExpression(
                t.memberExpression(
                  t.identifier('Array'),
                  t.identifier('prototype'),
                ),
                t.identifier('slice'),
              ),
              t.identifier('call'),
            ),
            [node],
          );
        }

        let helperName;
        const args = [node];

        if (i === true) {
          helperName = 'toConsumableArray';
        } else if (i) {
          args.push(t.numericLiteral(i));
          helperName = 'slicedToArray';
        } else {
          helperName = 'toArray';
        }

        if (arrayLikeIsIterable) {
          args.unshift(this.hub.addHelper(helperName));
          helperName = 'maybeArrayLike';
        }

        return t.callExpression(this.hub.addHelper(helperName), args);
      }

      hasLabel(name) {
        return !!this.getLabel(name);
      }

      getLabel(name) {
        return this.labels.get(name);
      }

      registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      }

      registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding('hoisted', path.get('id'), path);
        } else if (path.isVariableDeclaration()) {
          const declarations = path.get('declarations');

          for (const declar of declarations) {
            this.registerBinding(path.node.kind, declar);
          }
        } else if (path.isClassDeclaration()) {
          this.registerBinding('let', path);
        } else if (path.isImportDeclaration()) {
          const specifiers = path.get('specifiers');

          for (const specifier of specifiers) {
            this.registerBinding('module', specifier);
          }
        } else if (path.isExportDeclaration()) {
          const declar = path.get('declaration');

          if (
            declar.isClassDeclaration() ||
            declar.isFunctionDeclaration() ||
            declar.isVariableDeclaration()
          ) {
            this.registerDeclaration(declar);
          }
        } else {
          this.registerBinding('unknown', path);
        }
      }

      buildUndefinedNode() {
        return t.unaryExpression('void', t.numericLiteral(0), true);
      }

      registerConstantViolation(path) {
        const ids = path.getBindingIdentifiers();

        for (const name of Object.keys(ids)) {
          const binding = this.getBinding(name);
          if (binding) binding.reassign(path);
        }
      }

      registerBinding(kind, path, bindingPath = path) {
        if (!kind) throw new ReferenceError('no `kind`');

        if (path.isVariableDeclaration()) {
          const declarators = path.get('declarations');

          for (const declar of declarators) {
            this.registerBinding(kind, declar);
          }

          return;
        }

        const parent = this.getProgramParent();
        const ids = path.getOuterBindingIdentifiers(true);

        for (const name of Object.keys(ids)) {
          parent.references[name] = true;

          for (const id of ids[name]) {
            const local = this.getOwnBinding(name);

            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }

            if (local) {
              this.registerConstantViolation(bindingPath);
            } else {
              this.bindings[name] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind: kind,
              });
            }
          }
        }
      }

      addGlobal(node) {
        this.globals[node.name] = node;
      }

      hasUid(name) {
        let scope = this;

        do {
          if (scope.uids[name]) return true;
        } while ((scope = scope.parent));

        return false;
      }

      hasGlobal(name) {
        let scope = this;

        do {
          if (scope.globals[name]) return true;
        } while ((scope = scope.parent));

        return false;
      }

      hasReference(name) {
        return !!this.getProgramParent().references[name];
      }

      isPure(node, constantsOnly) {
        if (t.isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (!binding) return false;
          if (constantsOnly) return binding.constant;
          return true;
        } else if (t.isClass(node)) {
          if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
            return false;
          }

          return this.isPure(node.body, constantsOnly);
        } else if (t.isClassBody(node)) {
          for (const method of node.body) {
            if (!this.isPure(method, constantsOnly)) return false;
          }

          return true;
        } else if (t.isBinary(node)) {
          return (
            this.isPure(node.left, constantsOnly) &&
            this.isPure(node.right, constantsOnly)
          );
        } else if (t.isArrayExpression(node)) {
          for (const elem of node.elements) {
            if (!this.isPure(elem, constantsOnly)) return false;
          }

          return true;
        } else if (t.isObjectExpression(node)) {
          for (const prop of node.properties) {
            if (!this.isPure(prop, constantsOnly)) return false;
          }

          return true;
        } else if (t.isMethod(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly))
            return false;
          if (node.kind === 'get' || node.kind === 'set') return false;
          return true;
        } else if (t.isProperty(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly))
            return false;
          return this.isPure(node.value, constantsOnly);
        } else if (t.isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else if (t.isTaggedTemplateExpression(node)) {
          return (
            t.matchesPattern(node.tag, 'String.raw') &&
            !this.hasBinding('String', true) &&
            this.isPure(node.quasi, constantsOnly)
          );
        } else if (t.isTemplateLiteral(node)) {
          for (const expression of node.expressions) {
            if (!this.isPure(expression, constantsOnly)) return false;
          }

          return true;
        } else {
          return t.isPureish(node);
        }
      }

      setData(key, val) {
        return (this.data[key] = val);
      }

      getData(key) {
        let scope = this;

        do {
          const data = scope.data[key];
          if (data != null) return data;
        } while ((scope = scope.parent));
      }

      removeData(key) {
        let scope = this;

        do {
          const data = scope.data[key];
          if (data != null) scope.data[key] = null;
        } while ((scope = scope.parent));
      }

      init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }

      crawl() {
        const path = this.path;
        this.references = Object.create(null);
        this.bindings = Object.create(null);
        this.globals = Object.create(null);
        this.uids = Object.create(null);
        this.data = Object.create(null);
        const programParent = this.getProgramParent();
        if (programParent.crawling) return;
        const state = {
          references: [],
          constantViolations: [],
          assignments: [],
        };
        this.crawling = true;

        if (path.type !== 'Program' && collectorVisitor._exploded) {
          for (const visit of collectorVisitor.enter) {
            visit(path, state);
          }

          const typeVisitors = collectorVisitor[path.type];

          if (typeVisitors) {
            for (const visit of typeVisitors.enter) {
              visit(path, state);
            }
          }
        }

        path.traverse(collectorVisitor, state);
        this.crawling = false;

        for (const path of state.assignments) {
          const ids = path.getBindingIdentifiers();

          for (const name of Object.keys(ids)) {
            if (path.scope.getBinding(name)) continue;
            programParent.addGlobal(ids[name]);
          }

          path.scope.registerConstantViolation(path);
        }

        for (const ref of state.references) {
          const binding = ref.scope.getBinding(ref.node.name);

          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }

        for (const path of state.constantViolations) {
          path.scope.registerConstantViolation(path);
        }
      }

      push(opts) {
        let path = this.path;

        if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }

        if (path.isSwitchStatement()) {
          path = (this.getFunctionParent() || this.getProgramParent()).path;
        }

        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          path.ensureBlock();
          path = path.get('body');
        }

        const unique = opts.unique;
        const kind = opts.kind || 'var';
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path.getData(dataKey);

        if (!declarPath) {
          const declar = t.variableDeclaration(kind, []);
          declar._blockHoist = blockHoist;
          [declarPath] = path.unshiftContainer('body', [declar]);
          if (!unique) path.setData(dataKey, declarPath);
        }

        const declarator = t.variableDeclarator(opts.id, opts.init);
        declarPath.node.declarations.push(declarator);
        this.registerBinding(kind, declarPath.get('declarations').pop());
      }

      getProgramParent() {
        let scope = this;

        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while ((scope = scope.parent));

        throw new Error("Couldn't find a Program");
      }

      getFunctionParent() {
        let scope = this;

        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while ((scope = scope.parent));

        return null;
      }

      getBlockParent() {
        let scope = this;

        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while ((scope = scope.parent));

        throw new Error(
          "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...",
        );
      }

      getAllBindings() {
        const ids = Object.create(null);
        let scope = this;

        do {
          for (const key of Object.keys(scope.bindings)) {
            if (key in ids === false) {
              ids[key] = scope.bindings[key];
            }
          }

          scope = scope.parent;
        } while (scope);

        return ids;
      }

      getAllBindingsOfKind(...kinds) {
        const ids = Object.create(null);

        for (const kind of kinds) {
          let scope = this;

          do {
            for (const name of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name];
              if (binding.kind === kind) ids[name] = binding;
            }

            scope = scope.parent;
          } while (scope);
        }

        return ids;
      }

      bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      }

      getBinding(name) {
        let scope = this;
        let previousPath;

        do {
          const binding = scope.getOwnBinding(name);

          if (binding) {
            var _previousPath;

            if (
              (_previousPath = previousPath) != null &&
              _previousPath.isPattern() &&
              binding.kind !== 'param'
            );
            else {
              return binding;
            }
          }

          previousPath = scope.path;
        } while ((scope = scope.parent));
      }

      getOwnBinding(name) {
        return this.bindings[name];
      }

      getBindingIdentifier(name) {
        var _this$getBinding;

        return (_this$getBinding = this.getBinding(name)) == null
          ? void 0
          : _this$getBinding.identifier;
      }

      getOwnBindingIdentifier(name) {
        const binding = this.bindings[name];
        return binding == null ? void 0 : binding.identifier;
      }

      hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }

      hasBinding(name, noGlobals) {
        if (!name) return false;
        if (this.hasOwnBinding(name)) return true;
        if (this.parentHasBinding(name, noGlobals)) return true;
        if (this.hasUid(name)) return true;
        if (!noGlobals && Scope.globals.includes(name)) return true;
        if (!noGlobals && Scope.contextVariables.includes(name)) return true;
        return false;
      }

      parentHasBinding(name, noGlobals) {
        var _this$parent;

        return (_this$parent = this.parent) == null
          ? void 0
          : _this$parent.hasBinding(name, noGlobals);
      }

      moveBindingTo(name, scope) {
        const info = this.getBinding(name);

        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      }

      removeOwnBinding(name) {
        delete this.bindings[name];
      }

      removeBinding(name) {
        var _this$getBinding2;

        (_this$getBinding2 = this.getBinding(name)) == null
          ? void 0
          : _this$getBinding2.scope.removeOwnBinding(name);
        let scope = this;

        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while ((scope = scope.parent));
      }
    }

    exports.default = Scope;
    Scope.globals = Object.keys(globals.builtin);
    Scope.contextVariables = ['arguments', 'undefined', 'Infinity', 'NaN'];
  });
  /*@__PURE__*/ getDefaultExportFromCjs(scope);

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(
    '',
  );
  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */

  var encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }

    throw new TypeError('Must be between 0 and 63: ' + number);
  };
  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */

  var decode = function (charCode) {
    var bigA = 65; // 'A'

    var bigZ = 90; // 'Z'

    var littleA = 97; // 'a'

    var littleZ = 122; // 'z'

    var zero = 48; // '0'

    var nine = 57; // '9'

    var plus = 43; // '+'

    var slash = 47; // '/'

    var littleOffset = 26;
    var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    } // 26 - 51: abcdefghijklmnopqrstuvwxyz

    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    } // 52 - 61: 0123456789

    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    } // 62: +

    if (charCode == plus) {
      return 62;
    } // 63: /

    if (charCode == slash) {
      return 63;
    } // Invalid base64 digit.

    return -1;
  };

  var base64 = {
    encode: encode,
    decode: decode,
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5; // binary: 100000

  var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

  var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */

  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */

  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  /**
   * Returns the base 64 VLQ encoded value.
   */

  var encode$1 = function base64VLQ_encode(aValue) {
    var encoded = '';
    var digit;
    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;

      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }

      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };
  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */

  var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error('Expected more digits in base 64 VLQ value.');
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));

      if (digit === -1) {
        throw new Error('Invalid base64 digit: ' + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq = {
    encode: encode$1,
    decode: decode$1,
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  var util = createCommonjsModule(function (module, exports) {
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */

    /**
     * This is a helper function for getting values from parameter/options
     * objects.
     *
     * @param args The object we are extracting values from
     * @param name The name of the property we are getting.
     * @param defaultValue An optional value to return if the property is missing
     * from the object. If this is not specified and the property is missing, an
     * error will be thrown.
     */
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }

    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;

    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);

      if (!match) {
        return null;
      }

      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5],
      };
    }

    exports.urlParse = urlParse;

    function urlGenerate(aParsedUrl) {
      var url = '';

      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
      }

      url += '//';

      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
      }

      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }

      if (aParsedUrl.port) {
        url += ':' + aParsedUrl.port;
      }

      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }

      return url;
    }

    exports.urlGenerate = urlGenerate;
    /**
     * Normalizes a path, or the path portion of a URL:
     *
     * - Replaces consecutive slashes with one slash.
     * - Removes unnecessary '.' parts.
     * - Removes unnecessary '<dir>/..' parts.
     *
     * Based on code in the Node.js 'path' core module.
     *
     * @param aPath The path or url to normalize.
     */

    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);

      if (url) {
        if (!url.path) {
          return aPath;
        }

        path = url.path;
      }

      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);

      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];

        if (part === '.') {
          parts.splice(i, 1);
        } else if (part === '..') {
          up++;
        } else if (up > 0) {
          if (part === '') {
            // The first part is blank if the path is absolute. Trying to go
            // above the root is a no-op. Therefore we can remove all '..' parts
            // directly after the root.
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }

      path = parts.join('/');

      if (path === '') {
        path = isAbsolute ? '/' : '.';
      }

      if (url) {
        url.path = path;
        return urlGenerate(url);
      }

      return path;
    }

    exports.normalize = normalize;
    /**
     * Joins two paths/URLs.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be joined with the root.
     *
     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
     *   first.
     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
     *   is updated with the result and aRoot is returned. Otherwise the result
     *   is returned.
     *   - If aPath is absolute, the result is aPath.
     *   - Otherwise the two paths are joined with a slash.
     * - Joining for example 'http://' and 'www.example.com' is also supported.
     */

    function join(aRoot, aPath) {
      if (aRoot === '') {
        aRoot = '.';
      }

      if (aPath === '') {
        aPath = '.';
      }

      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);

      if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
      } // `join(foo, '//www.example.org')`

      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }

        return urlGenerate(aPathUrl);
      }

      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      } // `join('http://', 'www.example.com')`

      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }

      var joined =
        aPath.charAt(0) === '/'
          ? aPath
          : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }

      return joined;
    }

    exports.join = join;

    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
    };
    /**
     * Make a path relative to a URL or another path.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be made relative to aRoot.
     */

    function relative(aRoot, aPath) {
      if (aRoot === '') {
        aRoot = '.';
      }

      aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
      // checking whether the root is a prefix of the path won't work. Instead, we
      // need to remove components from the root one by one, until either we find
      // a prefix that fits, or we run out of components to remove.

      var level = 0;

      while (aPath.indexOf(aRoot + '/') !== 0) {
        var index = aRoot.lastIndexOf('/');

        if (index < 0) {
          return aPath;
        } // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.

        aRoot = aRoot.slice(0, index);

        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }

        ++level;
      } // Make sure we add a "../" for each component we removed from the root.

      return Array(level + 1).join('../') + aPath.substr(aRoot.length + 1);
    }

    exports.relative = relative;

    var supportsNullProto = (function () {
      var obj = Object.create(null);
      return !('__proto__' in obj);
    })();

    function identity(s) {
      return s;
    }
    /**
     * Because behavior goes wacky when you set `__proto__` on objects, we
     * have to prefix all the strings in our set with an arbitrary character.
     *
     * See https://github.com/mozilla/source-map/pull/31 and
     * https://github.com/mozilla/source-map/issues/30
     *
     * @param String aStr
     */

    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return '$' + aStr;
      }

      return aStr;
    }

    exports.toSetString = supportsNullProto ? identity : toSetString;

    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }

      return aStr;
    }

    exports.fromSetString = supportsNullProto ? identity : fromSetString;

    function isProtoString(s) {
      if (!s) {
        return false;
      }

      var length = s.length;

      if (
        length < 9
        /* "__proto__".length */
      ) {
        return false;
      }

      if (
        s.charCodeAt(length - 1) !== 95 ||
        /* '_' */
        s.charCodeAt(length - 2) !== 95 ||
        /* '_' */
        s.charCodeAt(length - 3) !== 111 ||
        /* 'o' */
        s.charCodeAt(length - 4) !== 116 ||
        /* 't' */
        s.charCodeAt(length - 5) !== 111 ||
        /* 'o' */
        s.charCodeAt(length - 6) !== 114 ||
        /* 'r' */
        s.charCodeAt(length - 7) !== 112 ||
        /* 'p' */
        s.charCodeAt(length - 8) !== 95 ||
        /* '_' */
        s.charCodeAt(length - 9) !== 95
        /* '_' */
      ) {
        return false;
      }

      for (var i = length - 10; i >= 0; i--) {
        if (
          s.charCodeAt(i) !== 36
          /* '$' */
        ) {
          return false;
        }
      }

      return true;
    }
    /**
     * Comparator between two mappings where the original positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same original source/line/column, but different generated
     * line and column the same. Useful when searching for a mapping with a
     * stubbed out mapping.
     */

    function compareByOriginalPositions(
      mappingA,
      mappingB,
      onlyCompareOriginal,
    ) {
      var cmp = mappingA.source - mappingB.source;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      return mappingA.name - mappingB.name;
    }

    exports.compareByOriginalPositions = compareByOriginalPositions;
    /**
     * Comparator between two mappings with deflated source and name indices where
     * the generated positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same generated line and column, but different
     * source/name/original line and column the same. Useful when searching for a
     * mapping with a stubbed out mapping.
     */

    function compareByGeneratedPositionsDeflated(
      mappingA,
      mappingB,
      onlyCompareGenerated,
    ) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }

      cmp = mappingA.source - mappingB.source;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0) {
        return cmp;
      }

      return mappingA.name - mappingB.name;
    }

    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }

      if (aStr1 > aStr2) {
        return 1;
      }

      return -1;
    }
    /**
     * Comparator between two mappings with inflated source and name strings where
     * the generated positions are compared.
     */

    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = strcmp(mappingA.source, mappingB.source);

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0) {
        return cmp;
      }

      return strcmp(mappingA.name, mappingB.name);
    }

    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var has$1 = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== 'undefined';
  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */

  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  /**
   * Static method for creating ArraySet instances from an existing array.
   */

  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();

    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }

    return set;
  };
  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */

  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap
      ? this._set.size
      : Object.getOwnPropertyNames(this._set).length;
  };
  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */

  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap
      ? this.has(aStr)
      : has$1.call(this._set, sStr);
    var idx = this._array.length;

    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }

    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */

  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has$1.call(this._set, sStr);
    }
  };
  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */

  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);

      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);

      if (has$1.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };
  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */

  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }

    throw new Error('No element indexed by ' + aIdx);
  };
  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */

  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1 = ArraySet;
  var arraySet = {
    ArraySet: ArraySet_1,
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */

  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return (
      lineB > lineA ||
      (lineB == lineA && columnB >= columnA) ||
      util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
    );
  }
  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */

  function MappingList() {
    this._array = [];
    this._sorted = true; // Serves as infimum

    this._last = {
      generatedLine: -1,
      generatedColumn: 0,
    };
  }
  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */

  MappingList.prototype.unsortedForEach = function MappingList_forEach(
    aCallback,
    aThisArg,
  ) {
    this._array.forEach(aCallback, aThisArg);
  };
  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */

  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;

      this._array.push(aMapping);
    } else {
      this._sorted = false;

      this._array.push(aMapping);
    }
  };
  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */

  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);

      this._sorted = true;
    }

    return this._array;
  };

  var MappingList_1 = MappingList;
  var mappingList = {
    MappingList: MappingList_1,
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var ArraySet$1 = arraySet.ArraySet;
  var MappingList$1 = mappingList.MappingList;
  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */

  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }

    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList$1();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;
  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */

  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
    aSourceMapConsumer,
  ) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot,
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn,
        },
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;

        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn,
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */

  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(
    aArgs,
  ) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);

      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);

      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name,
    });
  };
  /**
   * Set the source content for a source file.
   */

  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(
    aSourceFile,
    aSourceContent,
  ) {
    var source = aSourceFile;

    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }

      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];

      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */

  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(
    aSourceMapConsumer,
    aSourceFile,
    aSourceMapPath,
  ) {
    var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.',
        );
      }

      sourceFile = aSourceMapConsumer.file;
    }

    var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    } // Applying the SourceMap can add and remove items from the sources and
    // the names array.

    var newSources = new ArraySet$1();
    var newNames = new ArraySet$1(); // Find mappings for the "sourceFile"

    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn,
        });

        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;

          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }

          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }

          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;

          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;

      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;

      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);

    this._sources = newSources;
    this._names = newNames; // Copy sourcesContents of applied map.

    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }

        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }

        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };
  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */

  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(
    aGenerated,
    aOriginal,
    aSource,
    aName,
  ) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (
      aOriginal &&
      typeof aOriginal.line !== 'number' &&
      typeof aOriginal.column !== 'number'
    ) {
      throw new Error(
        'original.line and original.column are not numbers -- you probably meant to omit ' +
          'the original mapping entirely and only map the generated position. If so, pass ' +
          'null for the original mapping instead of an object with empty or null values.',
      );
    }

    if (
      aGenerated &&
      'line' in aGenerated &&
      'column' in aGenerated &&
      aGenerated.line > 0 &&
      aGenerated.column >= 0 &&
      !aOriginal &&
      !aSource &&
      !aName
    ) {
      // Case 1.
      return;
    } else if (
      aGenerated &&
      'line' in aGenerated &&
      'column' in aGenerated &&
      aOriginal &&
      'line' in aOriginal &&
      'column' in aOriginal &&
      aGenerated.line > 0 &&
      aGenerated.column >= 0 &&
      aOriginal.line > 0 &&
      aOriginal.column >= 0 &&
      aSource
    ) {
      // Cases 2 and 3.
      return;
    } else {
      throw new Error(
        'Invalid mapping: ' +
          JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName,
          }),
      );
    }
  };
  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */

  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();

    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;

        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (
            !util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])
          ) {
            continue;
          }

          next += ',';
        }
      }

      next += base64Vlq.encode(
        mapping.generatedColumn - previousGeneratedColumn,
      );
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64Vlq.encode(sourceIdx - previousSource);
        previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

        next += base64Vlq.encode(
          mapping.originalLine - 1 - previousOriginalLine,
        );
        previousOriginalLine = mapping.originalLine - 1;
        next += base64Vlq.encode(
          mapping.originalColumn - previousOriginalColumn,
        );
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64Vlq.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(
    aSources,
    aSourceRoot,
  ) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }

      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }

      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };
  /**
   * Externalize the source map.
   */

  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings(),
    };

    if (this._file != null) {
      map.file = this._file;
    }

    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }

    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(
        map.sources,
        map.sourceRoot,
      );
    }

    return map;
  };
  /**
   * Render the source map being generated to a string.
   */

  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

  var SourceMapGenerator_1 = SourceMapGenerator;
  var sourceMapGenerator = {
    SourceMapGenerator: SourceMapGenerator_1,
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  var binarySearch = createCommonjsModule(function (module, exports) {
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    /**
     * Recursive implementation of binary search.
     *
     * @param aLow Indices here and lower do not contain the needle.
     * @param aHigh Indices here and higher do not contain the needle.
     * @param aNeedle The element being searched for.
     * @param aHaystack The non-empty array being searched.
     * @param aCompare Function which takes two elements and returns -1, 0, or 1.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     */

    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      // This function terminates when one of the following is true:
      //
      //   1. We find the exact element we are looking for.
      //
      //   2. We did not find the exact element, but we can return the index of
      //      the next-closest element.
      //
      //   3. We did not find the exact element, and there is no next-closest
      //      element than the one we are searching for, so we return -1.
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);

      if (cmp === 0) {
        // Found the element we are looking for.
        return mid;
      } else if (cmp > 0) {
        // Our needle is greater than aHaystack[mid].
        if (aHigh - mid > 1) {
          // The element is in the upper half.
          return recursiveSearch(
            mid,
            aHigh,
            aNeedle,
            aHaystack,
            aCompare,
            aBias,
          );
        } // The exact needle element was not found in this haystack. Determine if
        // we are in termination case (3) or (2) and return the appropriate thing.

        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        // Our needle is less than aHaystack[mid].
        if (mid - aLow > 1) {
          // The element is in the lower half.
          return recursiveSearch(
            aLow,
            mid,
            aNeedle,
            aHaystack,
            aCompare,
            aBias,
          );
        } // we are in termination case (3) or (2) and return the appropriate thing.

        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    /**
     * This is an implementation of binary search which will always try and return
     * the index of the closest element if there is no exact hit. This is because
     * mappings between original and generated line/col pairs are single points,
     * and there is an implicit region between each of them, so a miss just means
     * that you aren't on the very start of a region.
     *
     * @param aNeedle The element you are looking for.
     * @param aHaystack The array that is being searched.
     * @param aCompare A function which takes the needle and an element in the
     *     array and returns -1, 0, or 1 depending on whether the needle is less
     *     than, equal to, or greater than the element, respectively.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
     */

    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }

      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND,
      );

      if (index < 0) {
        return -1;
      } // We have found either the exact element, or the next-closest element than
      // the one we are searching for. However, there may be more than one such
      // element. Make sure we always return the smallest of these.

      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }

        --index;
      }

      return index;
    };
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */

  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */

  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.
    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.
      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1; // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */

  var quickSort_1 = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

  var quickSort = {
    quickSort: quickSort_1,
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var ArraySet$2 = arraySet.ArraySet;
  var quickSort$1 = quickSort.quickSort;

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap)
      : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };
  /**
   * The version of the source mapping spec that we are consuming.
   */

  SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    },
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    },
  });

  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(
    aStr,
    index,
  ) {
    var c = aStr.charAt(index);
    return c === ';' || c === ',';
  };
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */

  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
    aStr,
    aSourceRoot,
  ) {
    throw new Error('Subclasses must implement _parseMappings');
  };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */

  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(
    aCallback,
    aContext,
    aOrder,
  ) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;

    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;

      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;

      default:
        throw new Error('Unknown order of iteration.');
    }

    var sourceRoot = this.sourceRoot;
    mappings
      .map(function (mapping) {
        var source =
          mapping.source === null ? null : this._sources.at(mapping.source);

        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }

        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name),
        };
      }, this)
      .forEach(aCallback, context);
  };
  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: Optional. the column number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */

  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(
    aArgs,
  ) {
    var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.

    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0),
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }

    if (!this._sources.has(needle.source)) {
      return [];
    }

    needle.source = this._sources.indexOf(needle.source);
    var mappings = [];

    var index = this._findMapping(
      needle,
      this._originalMappings,
      'originalLine',
      'originalColumn',
      util.compareByOriginalPositions,
      binarySearch.LEAST_UPPER_BOUND,
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.

        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null),
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.

        while (
          mapping &&
          mapping.originalLine === line &&
          mapping.originalColumn == originalColumn
        ) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null),
          });
          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

  var SourceMapConsumer_1 = SourceMapConsumer;
  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */

  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.

    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    sources = sources
      .map(String) // Some source maps produce relative source paths like "./foo.js" instead of
      // "foo.js".  Normalize these first so that future comparisons will succeed.
      // See bugzil.la/1090768.
      .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
      // the source root, if the source root is absolute. Not doing this would
      // be particularly problematic when the source root is a prefix of the
      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
      .map(function (source) {
        return sourceRoot &&
          util.isAbsolute(sourceRoot) &&
          util.isAbsolute(source)
          ? util.relative(sourceRoot, source)
          : source;
      }); // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.

    this._names = ArraySet$2.fromArray(names.map(String), true);
    this._sources = ArraySet$2.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */

  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(
    aSourceMap,
  ) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = (smc._names = ArraySet$2.fromArray(
      aSourceMap._names.toArray(),
      true,
    ));
    var sources = (smc._sources = ArraySet$2.fromArray(
      aSourceMap._sources.toArray(),
      true,
    ));
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(
      smc._sources.toArray(),
      smc.sourceRoot,
    );
    smc.file = aSourceMap._file; // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();

    var destGeneratedMappings = (smc.__generatedMappings = []);
    var destOriginalMappings = (smc.__originalMappings = []);

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  /**
   * The version of the source mapping spec that we are consuming.
   */

  BasicSourceMapConsumer.prototype._version = 3;
  /**
   * The list of original sources.
   */

  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    },
  });
  /**
   * Provide the JIT with a nice shape / hidden class.
   */

  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */

  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
    aStr,
    aSourceRoot,
  ) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.

        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }

        str = aStr.slice(index, end);
        segment = cachedSegments[str];

        if (segment) {
          index += str.length;
        } else {
          segment = [];

          while (index < end) {
            base64Vlq.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        } // Generated column.

        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1]; // Original line.

          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

          mapping.originalLine += 1; // Original column.

          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);

        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort$1(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */

  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(
    aNeedle,
    aMappings,
    aLineName,
    aColumnName,
    aComparator,
    aBias,
  ) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError(
        'Line must be greater than or equal to 1, got ' + aNeedle[aLineName],
      );
    }

    if (aNeedle[aColumnName] < 0) {
      throw new TypeError(
        'Column must be greater than or equal to 0, got ' +
          aNeedle[aColumnName],
      );
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */

  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).

      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      } // The last mapping for each line spans the entire line.

      mapping.lastGeneratedColumn = Infinity;
    }
  };
  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */

  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(
    aArgs,
  ) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column'),
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      'generatedLine',
      'generatedColumn',
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND),
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);

        if (source !== null) {
          source = this._sources.at(source);

          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }

        var name = util.getArg(mapping, 'name', null);

        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name,
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null,
    };
  };
  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */

  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }

    return (
      this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) {
        return sc == null;
      })
    );
  };
  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */

  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(
    aSource,
    nullOnMissing,
  ) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;

    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, '');

      if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == '/') && this._sources.has('/' + aSource)) {
        return this.sourcesContent[this._sources.indexOf('/' + aSource)];
      }
    } // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */

  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(
    aArgs,
  ) {
    var source = util.getArg(aArgs, 'source');

    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }

    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null,
      };
    }

    source = this._sources.indexOf(source);
    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column'),
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      'originalLine',
      'originalColumn',
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND),
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null),
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null,
    };
  };

  var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;
  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */

  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet$2();
    this._names = new ArraySet$2();
    var lastOffset = {
      line: -1,
      column: 0,
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }

      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (
        offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
      ) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }

      lastOffset = offset;
      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1,
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map')),
      };
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(
    SourceMapConsumer.prototype,
  );
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  /**
   * The version of the source mapping spec that we are consuming.
   */

  IndexedSourceMapConsumer.prototype._version = 3;
  /**
   * The list of original sources.
   */

  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];

      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }

      return sources;
    },
  });
  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */

  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(
    aArgs,
  ) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column'),
    }; // Find the section containing the generated position we're trying to map
    // to an original position.

    var sectionIndex = binarySearch.search(needle, this._sections, function (
      needle,
      section,
    ) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

      if (cmp) {
        return cmp;
      }

      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null,
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column:
        needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
          ? section.generatedOffset.generatedColumn - 1
          : 0),
      bias: aArgs.bias,
    });
  };
  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */

  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */

  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(
    aSource,
    nullOnMissing,
  ) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);

      if (content) {
        return content;
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */

  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(
    aArgs,
  ) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i]; // Only consider this section if the requested source is in the list of
      // sources of the consumer.

      if (
        section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1
      ) {
        continue;
      }

      var generatedPosition = section.consumer.generatedPositionFor(aArgs);

      if (generatedPosition) {
        var ret = {
          line:
            generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column:
            generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
              ? section.generatedOffset.generatedColumn - 1
              : 0),
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null,
    };
  };
  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */

  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(
    aStr,
    aSourceRoot,
  ) {
    this.__generatedMappings = [];
    this.__originalMappings = [];

    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;

      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);

        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }

        this._sources.add(source);

        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name); // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.

        var adjustedMapping = {
          source: source,
          generatedLine:
            mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn:
            mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
              ? section.generatedOffset.generatedColumn - 1
              : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name,
        };

        this.__generatedMappings.push(adjustedMapping);

        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort$1(
      this.__generatedMappings,
      util.compareByGeneratedPositionsDeflated,
    );
    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
  };

  var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;
  var sourceMapConsumer = {
    SourceMapConsumer: SourceMapConsumer_1,
    BasicSourceMapConsumer: BasicSourceMapConsumer_1,
    IndexedSourceMapConsumer: IndexedSourceMapConsumer_1,
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator; // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).

  var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

  var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!

  var isSourceNode = '$$$isSourceNode$$$';
  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */

  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }
  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */

  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(
    aGeneratedCode,
    aSourceMapConsumer,
    aRelativePath,
  ) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode(); // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.

    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;

    var shiftNextLine = function () {
      var lineContents = getNextLine(); // The last line of a file might not have a newline.

      var newLine = getNextLine() || '';
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length
          ? remainingLines[remainingLinesIndex++]
          : undefined;
      }
    }; // We need to remember the position of "remainingLines"

    var lastGeneratedLine = 1,
      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.

    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0; // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(
            0,
            mapping.generatedColumn - lastGeneratedColumn,
          );
          remainingLines[remainingLinesIndex] = nextLine.substr(
            mapping.generatedColumn - lastGeneratedColumn,
          );
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code); // No more remaining code, continue

          lastMapping = mapping;
          return;
        }
      } // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.

      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }

      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(
          mapping.generatedColumn,
        );
        lastGeneratedColumn = mapping.generatedColumn;
      }

      lastMapping = mapping;
    }, this); // We have processed all mappings.

    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      } // and add the remaining lines without any mapping

      node.add(remainingLines.splice(remainingLinesIndex).join(''));
    } // Copy sourcesContent into SourceNode

    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }

        node.setSourceContent(sourceFile, content);
      }
    });
    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(
          new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name,
          ),
        );
      }
    }
  };
  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */

  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
          aChunk,
      );
    }

    return this;
  };
  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */

  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
          aChunk,
      );
    }

    return this;
  };
  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */

  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;

    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];

      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name,
          });
        }
      }
    }
  };
  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */

  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;

    if (len > 0) {
      newChildren = [];

      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }

      newChildren.push(this.children[i]);
      this.children = newChildren;
    }

    return this;
  };
  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */

  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
    aPattern,
    aReplacement,
  ) {
    var lastChild = this.children[this.children.length - 1];

    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(
        aPattern,
        aReplacement,
      );
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }

    return this;
  };
  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */

  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(
    aSourceFile,
    aSourceContent,
  ) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */

  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(
    aFn,
  ) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);

    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */

  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = '';
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };
  /**
   * Returns the string representation of this source node along with a source
   * map.
   */

  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(
    aArgs,
  ) {
    var generated = {
      code: '',
      line: 1,
      column: 0,
    };
    var map = new SourceMapGenerator$1(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;

      if (
        original.source !== null &&
        original.line !== null &&
        original.column !== null
      ) {
        if (
          lastOriginalSource !== original.source ||
          lastOriginalLine !== original.line ||
          lastOriginalColumn !== original.column ||
          lastOriginalName !== original.name
        ) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column,
            },
            generated: {
              line: generated.line,
              column: generated.column,
            },
            name: original.name,
          });
        }

        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column,
          },
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }

      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0; // Mappings end at eol

          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column,
              },
              generated: {
                line: generated.line,
                column: generated.column,
              },
              name: original.name,
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map,
    };
  };

  var SourceNode_1 = SourceNode;
  var sourceNode = {
    SourceNode: SourceNode_1,
  };

  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
  var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
  var SourceNode$1 = sourceNode.SourceNode;
  var sourceMap = {
    SourceMapGenerator: SourceMapGenerator$2,
    SourceMapConsumer: SourceMapConsumer$1,
    SourceNode: SourceNode$1,
  };

  var sourceMap_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    class SourceMap {
      constructor(opts, code) {
        this._cachedMap = void 0;
        this._code = void 0;
        this._opts = void 0;
        this._rawMappings = void 0;
        this._lastGenLine = void 0;
        this._lastSourceLine = void 0;
        this._lastSourceColumn = void 0;
        this._cachedMap = null;
        this._code = code;
        this._opts = opts;
        this._rawMappings = [];
      }

      get() {
        if (!this._cachedMap) {
          const map = (this._cachedMap = new sourceMap.SourceMapGenerator({
            sourceRoot: this._opts.sourceRoot,
          }));
          const code = this._code;

          if (typeof code === 'string') {
            map.setSourceContent(
              this._opts.sourceFileName.replace(/\\/g, '/'),
              code,
            );
          } else if (typeof code === 'object') {
            Object.keys(code).forEach((sourceFileName) => {
              map.setSourceContent(
                sourceFileName.replace(/\\/g, '/'),
                code[sourceFileName],
              );
            });
          }

          this._rawMappings.forEach((mapping) => map.addMapping(mapping), map);
        }

        return this._cachedMap.toJSON();
      }

      getRawMappings() {
        return this._rawMappings.slice();
      }

      mark(
        generatedLine,
        generatedColumn,
        line,
        column,
        identifierName,
        filename,
        force,
      ) {
        if (this._lastGenLine !== generatedLine && line === null) return;

        if (
          !force &&
          this._lastGenLine === generatedLine &&
          this._lastSourceLine === line &&
          this._lastSourceColumn === column
        ) {
          return;
        }

        this._cachedMap = null;
        this._lastGenLine = generatedLine;
        this._lastSourceLine = line;
        this._lastSourceColumn = column;

        this._rawMappings.push({
          name: identifierName || undefined,
          generated: {
            line: generatedLine,
            column: generatedColumn,
          },
          source:
            line == null
              ? undefined
              : (filename || this._opts.sourceFileName).replace(/\\/g, '/'),
          original:
            line == null
              ? undefined
              : {
                  line: line,
                  column: column,
                },
        });
      }
    }

    exports.default = SourceMap;
  });

  var buffer = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;
    const SPACES_RE = /^[ \t]+$/;

    class Buffer {
      constructor(map) {
        this._map = null;
        this._buf = [];
        this._last = '';
        this._queue = [];
        this._position = {
          line: 1,
          column: 0,
        };
        this._sourcePosition = {
          identifierName: null,
          line: null,
          column: null,
          filename: null,
        };
        this._disallowedPop = null;
        this._map = map;
      }

      get() {
        this._flush();

        const map = this._map;
        const result = {
          code: this._buf.join('').trimRight(),
          map: null,
          rawMappings: map == null ? void 0 : map.getRawMappings(),
        };

        if (map) {
          Object.defineProperty(result, 'map', {
            configurable: true,
            enumerable: true,

            get() {
              return (this.map = map.get());
            },

            set(value) {
              Object.defineProperty(this, 'map', {
                value,
                writable: true,
              });
            },
          });
        }

        return result;
      }

      append(str) {
        this._flush();

        const {
          line,
          column,
          filename,
          identifierName,
          force,
        } = this._sourcePosition;

        this._append(str, line, column, identifierName, filename, force);
      }

      queue(str) {
        if (str === '\n') {
          while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
            this._queue.shift();
          }
        }

        const {
          line,
          column,
          filename,
          identifierName,
          force,
        } = this._sourcePosition;

        this._queue.unshift([
          str,
          line,
          column,
          identifierName,
          filename,
          force,
        ]);
      }

      _flush() {
        let item;

        while ((item = this._queue.pop())) {
          this._append(...item);
        }
      }

      _append(str, line, column, identifierName, filename, force) {
        this._buf.push(str);

        this._last = str[str.length - 1];
        let i = str.indexOf('\n');
        let last = 0;

        if (i !== 0) {
          this._mark(line, column, identifierName, filename, force);
        }

        while (i !== -1) {
          this._position.line++;
          this._position.column = 0;
          last = i + 1;

          if (last < str.length) {
            this._mark(++line, 0, identifierName, filename, force);
          }

          i = str.indexOf('\n', last);
        }

        this._position.column += str.length - last;
      }

      _mark(line, column, identifierName, filename, force) {
        var _this$_map;

        (_this$_map = this._map) == null
          ? void 0
          : _this$_map.mark(
              this._position.line,
              this._position.column,
              line,
              column,
              identifierName,
              filename,
              force,
            );
      }

      removeTrailingNewline() {
        if (this._queue.length > 0 && this._queue[0][0] === '\n') {
          this._queue.shift();
        }
      }

      removeLastSemicolon() {
        if (this._queue.length > 0 && this._queue[0][0] === ';') {
          this._queue.shift();
        }
      }

      endsWith(suffix) {
        if (suffix.length === 1) {
          let last;

          if (this._queue.length > 0) {
            const str = this._queue[0][0];
            last = str[str.length - 1];
          } else {
            last = this._last;
          }

          return last === suffix;
        }

        const end =
          this._last + this._queue.reduce((acc, item) => item[0] + acc, '');

        if (suffix.length <= end.length) {
          return end.slice(-suffix.length) === suffix;
        }

        return false;
      }

      hasContent() {
        return this._queue.length > 0 || !!this._last;
      }

      exactSource(loc, cb) {
        this.source('start', loc, true);
        cb();
        this.source('end', loc);

        this._disallowPop('start', loc);
      }

      source(prop, loc, force) {
        if (prop && !loc) return;

        this._normalizePosition(prop, loc, this._sourcePosition, force);
      }

      withSource(prop, loc, cb) {
        if (!this._map) return cb();
        const originalLine = this._sourcePosition.line;
        const originalColumn = this._sourcePosition.column;
        const originalFilename = this._sourcePosition.filename;
        const originalIdentifierName = this._sourcePosition.identifierName;
        this.source(prop, loc);
        cb();

        if (
          (!this._sourcePosition.force ||
            this._sourcePosition.line !== originalLine ||
            this._sourcePosition.column !== originalColumn ||
            this._sourcePosition.filename !== originalFilename) &&
          (!this._disallowedPop ||
            this._disallowedPop.line !== originalLine ||
            this._disallowedPop.column !== originalColumn ||
            this._disallowedPop.filename !== originalFilename)
        ) {
          this._sourcePosition.line = originalLine;
          this._sourcePosition.column = originalColumn;
          this._sourcePosition.filename = originalFilename;
          this._sourcePosition.identifierName = originalIdentifierName;
          this._sourcePosition.force = false;
          this._disallowedPop = null;
        }
      }

      _disallowPop(prop, loc) {
        if (prop && !loc) return;
        this._disallowedPop = this._normalizePosition(prop, loc);
      }

      _normalizePosition(prop, loc, targetObj, force) {
        const pos = loc ? loc[prop] : null;

        if (targetObj === undefined) {
          targetObj = {
            identifierName: null,
            line: null,
            column: null,
            filename: null,
            force: false,
          };
        }

        const origLine = targetObj.line;
        const origColumn = targetObj.column;
        const origFilename = targetObj.filename;
        targetObj.identifierName =
          (prop === 'start' && (loc == null ? void 0 : loc.identifierName)) ||
          null;
        targetObj.line = pos == null ? void 0 : pos.line;
        targetObj.column = pos == null ? void 0 : pos.column;
        targetObj.filename = loc == null ? void 0 : loc.filename;

        if (
          force ||
          targetObj.line !== origLine ||
          targetObj.column !== origColumn ||
          targetObj.filename !== origFilename
        ) {
          targetObj.force = force;
        }

        return targetObj;
      }

      getCurrentColumn() {
        const extra = this._queue.reduce((acc, item) => item[0] + acc, '');

        const lastIndex = extra.lastIndexOf('\n');
        return lastIndex === -1
          ? this._position.column + extra.length
          : extra.length - 1 - lastIndex;
      }

      getCurrentLine() {
        const extra = this._queue.reduce((acc, item) => item[0] + acc, '');

        let count = 0;

        for (let i = 0; i < extra.length; i++) {
          if (extra[i] === '\n') count++;
        }

        return this._position.line + count;
      }
    }

    exports.default = Buffer;
  });
  /*@__PURE__*/ getDefaultExportFromCjs(buffer);

  var whitespace = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.list = exports.nodes = void 0;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function crawl(node, state = {}) {
      if (t.isMemberExpression(node) || t.isOptionalMemberExpression(node)) {
        crawl(node.object, state);
        if (node.computed) crawl(node.property, state);
      } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
        crawl(node.left, state);
        crawl(node.right, state);
      } else if (t.isCallExpression(node) || t.isOptionalCallExpression(node)) {
        state.hasCall = true;
        crawl(node.callee, state);
      } else if (t.isFunction(node)) {
        state.hasFunction = true;
      } else if (t.isIdentifier(node)) {
        state.hasHelper = state.hasHelper || isHelper(node.callee);
      }

      return state;
    }

    function isHelper(node) {
      if (t.isMemberExpression(node)) {
        return isHelper(node.object) || isHelper(node.property);
      } else if (t.isIdentifier(node)) {
        return node.name === 'require' || node.name[0] === '_';
      } else if (t.isCallExpression(node)) {
        return isHelper(node.callee);
      } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
        return (
          (t.isIdentifier(node.left) && isHelper(node.left)) ||
          isHelper(node.right)
        );
      } else {
        return false;
      }
    }

    function isType(node) {
      return (
        t.isLiteral(node) ||
        t.isObjectExpression(node) ||
        t.isArrayExpression(node) ||
        t.isIdentifier(node) ||
        t.isMemberExpression(node)
      );
    }

    const nodes = {
      AssignmentExpression(node) {
        const state = crawl(node.right);

        if ((state.hasCall && state.hasHelper) || state.hasFunction) {
          return {
            before: state.hasFunction,
            after: true,
          };
        }
      },

      SwitchCase(node, parent) {
        return {
          before: !!node.consequent.length || parent.cases[0] === node,
          after:
            !node.consequent.length &&
            parent.cases[parent.cases.length - 1] === node,
        };
      },

      LogicalExpression(node) {
        if (t.isFunction(node.left) || t.isFunction(node.right)) {
          return {
            after: true,
          };
        }
      },

      Literal(node) {
        if (t.isStringLiteral(node) && node.value === 'use strict') {
          return {
            after: true,
          };
        }
      },

      CallExpression(node) {
        if (t.isFunction(node.callee) || isHelper(node)) {
          return {
            before: true,
            after: true,
          };
        }
      },

      OptionalCallExpression(node) {
        if (t.isFunction(node.callee)) {
          return {
            before: true,
            after: true,
          };
        }
      },

      VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
          const declar = node.declarations[i];
          let enabled = isHelper(declar.id) && !isType(declar.init);

          if (!enabled) {
            const state = crawl(declar.init);
            enabled =
              (isHelper(declar.init) && state.hasCall) || state.hasFunction;
          }

          if (enabled) {
            return {
              before: true,
              after: true,
            };
          }
        }
      },

      IfStatement(node) {
        if (t.isBlockStatement(node.consequent)) {
          return {
            before: true,
            after: true,
          };
        }
      },
    };
    exports.nodes = nodes;

    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (
      node,
      parent,
    ) {
      if (parent.properties[0] === node) {
        return {
          before: true,
        };
      }
    };

    nodes.ObjectTypeCallProperty = function (node, parent) {
      var _parent$properties;

      if (
        parent.callProperties[0] === node &&
        !(
          (_parent$properties = parent.properties) != null &&
          _parent$properties.length
        )
      ) {
        return {
          before: true,
        };
      }
    };

    nodes.ObjectTypeIndexer = function (node, parent) {
      var _parent$properties2, _parent$callPropertie;

      if (
        parent.indexers[0] === node &&
        !(
          (_parent$properties2 = parent.properties) != null &&
          _parent$properties2.length
        ) &&
        !(
          (_parent$callPropertie = parent.callProperties) != null &&
          _parent$callPropertie.length
        )
      ) {
        return {
          before: true,
        };
      }
    };

    nodes.ObjectTypeInternalSlot = function (node, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;

      if (
        parent.internalSlots[0] === node &&
        !(
          (_parent$properties3 = parent.properties) != null &&
          _parent$properties3.length
        ) &&
        !(
          (_parent$callPropertie2 = parent.callProperties) != null &&
          _parent$callPropertie2.length
        ) &&
        !(
          (_parent$indexers = parent.indexers) != null &&
          _parent$indexers.length
        )
      ) {
        return {
          before: true,
        };
      }
    };

    const list = {
      VariableDeclaration(node) {
        return node.declarations.map((decl) => decl.init);
      },

      ArrayExpression(node) {
        return node.elements;
      },

      ObjectExpression(node) {
        return node.properties;
      },
    };
    exports.list = list;
    [
      ['Function', true],
      ['Class', true],
      ['Loop', true],
      ['LabeledStatement', true],
      ['SwitchStatement', true],
      ['TryStatement', true],
    ].forEach(function ([type, amounts]) {
      if (typeof amounts === 'boolean') {
        amounts = {
          after: amounts,
          before: amounts,
        };
      }

      [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
        nodes[type] = function () {
          return amounts;
        };
      });
    });
  });

  var parentheses = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.UpdateExpression = UpdateExpression;
    exports.ObjectExpression = ObjectExpression;
    exports.DoExpression = DoExpression;
    exports.Binary = Binary;
    exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.TSAsExpression = TSAsExpression;
    exports.TSTypeAssertion = TSTypeAssertion;
    exports.TSIntersectionType = exports.TSUnionType = TSUnionType;
    exports.TSInferType = TSInferType;
    exports.BinaryExpression = BinaryExpression;
    exports.SequenceExpression = SequenceExpression;
    exports.AwaitExpression = exports.YieldExpression = YieldExpression;
    exports.ClassExpression = ClassExpression;
    exports.UnaryLike = UnaryLike;
    exports.FunctionExpression = FunctionExpression;
    exports.ArrowFunctionExpression = ArrowFunctionExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
    exports.AssignmentExpression = AssignmentExpression;
    exports.LogicalExpression = LogicalExpression;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    const PRECEDENCE = {
      '||': 0,
      '??': 0,
      '&&': 1,
      '|': 2,
      '^': 3,
      '&': 4,
      '==': 5,
      '===': 5,
      '!=': 5,
      '!==': 5,
      '<': 6,
      '>': 6,
      '<=': 6,
      '>=': 6,
      in: 6,
      instanceof: 6,
      '>>': 7,
      '<<': 7,
      '>>>': 7,
      '+': 8,
      '-': 8,
      '*': 9,
      '/': 9,
      '%': 9,
      '**': 10,
    };

    const isClassExtendsClause = (node, parent) =>
      (t.isClassDeclaration(parent) || t.isClassExpression(parent)) &&
      parent.superClass === node;

    const hasPostfixPart = (node, parent) =>
      ((t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) &&
        parent.object === node) ||
      ((t.isCallExpression(parent) ||
        t.isOptionalCallExpression(parent) ||
        t.isNewExpression(parent)) &&
        parent.callee === node) ||
      (t.isTaggedTemplateExpression(parent) && parent.tag === node) ||
      t.isTSNonNullExpression(parent);

    function NullableTypeAnnotation(node, parent) {
      return t.isArrayTypeAnnotation(parent);
    }

    function FunctionTypeAnnotation(node, parent, printStack) {
      return (
        t.isUnionTypeAnnotation(parent) ||
        t.isIntersectionTypeAnnotation(parent) ||
        t.isArrayTypeAnnotation(parent) ||
        (t.isTypeAnnotation(parent) &&
          t.isArrowFunctionExpression(printStack[printStack.length - 3]))
      );
    }

    function UpdateExpression(node, parent) {
      return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    }

    function ObjectExpression(node, parent, printStack) {
      return isFirstInStatement(printStack, {
        considerArrow: true,
      });
    }

    function DoExpression(node, parent, printStack) {
      return isFirstInStatement(printStack);
    }

    function Binary(node, parent) {
      if (
        node.operator === '**' &&
        t.isBinaryExpression(parent, {
          operator: '**',
        })
      ) {
        return parent.left === node;
      }

      if (isClassExtendsClause(node, parent)) {
        return true;
      }

      if (
        hasPostfixPart(node, parent) ||
        t.isUnaryLike(parent) ||
        t.isAwaitExpression(parent)
      ) {
        return true;
      }

      if (t.isBinary(parent)) {
        const parentOp = parent.operator;
        const parentPos = PRECEDENCE[parentOp];
        const nodeOp = node.operator;
        const nodePos = PRECEDENCE[nodeOp];

        if (
          (parentPos === nodePos &&
            parent.right === node &&
            !t.isLogicalExpression(parent)) ||
          parentPos > nodePos
        ) {
          return true;
        }
      }
    }

    function UnionTypeAnnotation(node, parent) {
      return (
        t.isArrayTypeAnnotation(parent) ||
        t.isNullableTypeAnnotation(parent) ||
        t.isIntersectionTypeAnnotation(parent) ||
        t.isUnionTypeAnnotation(parent)
      );
    }

    function TSAsExpression() {
      return true;
    }

    function TSTypeAssertion() {
      return true;
    }

    function TSUnionType(node, parent) {
      return (
        t.isTSArrayType(parent) ||
        t.isTSOptionalType(parent) ||
        t.isTSIntersectionType(parent) ||
        t.isTSUnionType(parent) ||
        t.isTSRestType(parent)
      );
    }

    function TSInferType(node, parent) {
      return t.isTSArrayType(parent) || t.isTSOptionalType(parent);
    }

    function BinaryExpression(node, parent) {
      return (
        node.operator === 'in' &&
        (t.isVariableDeclarator(parent) || t.isFor(parent))
      );
    }

    function SequenceExpression(node, parent) {
      if (
        t.isForStatement(parent) ||
        t.isThrowStatement(parent) ||
        t.isReturnStatement(parent) ||
        (t.isIfStatement(parent) && parent.test === node) ||
        (t.isWhileStatement(parent) && parent.test === node) ||
        (t.isForInStatement(parent) && parent.right === node) ||
        (t.isSwitchStatement(parent) && parent.discriminant === node) ||
        (t.isExpressionStatement(parent) && parent.expression === node)
      ) {
        return false;
      }

      return true;
    }

    function YieldExpression(node, parent) {
      return (
        t.isBinary(parent) ||
        t.isUnaryLike(parent) ||
        hasPostfixPart(node, parent) ||
        (t.isAwaitExpression(parent) && t.isYieldExpression(node)) ||
        (t.isConditionalExpression(parent) && node === parent.test) ||
        isClassExtendsClause(node, parent)
      );
    }

    function ClassExpression(node, parent, printStack) {
      return isFirstInStatement(printStack, {
        considerDefaultExports: true,
      });
    }

    function UnaryLike(node, parent) {
      return (
        hasPostfixPart(node, parent) ||
        t.isBinaryExpression(parent, {
          operator: '**',
          left: node,
        }) ||
        isClassExtendsClause(node, parent)
      );
    }

    function FunctionExpression(node, parent, printStack) {
      return isFirstInStatement(printStack, {
        considerDefaultExports: true,
      });
    }

    function ArrowFunctionExpression(node, parent) {
      return (
        t.isExportDeclaration(parent) || ConditionalExpression(node, parent)
      );
    }

    function ConditionalExpression(node, parent) {
      if (
        t.isUnaryLike(parent) ||
        t.isBinary(parent) ||
        t.isConditionalExpression(parent, {
          test: node,
        }) ||
        t.isAwaitExpression(parent) ||
        t.isTSTypeAssertion(parent) ||
        t.isTSAsExpression(parent)
      ) {
        return true;
      }

      return UnaryLike(node, parent);
    }

    function OptionalMemberExpression(node, parent) {
      return (
        t.isCallExpression(parent, {
          callee: node,
        }) ||
        t.isMemberExpression(parent, {
          object: node,
        })
      );
    }

    function AssignmentExpression(node, parent) {
      if (t.isObjectPattern(node.left)) {
        return true;
      } else {
        return ConditionalExpression(node, parent);
      }
    }

    function LogicalExpression(node, parent) {
      switch (node.operator) {
        case '||':
          if (!t.isLogicalExpression(parent)) return false;
          return parent.operator === '??' || parent.operator === '&&';

        case '&&':
          return t.isLogicalExpression(parent, {
            operator: '??',
          });

        case '??':
          return t.isLogicalExpression(parent) && parent.operator !== '??';
      }
    }

    function isFirstInStatement(
      printStack,
      {considerArrow = false, considerDefaultExports = false} = {},
    ) {
      let i = printStack.length - 1;
      let node = printStack[i];
      i--;
      let parent = printStack[i];

      while (i >= 0) {
        if (
          t.isExpressionStatement(parent, {
            expression: node,
          }) ||
          (considerDefaultExports &&
            t.isExportDefaultDeclaration(parent, {
              declaration: node,
            })) ||
          (considerArrow &&
            t.isArrowFunctionExpression(parent, {
              body: node,
            }))
        ) {
          return true;
        }

        if (
          (hasPostfixPart(node, parent) && !t.isNewExpression(parent)) ||
          (t.isSequenceExpression(parent) && parent.expressions[0] === node) ||
          t.isConditional(parent, {
            test: node,
          }) ||
          t.isBinary(parent, {
            left: node,
          }) ||
          t.isAssignmentExpression(parent, {
            left: node,
          })
        ) {
          node = parent;
          i--;
          parent = printStack[i];
        } else {
          return false;
        }
      }

      return false;
    }
  });

  var needsWhitespace_1 = needsWhitespace;
  var needsWhitespaceBefore_1 = needsWhitespaceBefore;
  var needsWhitespaceAfter_1 = needsWhitespaceAfter;
  var needsParens_1 = needsParens;

  var whitespace$1 = _interopRequireWildcard$6(whitespace);

  var parens = _interopRequireWildcard$6(parentheses);

  var t$1 = _interopRequireWildcard$6(lib$2);

  function _getRequireWildcardCache$6() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$6 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$6(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$6();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function expandAliases(obj) {
    const newObj = {};

    function add(type, func) {
      const fn = newObj[type];
      newObj[type] = fn
        ? function (node, parent, stack) {
            const result = fn(node, parent, stack);
            return result == null ? func(node, parent, stack) : result;
          }
        : func;
    }

    for (const type of Object.keys(obj)) {
      const aliases = t$1.FLIPPED_ALIAS_KEYS[type];

      if (aliases) {
        for (const alias of aliases) {
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }

    return newObj;
  }

  const expandedParens = expandAliases(parens);
  const expandedWhitespaceNodes = expandAliases(whitespace$1.nodes);
  const expandedWhitespaceList = expandAliases(whitespace$1.list);

  function find(obj, node, parent, printStack) {
    const fn = obj[node.type];
    return fn ? fn(node, parent, printStack) : null;
  }

  function isOrHasCallExpression(node) {
    if (t$1.isCallExpression(node)) {
      return true;
    }

    return t$1.isMemberExpression(node) && isOrHasCallExpression(node.object);
  }

  function needsWhitespace(node, parent, type) {
    if (!node) return 0;

    if (t$1.isExpressionStatement(node)) {
      node = node.expression;
    }

    let linesInfo = find(expandedWhitespaceNodes, node, parent);

    if (!linesInfo) {
      const items = find(expandedWhitespaceList, node, parent);

      if (items) {
        for (let i = 0; i < items.length; i++) {
          linesInfo = needsWhitespace(items[i], node, type);
          if (linesInfo) break;
        }
      }
    }

    if (typeof linesInfo === 'object' && linesInfo !== null) {
      return linesInfo[type] || 0;
    }

    return 0;
  }

  function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, 'before');
  }

  function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, 'after');
  }

  function needsParens(node, parent, printStack) {
    if (!parent) return false;

    if (t$1.isNewExpression(parent) && parent.callee === node) {
      if (isOrHasCallExpression(node)) return true;
    }

    return find(expandedParens, node, parent, printStack);
  }

  var node$1 = /*#__PURE__*/ Object.defineProperty(
    {
      needsWhitespace: needsWhitespace_1,
      needsWhitespaceBefore: needsWhitespaceBefore_1,
      needsWhitespaceAfter: needsWhitespaceAfter_1,
      needsParens: needsParens_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var TaggedTemplateExpression_1 = TaggedTemplateExpression;
  var TemplateElement_1 = TemplateElement;
  var TemplateLiteral_1 = TemplateLiteral;

  _interopRequireWildcard$7(lib$2);

  function _getRequireWildcardCache$7() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$7 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$7(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$7();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function TaggedTemplateExpression(node) {
    this.print(node.tag, node);
    this.print(node.typeParameters, node);
    this.print(node.quasi, node);
  }

  function TemplateElement(node, parent) {
    const isFirst = parent.quasis[0] === node;
    const isLast = parent.quasis[parent.quasis.length - 1] === node;
    const value =
      (isFirst ? '`' : '}') + node.value.raw + (isLast ? '`' : '${');
    this.token(value);
  }

  function TemplateLiteral(node) {
    const quasis = node.quasis;

    for (let i = 0; i < quasis.length; i++) {
      this.print(quasis[i], node);

      if (i + 1 < quasis.length) {
        this.print(node.expressions[i], node);
      }
    }
  }

  var templateLiterals = /*#__PURE__*/ Object.defineProperty(
    {
      TaggedTemplateExpression: TaggedTemplateExpression_1,
      TemplateElement: TemplateElement_1,
      TemplateLiteral: TemplateLiteral_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var expressions = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.UnaryExpression = UnaryExpression;
    exports.DoExpression = DoExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.NewExpression = NewExpression;
    exports.SequenceExpression = SequenceExpression;
    exports.ThisExpression = ThisExpression;
    exports.Super = Super;
    exports.Decorator = Decorator;
    exports.OptionalMemberExpression = OptionalMemberExpression;
    exports.OptionalCallExpression = OptionalCallExpression;
    exports.CallExpression = CallExpression;
    exports.Import = Import;
    exports.EmptyStatement = EmptyStatement;
    exports.ExpressionStatement = ExpressionStatement;
    exports.AssignmentPattern = AssignmentPattern;
    exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
    exports.BindExpression = BindExpression;
    exports.MemberExpression = MemberExpression;
    exports.MetaProperty = MetaProperty;
    exports.PrivateName = PrivateName;
    exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports.ModuleExpression = ModuleExpression;
    exports.AwaitExpression = exports.YieldExpression = void 0;

    var t = _interopRequireWildcard(lib$2);

    var n = _interopRequireWildcard(node$1);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function UnaryExpression(node) {
      if (
        node.operator === 'void' ||
        node.operator === 'delete' ||
        node.operator === 'typeof' ||
        node.operator === 'throw'
      ) {
        this.word(node.operator);
        this.space();
      } else {
        this.token(node.operator);
      }

      this.print(node.argument, node);
    }

    function DoExpression(node) {
      this.word('do');
      this.space();
      this.print(node.body, node);
    }

    function ParenthesizedExpression(node) {
      this.token('(');
      this.print(node.expression, node);
      this.token(')');
    }

    function UpdateExpression(node) {
      if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument, node);
      } else {
        this.startTerminatorless(true);
        this.print(node.argument, node);
        this.endTerminatorless();
        this.token(node.operator);
      }
    }

    function ConditionalExpression(node) {
      this.print(node.test, node);
      this.space();
      this.token('?');
      this.space();
      this.print(node.consequent, node);
      this.space();
      this.token(':');
      this.space();
      this.print(node.alternate, node);
    }

    function NewExpression(node, parent) {
      this.word('new');
      this.space();
      this.print(node.callee, node);

      if (
        this.format.minified &&
        node.arguments.length === 0 &&
        !node.optional &&
        !t.isCallExpression(parent, {
          callee: node,
        }) &&
        !t.isMemberExpression(parent) &&
        !t.isNewExpression(parent)
      ) {
        return;
      }

      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);

      if (node.optional) {
        this.token('?.');
      }

      this.token('(');
      this.printList(node.arguments, node);
      this.token(')');
    }

    function SequenceExpression(node) {
      this.printList(node.expressions, node);
    }

    function ThisExpression() {
      this.word('this');
    }

    function Super() {
      this.word('super');
    }

    function Decorator(node) {
      this.token('@');
      this.print(node.expression, node);
      this.newline();
    }

    function OptionalMemberExpression(node) {
      this.print(node.object, node);

      if (!node.computed && t.isMemberExpression(node.property)) {
        throw new TypeError(
          'Got a MemberExpression for MemberExpression property',
        );
      }

      let computed = node.computed;

      if (
        t.isLiteral(node.property) &&
        typeof node.property.value === 'number'
      ) {
        computed = true;
      }

      if (node.optional) {
        this.token('?.');
      }

      if (computed) {
        this.token('[');
        this.print(node.property, node);
        this.token(']');
      } else {
        if (!node.optional) {
          this.token('.');
        }

        this.print(node.property, node);
      }
    }

    function OptionalCallExpression(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);

      if (node.optional) {
        this.token('?.');
      }

      this.token('(');
      this.printList(node.arguments, node);
      this.token(')');
    }

    function CallExpression(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      this.token('(');
      this.printList(node.arguments, node);
      this.token(')');
    }

    function Import() {
      this.word('import');
    }

    function buildYieldAwait(keyword) {
      return function (node) {
        this.word(keyword);

        if (node.delegate) {
          this.token('*');
        }

        if (node.argument) {
          this.space();
          const terminatorState = this.startTerminatorless();
          this.print(node.argument, node);
          this.endTerminatorless(terminatorState);
        }
      };
    }

    const YieldExpression = buildYieldAwait('yield');
    exports.YieldExpression = YieldExpression;
    const AwaitExpression = buildYieldAwait('await');
    exports.AwaitExpression = AwaitExpression;

    function EmptyStatement() {
      this.semicolon(true);
    }

    function ExpressionStatement(node) {
      this.print(node.expression, node);
      this.semicolon();
    }

    function AssignmentPattern(node) {
      this.print(node.left, node);
      if (node.left.optional) this.token('?');
      this.print(node.left.typeAnnotation, node);
      this.space();
      this.token('=');
      this.space();
      this.print(node.right, node);
    }

    function AssignmentExpression(node, parent) {
      const parens =
        this.inForStatementInitCounter &&
        node.operator === 'in' &&
        !n.needsParens(node, parent);

      if (parens) {
        this.token('(');
      }

      this.print(node.left, node);
      this.space();

      if (node.operator === 'in' || node.operator === 'instanceof') {
        this.word(node.operator);
      } else {
        this.token(node.operator);
      }

      this.space();
      this.print(node.right, node);

      if (parens) {
        this.token(')');
      }
    }

    function BindExpression(node) {
      this.print(node.object, node);
      this.token('::');
      this.print(node.callee, node);
    }

    function MemberExpression(node) {
      this.print(node.object, node);

      if (!node.computed && t.isMemberExpression(node.property)) {
        throw new TypeError(
          'Got a MemberExpression for MemberExpression property',
        );
      }

      let computed = node.computed;

      if (
        t.isLiteral(node.property) &&
        typeof node.property.value === 'number'
      ) {
        computed = true;
      }

      if (computed) {
        this.token('[');
        this.print(node.property, node);
        this.token(']');
      } else {
        this.token('.');
        this.print(node.property, node);
      }
    }

    function MetaProperty(node) {
      this.print(node.meta, node);
      this.token('.');
      this.print(node.property, node);
    }

    function PrivateName(node) {
      this.token('#');
      this.print(node.id, node);
    }

    function V8IntrinsicIdentifier(node) {
      this.token('%');
      this.word(node.name);
    }

    function ModuleExpression(node) {
      this.word('module');
      this.space();
      this.token('{');

      if (node.body.body.length === 0) {
        this.token('}');
      } else {
        this.newline();
        this.printSequence(node.body.body, node, {
          indent: true,
        });
        this.rightBrace();
      }
    }
  });

  var statements = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.WithStatement = WithStatement;
    exports.IfStatement = IfStatement;
    exports.ForStatement = ForStatement;
    exports.WhileStatement = WhileStatement;
    exports.DoWhileStatement = DoWhileStatement;
    exports.LabeledStatement = LabeledStatement;
    exports.TryStatement = TryStatement;
    exports.CatchClause = CatchClause;
    exports.SwitchStatement = SwitchStatement;
    exports.SwitchCase = SwitchCase;
    exports.DebuggerStatement = DebuggerStatement;
    exports.VariableDeclaration = VariableDeclaration;
    exports.VariableDeclarator = VariableDeclarator;
    exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function WithStatement(node) {
      this.word('with');
      this.space();
      this.token('(');
      this.print(node.object, node);
      this.token(')');
      this.printBlock(node);
    }

    function IfStatement(node) {
      this.word('if');
      this.space();
      this.token('(');
      this.print(node.test, node);
      this.token(')');
      this.space();
      const needsBlock =
        node.alternate && t.isIfStatement(getLastStatement(node.consequent));

      if (needsBlock) {
        this.token('{');
        this.newline();
        this.indent();
      }

      this.printAndIndentOnComments(node.consequent, node);

      if (needsBlock) {
        this.dedent();
        this.newline();
        this.token('}');
      }

      if (node.alternate) {
        if (this.endsWith('}')) this.space();
        this.word('else');
        this.space();
        this.printAndIndentOnComments(node.alternate, node);
      }
    }

    function getLastStatement(statement) {
      if (!t.isStatement(statement.body)) return statement;
      return getLastStatement(statement.body);
    }

    function ForStatement(node) {
      this.word('for');
      this.space();
      this.token('(');
      this.inForStatementInitCounter++;
      this.print(node.init, node);
      this.inForStatementInitCounter--;
      this.token(';');

      if (node.test) {
        this.space();
        this.print(node.test, node);
      }

      this.token(';');

      if (node.update) {
        this.space();
        this.print(node.update, node);
      }

      this.token(')');
      this.printBlock(node);
    }

    function WhileStatement(node) {
      this.word('while');
      this.space();
      this.token('(');
      this.print(node.test, node);
      this.token(')');
      this.printBlock(node);
    }

    const buildForXStatement = function (op) {
      return function (node) {
        this.word('for');
        this.space();

        if (op === 'of' && node.await) {
          this.word('await');
          this.space();
        }

        this.token('(');
        this.print(node.left, node);
        this.space();
        this.word(op);
        this.space();
        this.print(node.right, node);
        this.token(')');
        this.printBlock(node);
      };
    };

    const ForInStatement = buildForXStatement('in');
    exports.ForInStatement = ForInStatement;
    const ForOfStatement = buildForXStatement('of');
    exports.ForOfStatement = ForOfStatement;

    function DoWhileStatement(node) {
      this.word('do');
      this.space();
      this.print(node.body, node);
      this.space();
      this.word('while');
      this.space();
      this.token('(');
      this.print(node.test, node);
      this.token(')');
      this.semicolon();
    }

    function buildLabelStatement(prefix, key = 'label') {
      return function (node) {
        this.word(prefix);
        const label = node[key];

        if (label) {
          this.space();
          const isLabel = key == 'label';
          const terminatorState = this.startTerminatorless(isLabel);
          this.print(label, node);
          this.endTerminatorless(terminatorState);
        }

        this.semicolon();
      };
    }

    const ContinueStatement = buildLabelStatement('continue');
    exports.ContinueStatement = ContinueStatement;
    const ReturnStatement = buildLabelStatement('return', 'argument');
    exports.ReturnStatement = ReturnStatement;
    const BreakStatement = buildLabelStatement('break');
    exports.BreakStatement = BreakStatement;
    const ThrowStatement = buildLabelStatement('throw', 'argument');
    exports.ThrowStatement = ThrowStatement;

    function LabeledStatement(node) {
      this.print(node.label, node);
      this.token(':');
      this.space();
      this.print(node.body, node);
    }

    function TryStatement(node) {
      this.word('try');
      this.space();
      this.print(node.block, node);
      this.space();

      if (node.handlers) {
        this.print(node.handlers[0], node);
      } else {
        this.print(node.handler, node);
      }

      if (node.finalizer) {
        this.space();
        this.word('finally');
        this.space();
        this.print(node.finalizer, node);
      }
    }

    function CatchClause(node) {
      this.word('catch');
      this.space();

      if (node.param) {
        this.token('(');
        this.print(node.param, node);
        this.print(node.param.typeAnnotation, node);
        this.token(')');
        this.space();
      }

      this.print(node.body, node);
    }

    function SwitchStatement(node) {
      this.word('switch');
      this.space();
      this.token('(');
      this.print(node.discriminant, node);
      this.token(')');
      this.space();
      this.token('{');
      this.printSequence(node.cases, node, {
        indent: true,

        addNewlines(leading, cas) {
          if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
        },
      });
      this.token('}');
    }

    function SwitchCase(node) {
      if (node.test) {
        this.word('case');
        this.space();
        this.print(node.test, node);
        this.token(':');
      } else {
        this.word('default');
        this.token(':');
      }

      if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, node, {
          indent: true,
        });
      }
    }

    function DebuggerStatement() {
      this.word('debugger');
      this.semicolon();
    }

    function variableDeclarationIndent() {
      this.token(',');
      this.newline();
      if (this.endsWith('\n')) for (let i = 0; i < 4; i++) this.space(true);
    }

    function constDeclarationIndent() {
      this.token(',');
      this.newline();
      if (this.endsWith('\n')) for (let i = 0; i < 6; i++) this.space(true);
    }

    function VariableDeclaration(node, parent) {
      if (node.declare) {
        this.word('declare');
        this.space();
      }

      this.word(node.kind);
      this.space();
      let hasInits = false;

      if (!t.isFor(parent)) {
        for (const declar of node.declarations) {
          if (declar.init) {
            hasInits = true;
          }
        }
      }

      let separator;

      if (hasInits) {
        separator =
          node.kind === 'const'
            ? constDeclarationIndent
            : variableDeclarationIndent;
      }

      this.printList(node.declarations, node, {
        separator,
      });

      if (t.isFor(parent)) {
        if (t.isForStatement(parent)) {
          if (parent.init === node) return;
        } else {
          if (parent.left === node) return;
        }
      }

      this.semicolon();
    }

    function VariableDeclarator(node) {
      this.print(node.id, node);
      if (node.definite) this.token('!');
      this.print(node.id.typeAnnotation, node);

      if (node.init) {
        this.space();
        this.token('=');
        this.space();
        this.print(node.init, node);
      }
    }
  });

  var classes = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
    exports.ClassBody = ClassBody;
    exports.ClassProperty = ClassProperty;
    exports.ClassPrivateProperty = ClassPrivateProperty;
    exports.ClassMethod = ClassMethod;
    exports.ClassPrivateMethod = ClassPrivateMethod;
    exports._classMethodHead = _classMethodHead;
    exports.StaticBlock = StaticBlock;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function ClassDeclaration(node, parent) {
      if (
        !this.format.decoratorsBeforeExport ||
        (!t.isExportDefaultDeclaration(parent) &&
          !t.isExportNamedDeclaration(parent))
      ) {
        this.printJoin(node.decorators, node);
      }

      if (node.declare) {
        this.word('declare');
        this.space();
      }

      if (node.abstract) {
        this.word('abstract');
        this.space();
      }

      this.word('class');

      if (node.id) {
        this.space();
        this.print(node.id, node);
      }

      this.print(node.typeParameters, node);

      if (node.superClass) {
        this.space();
        this.word('extends');
        this.space();
        this.print(node.superClass, node);
        this.print(node.superTypeParameters, node);
      }

      if (node.implements) {
        this.space();
        this.word('implements');
        this.space();
        this.printList(node.implements, node);
      }

      this.space();
      this.print(node.body, node);
    }

    function ClassBody(node) {
      this.token('{');
      this.printInnerComments(node);

      if (node.body.length === 0) {
        this.token('}');
      } else {
        this.newline();
        this.indent();
        this.printSequence(node.body, node);
        this.dedent();
        if (!this.endsWith('\n')) this.newline();
        this.rightBrace();
      }
    }

    function ClassProperty(node) {
      this.printJoin(node.decorators, node);
      this.source('end', node.key.loc);
      this.tsPrintClassMemberModifiers(node, true);

      if (node.computed) {
        this.token('[');
        this.print(node.key, node);
        this.token(']');
      } else {
        this._variance(node);

        this.print(node.key, node);
      }

      if (node.optional) {
        this.token('?');
      }

      if (node.definite) {
        this.token('!');
      }

      this.print(node.typeAnnotation, node);

      if (node.value) {
        this.space();
        this.token('=');
        this.space();
        this.print(node.value, node);
      }

      this.semicolon();
    }

    function ClassPrivateProperty(node) {
      this.printJoin(node.decorators, node);

      if (node.static) {
        this.word('static');
        this.space();
      }

      this.print(node.key, node);
      this.print(node.typeAnnotation, node);

      if (node.value) {
        this.space();
        this.token('=');
        this.space();
        this.print(node.value, node);
      }

      this.semicolon();
    }

    function ClassMethod(node) {
      this._classMethodHead(node);

      this.space();
      this.print(node.body, node);
    }

    function ClassPrivateMethod(node) {
      this._classMethodHead(node);

      this.space();
      this.print(node.body, node);
    }

    function _classMethodHead(node) {
      this.printJoin(node.decorators, node);
      this.source('end', node.key.loc);
      this.tsPrintClassMemberModifiers(node, false);

      this._methodHead(node);
    }

    function StaticBlock(node) {
      this.word('static');
      this.space();
      this.token('{');

      if (node.body.length === 0) {
        this.token('}');
      } else {
        this.newline();
        this.printSequence(node.body, node, {
          indent: true,
        });
        this.rightBrace();
      }
    }
  });

  var methods = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports._params = _params;
    exports._parameters = _parameters;
    exports._param = _param;
    exports._methodHead = _methodHead;
    exports._predicate = _predicate;
    exports._functionHead = _functionHead;
    exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
    exports.ArrowFunctionExpression = ArrowFunctionExpression;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _params(node) {
      this.print(node.typeParameters, node);
      this.token('(');

      this._parameters(node.params, node);

      this.token(')');
      this.print(node.returnType, node);
    }

    function _parameters(parameters, parent) {
      for (let i = 0; i < parameters.length; i++) {
        this._param(parameters[i], parent);

        if (i < parameters.length - 1) {
          this.token(',');
          this.space();
        }
      }
    }

    function _param(parameter, parent) {
      this.printJoin(parameter.decorators, parameter);
      this.print(parameter, parent);
      if (parameter.optional) this.token('?');
      this.print(parameter.typeAnnotation, parameter);
    }

    function _methodHead(node) {
      const kind = node.kind;
      const key = node.key;

      if (kind === 'get' || kind === 'set') {
        this.word(kind);
        this.space();
      }

      if (node.async) {
        this._catchUp('start', key.loc);

        this.word('async');
        this.space();
      }

      if (kind === 'method' || kind === 'init') {
        if (node.generator) {
          this.token('*');
        }
      }

      if (node.computed) {
        this.token('[');
        this.print(key, node);
        this.token(']');
      } else {
        this.print(key, node);
      }

      if (node.optional) {
        this.token('?');
      }

      this._params(node);
    }

    function _predicate(node) {
      if (node.predicate) {
        if (!node.returnType) {
          this.token(':');
        }

        this.space();
        this.print(node.predicate, node);
      }
    }

    function _functionHead(node) {
      if (node.async) {
        this.word('async');
        this.space();
      }

      this.word('function');
      if (node.generator) this.token('*');
      this.space();

      if (node.id) {
        this.print(node.id, node);
      }

      this._params(node);

      this._predicate(node);
    }

    function FunctionExpression(node) {
      this._functionHead(node);

      this.space();
      this.print(node.body, node);
    }

    function ArrowFunctionExpression(node) {
      if (node.async) {
        this.word('async');
        this.space();
      }

      const firstParam = node.params[0];

      if (
        node.params.length === 1 &&
        t.isIdentifier(firstParam) &&
        !hasTypes(node, firstParam)
      ) {
        var _firstParam$leadingCo, _firstParam$trailingC;

        if (
          (this.format.retainLines || node.async) &&
          ((node.loc &&
            node.body.loc &&
            node.loc.start.line < node.body.loc.start.line) ||
            ((_firstParam$leadingCo = firstParam.leadingComments) != null &&
              _firstParam$leadingCo.length) ||
            ((_firstParam$trailingC = firstParam.trailingComments) != null &&
              _firstParam$trailingC.length))
        ) {
          this.token('(');

          if (
            firstParam.loc &&
            firstParam.loc.start.line > node.loc.start.line
          ) {
            this.indent();
            this.print(firstParam, node);
            this.dedent();

            this._catchUp('start', node.body.loc);
          } else {
            this.print(firstParam, node);
          }

          this.token(')');
        } else {
          this.print(firstParam, node);
        }
      } else {
        this._params(node);
      }

      this._predicate(node);

      this.space();
      this.token('=>');
      this.space();
      this.print(node.body, node);
    }

    function hasTypes(node, param) {
      return (
        node.typeParameters ||
        node.returnType ||
        param.typeAnnotation ||
        param.optional ||
        param.trailingComments
      );
    }
  });

  var ImportSpecifier_1 = ImportSpecifier;
  var ImportDefaultSpecifier_1 = ImportDefaultSpecifier;
  var ExportDefaultSpecifier_1 = ExportDefaultSpecifier;
  var ExportSpecifier_1 = ExportSpecifier;
  var ExportNamespaceSpecifier_1 = ExportNamespaceSpecifier;
  var ExportAllDeclaration_1 = ExportAllDeclaration;
  var ExportNamedDeclaration_1 = ExportNamedDeclaration;
  var ExportDefaultDeclaration_1 = ExportDefaultDeclaration;
  var ImportDeclaration_1 = ImportDeclaration;
  var ImportAttribute_1 = ImportAttribute;
  var ImportNamespaceSpecifier_1 = ImportNamespaceSpecifier;

  var t$2 = _interopRequireWildcard$8(lib$2);

  function _getRequireWildcardCache$8() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$8 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$8(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$8();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function ImportSpecifier(node) {
    if (node.importKind === 'type' || node.importKind === 'typeof') {
      this.word(node.importKind);
      this.space();
    }

    this.print(node.imported, node);

    if (node.local && node.local.name !== node.imported.name) {
      this.space();
      this.word('as');
      this.space();
      this.print(node.local, node);
    }
  }

  function ImportDefaultSpecifier(node) {
    this.print(node.local, node);
  }

  function ExportDefaultSpecifier(node) {
    this.print(node.exported, node);
  }

  function ExportSpecifier(node) {
    this.print(node.local, node);

    if (node.exported && node.local.name !== node.exported.name) {
      this.space();
      this.word('as');
      this.space();
      this.print(node.exported, node);
    }
  }

  function ExportNamespaceSpecifier(node) {
    this.token('*');
    this.space();
    this.word('as');
    this.space();
    this.print(node.exported, node);
  }

  function ExportAllDeclaration(node) {
    this.word('export');
    this.space();

    if (node.exportKind === 'type') {
      this.word('type');
      this.space();
    }

    this.token('*');
    this.space();
    this.word('from');
    this.space();
    this.print(node.source, node);
    this.printAssertions(node);
    this.semicolon();
  }

  function ExportNamedDeclaration(node) {
    if (
      this.format.decoratorsBeforeExport &&
      t$2.isClassDeclaration(node.declaration)
    ) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word('export');
    this.space();
    ExportDeclaration.apply(this, arguments);
  }

  function ExportDefaultDeclaration(node) {
    if (
      this.format.decoratorsBeforeExport &&
      t$2.isClassDeclaration(node.declaration)
    ) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word('export');
    this.space();
    this.word('default');
    this.space();
    ExportDeclaration.apply(this, arguments);
  }

  function ExportDeclaration(node) {
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar, node);
      if (!t$2.isStatement(declar)) this.semicolon();
    } else {
      if (node.exportKind === 'type') {
        this.word('type');
        this.space();
      }

      const specifiers = node.specifiers.slice(0);
      let hasSpecial = false;

      for (;;) {
        const first = specifiers[0];

        if (
          t$2.isExportDefaultSpecifier(first) ||
          t$2.isExportNamespaceSpecifier(first)
        ) {
          hasSpecial = true;
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(',');
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length || (!specifiers.length && !hasSpecial)) {
        this.token('{');

        if (specifiers.length) {
          this.space();
          this.printList(specifiers, node);
          this.space();
        }

        this.token('}');
      }

      if (node.source) {
        this.space();
        this.word('from');
        this.space();
        this.print(node.source, node);
        this.printAssertions(node);
      }

      this.semicolon();
    }
  }

  function ImportDeclaration(node) {
    var _node$attributes;

    this.word('import');
    this.space();

    if (node.importKind === 'type' || node.importKind === 'typeof') {
      this.word(node.importKind);
      this.space();
    }

    const specifiers = node.specifiers.slice(0);

    if (specifiers != null && specifiers.length) {
      for (;;) {
        const first = specifiers[0];

        if (
          t$2.isImportDefaultSpecifier(first) ||
          t$2.isImportNamespaceSpecifier(first)
        ) {
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(',');
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length) {
        this.token('{');
        this.space();
        this.printList(specifiers, node);
        this.space();
        this.token('}');
      }

      this.space();
      this.word('from');
      this.space();
    }

    this.print(node.source, node);
    this.printAssertions(node);

    if (
      (_node$attributes = node.attributes) != null &&
      _node$attributes.length
    ) {
      this.space();
      this.word('with');
      this.space();
      this.printList(node.attributes, node);
    }

    this.semicolon();
  }

  function ImportAttribute(node) {
    this.print(node.key);
    this.token(':');
    this.space();
    this.print(node.value);
  }

  function ImportNamespaceSpecifier(node) {
    this.token('*');
    this.space();
    this.word('as');
    this.space();
    this.print(node.local, node);
  }

  var modules = /*#__PURE__*/ Object.defineProperty(
    {
      ImportSpecifier: ImportSpecifier_1,
      ImportDefaultSpecifier: ImportDefaultSpecifier_1,
      ExportDefaultSpecifier: ExportDefaultSpecifier_1,
      ExportSpecifier: ExportSpecifier_1,
      ExportNamespaceSpecifier: ExportNamespaceSpecifier_1,
      ExportAllDeclaration: ExportAllDeclaration_1,
      ExportNamedDeclaration: ExportNamedDeclaration_1,
      ExportDefaultDeclaration: ExportDefaultDeclaration_1,
      ImportDeclaration: ImportDeclaration_1,
      ImportAttribute: ImportAttribute_1,
      ImportNamespaceSpecifier: ImportNamespaceSpecifier_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;

  function init() {
    inited = true;
    var code =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray(b64) {
    if (!inited) {
      init();
    }

    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice

    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

    arr = new Arr((len * 3) / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 18) |
        (revLookup[b64.charCodeAt(i + 1)] << 12) |
        (revLookup[b64.charCodeAt(i + 2)] << 6) |
        revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xff;
      arr[L++] = (tmp >> 8) & 0xff;
      arr[L++] = tmp & 0xff;
    }

    if (placeHolders === 2) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 2) |
        (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xff;
    } else if (placeHolders === 1) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 10) |
        (revLookup[b64.charCodeAt(i + 1)] << 4) |
        (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xff;
      arr[L++] = tmp & 0xff;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return (
      lookup[(num >> 18) & 0x3f] +
      lookup[(num >> 12) & 0x3f] +
      lookup[(num >> 6) & 0x3f] +
      lookup[num & 0x3f]
    );
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    if (!inited) {
      init();
    }

    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(
        encodeChunk(
          uint8,
          i,
          i + maxChunkLength > len2 ? len2 : i + maxChunkLength,
        ),
      );
    } // pad the end with zeros, but make sure to not forget the extra bytes

    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3f];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3f];
      output += lookup[(tmp << 2) & 0x3f];
      output += '=';
    }

    parts.push(output);
    return parts.join('');
  }

  function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << -nBits) - 1);
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << -nBits) - 1);
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }

  function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (
      ;
      mLen >= 8;
      buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
    ) {}

    e = (e << mLen) | m;
    eLen += mLen;

    for (
      ;
      eLen > 0;
      buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
    ) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  var isArray =
    Array.isArray ||
    function (arr) {
      return toString.call(arr) == '[object Array]';
    };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */

  var INSPECT_MAX_BYTES = 50;
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */

  Buffer.TYPED_ARRAY_SUPPORT =
    global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length');
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }

      that.length = length;
    }

    return that;
  }
  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length);
    } // Common case.

    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string',
        );
      }

      return allocUnsafe(this, arg);
    }

    return from(this, arg, encodingOrOffset, length);
  }

  Buffer.poolSize = 8192; // not used by this implementation
  // TODO: Legacy, not needed anymore. Remove in next major version.

  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr;
  };

  function from(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset);
    }

    return fromObject(that, value);
  }
  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/

  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }

  function alloc(that, size, fill, encoding) {
    assertSize(size);

    if (size <= 0) {
      return createBuffer(that, size);
    }

    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill);
    }

    return createBuffer(that, size);
  }
  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/

  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };

  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }

    return that;
  }
  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */

  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */

  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size);
  };

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that;
  }

  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }

    return that;
  }

  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }

    return that;
  }

  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that;
      }

      obj.copy(that, 0, 0, len);
      return that;
    }

    if (obj) {
      if (
        (typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) ||
        'length' in obj
      ) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0);
        }

        return fromArrayLike(that, obj);
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }

    throw new TypeError(
      'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.',
    );
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError(
        'Attempt to allocate Buffer larger than maximum ' +
          'size: 0x' +
          kMaxLength().toString(16) +
          ' bytes',
      );
    }

    return length | 0;
  }

  Buffer.isBuffer = isBuffer;

  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }

  Buffer.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }

    if (
      typeof ArrayBuffer !== 'undefined' &&
      typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)
    ) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0; // Use a for loop to avoid recursion

    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes(string).length;

        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

    if (start === undefined || start < 0) {
      start = 0;
    } // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.

    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.

    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.

  Buffer.prototype._isBuffer = true;

  function swap$1(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap$1(this, i, i + 1);
    }

    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap$1(this, i, i + 3);
      swap$1(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap$1(this, i, i + 7);
      swap$1(this, i + 1, i + 6);
      swap$1(this, i + 2, i + 5);
      swap$1(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = INSPECT_MAX_BYTES;

    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }

    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(
    target,
    start,
    end,
    thisStart,
    thisEnd,
  ) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer');
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (
      start < 0 ||
      end > target.length ||
      thisStart < 0 ||
      thisEnd > this.length
    ) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf

  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1; // Normalize byteOffset

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset; // Coerce to Number.

    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    } // Normalize byteOffset: negative offsets start from the end of the buffer

    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    } // Normalize val

    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    } // Finally, search either indexOf (if dir is true) or lastIndexOf

    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xff; // Search for a byte value [0-255]

      if (
        Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function'
      ) {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (
        encoding === 'ucs2' ||
        encoding === 'ucs-2' ||
        encoding === 'utf16le' ||
        encoding === 'utf-16le'
      ) {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (
          read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)
        ) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(
    val,
    byteOffset,
    encoding,
  ) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    } // must be an even number of digits

    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(
      utf8ToBytes(string, buf.length - offset),
      buf,
      offset,
      length,
    );
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(
      utf16leToBytes(string, buf.length - offset),
      buf,
      offset,
      length,
    );
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;

      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      } // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported',
      );
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (
      (string.length > 0 && (length < 0 || offset < 0)) ||
      offset > this.length
    ) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence =
        firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xc0) === 0x80) {
              tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);

              if (tempCodePoint > 0x7f) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {
              tempCodePoint =
                ((firstByte & 0xf) << 0xc) |
                ((secondByte & 0x3f) << 0x6) |
                (thirdByte & 0x3f);

              if (
                tempCodePoint > 0x7ff &&
                (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
              ) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if (
              (secondByte & 0xc0) === 0x80 &&
              (thirdByte & 0xc0) === 0x80 &&
              (fourthByte & 0xc0) === 0x80
            ) {
              tempCodePoint =
                ((firstByte & 0xf) << 0x12) |
                ((secondByte & 0x3f) << 0xc) |
                ((thirdByte & 0x3f) << 0x6) |
                (fourthByte & 0x3f);

              if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xfffd;
        bytesPerSequence = 1;
      } else if (codePoint > 0xffff) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety

  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    } // Decode in chunks to avoid "call stack size exceeded".

    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)),
      );
    }

    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7f);
    }

    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }

    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';

    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf;

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);

      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */

  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(
    offset,
    byteLength,
    noAssert,
  ) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(
    offset,
    byteLength,
    noAssert,
  ) {
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (
      (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +
      this[offset + 3] * 0x1000000
    );
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (
      this[offset] * 0x1000000 +
      ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])
    );
  };

  Buffer.prototype.readIntLE = function readIntLE(
    offset,
    byteLength,
    noAssert,
  ) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(
    offset,
    byteLength,
    noAssert,
  ) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return val & 0x8000 ? val | 0xffff0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return val & 0x8000 ? val | 0xffff0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (
      this[offset] |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
    );
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (
      (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3]
    );
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(
    value,
    offset,
    byteLength,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xff;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xff;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(
    value,
    offset,
    byteLength,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xff;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xff;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        ((littleEndian ? i : 1 - i) * 8);
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(
    value,
    offset,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(
    value,
    offset,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(
    value,
    offset,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(
    value,
    offset,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(
    value,
    offset,
    byteLength,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xff;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(
    value,
    offset,
    byteLength,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xff;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(
    value,
    offset,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(
    value,
    offset,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(
    value,
    offset,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(
    value,
    offset,
    noAssert,
  ) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }

    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(
    value,
    offset,
    noAssert,
  ) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(
    value,
    offset,
    noAssert,
  ) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }

    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(
    value,
    offset,
    noAssert,
  ) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(
    value,
    offset,
    noAssert,
  ) {
    return writeDouble(this, value, offset, false, noAssert);
  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)

  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart,
      );
    }

    return len;
  }; // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])

  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (code < 256) {
          val = code;
        }
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } // Invalid ranges are not set to a default, so can range check early.

    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  }; // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i); // is surrogate component

      if (codePoint > 0xd7ff && codePoint < 0xe000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xdbff) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
            continue;
          } // valid lead

          leadSurrogate = codePoint;
          continue;
        } // 2 leads in a row

        if (codePoint < 0xdc00) {
          if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
          leadSurrogate = codePoint;
          continue;
        } // valid surrogate pair

        codePoint =
          (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
      }

      leadSurrogate = null; // encode utf8

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(
          (codePoint >> 0xc) | 0xe0,
          ((codePoint >> 0x6) & 0x3f) | 0x80,
          (codePoint & 0x3f) | 0x80,
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(
          (codePoint >> 0x12) | 0xf0,
          ((codePoint >> 0xc) & 0x3f) | 0x80,
          ((codePoint >> 0x6) & 0x3f) | 0x80,
          (codePoint & 0x3f) | 0x80,
        );
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xff);
    }

    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  }

  function isnan(val) {
    return val !== val; // eslint-disable-line no-self-compare
  } // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually

  function isBuffer(obj) {
    return (
      obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    );
  }

  function isFastBuffer(obj) {
    return (
      !!obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj)
    );
  } // For Node v0.10 support. Remove this eventually.

  function isSlowBuffer(obj) {
    return (
      typeof obj.readFloatLE === 'function' &&
      typeof obj.slice === 'function' &&
      isFastBuffer(obj.slice(0, 0))
    );
  }

  const object = {};
  const hasOwnProperty = object.hasOwnProperty;

  const forOwn = (object, callback) => {
    for (const key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(key, object[key]);
      }
    }
  };

  const extend = (destination, source) => {
    if (!source) {
      return destination;
    }

    forOwn(source, (key, value) => {
      destination[key] = value;
    });
    return destination;
  };

  const forEach = (array, callback) => {
    const length = array.length;
    let index = -1;

    while (++index < length) {
      callback(array[index]);
    }
  };

  const toString$1 = object.toString;
  const isArray$1 = Array.isArray;
  const isBuffer$1 = Buffer.isBuffer;

  const isObject = (value) => {
    // This is a very simple check, but it’s good enough for what we need.
    return toString$1.call(value) == '[object Object]';
  };

  const isString = (value) => {
    return (
      typeof value == 'string' || toString$1.call(value) == '[object String]'
    );
  };

  const isNumber = (value) => {
    return (
      typeof value == 'number' || toString$1.call(value) == '[object Number]'
    );
  };

  const isFunction$1 = (value) => {
    return typeof value == 'function';
  };

  const isMap = (value) => {
    return toString$1.call(value) == '[object Map]';
  };

  const isSet = (value) => {
    return toString$1.call(value) == '[object Set]';
  };
  /*--------------------------------------------------------------------------*/
  // https://mathiasbynens.be/notes/javascript-escapes#single

  const singleEscapes = {
    '"': '\\"',
    "'": "\\'",
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t', // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  };
  const regexSingleEscape = /["'\\\b\f\n\r\t]/;
  const regexDigit = /[0-9]/;
  const regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

  const jsesc = (argument, options) => {
    const increaseIndentation = () => {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    }; // Handle options

    const defaults = {
      escapeEverything: false,
      minimal: false,
      isScriptContext: false,
      quotes: 'single',
      wrap: false,
      es6: false,
      json: false,
      compact: true,
      lowercaseHex: false,
      numbers: 'decimal',
      indent: '\t',
      indentLevel: 0,
      __inline1__: false,
      __inline2__: false,
    };
    const json = options && options.json;

    if (json) {
      defaults.quotes = 'double';
      defaults.wrap = true;
    }

    options = extend(defaults, options);

    if (
      options.quotes != 'single' &&
      options.quotes != 'double' &&
      options.quotes != 'backtick'
    ) {
      options.quotes = 'single';
    }

    const quote =
      options.quotes == 'double'
        ? '"'
        : options.quotes == 'backtick'
        ? '`'
        : "'";
    const compact = options.compact;
    const lowercaseHex = options.lowercaseHex;
    let indent = options.indent.repeat(options.indentLevel);
    let oldIndent = '';
    const inline1 = options.__inline1__;
    const inline2 = options.__inline2__;
    const newLine = compact ? '' : '\n';
    let result;
    let isEmpty = true;
    const useBinNumbers = options.numbers == 'binary';
    const useOctNumbers = options.numbers == 'octal';
    const useDecNumbers = options.numbers == 'decimal';
    const useHexNumbers = options.numbers == 'hexadecimal';

    if (json && argument && isFunction$1(argument.toJSON)) {
      argument = argument.toJSON();
    }

    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return 'new Map()';
        }

        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }

        return 'new Map(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isSet(argument)) {
        if (argument.size == 0) {
          return 'new Set()';
        }

        return 'new Set(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isBuffer$1(argument)) {
        if (argument.length == 0) {
          return 'Buffer.from([])';
        }

        return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isArray$1(argument)) {
        result = [];
        options.wrap = true;

        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }

        if (!inline2) {
          increaseIndentation();
        }

        forEach(argument, (value) => {
          isEmpty = false;

          if (inline2) {
            options.__inline2__ = false;
          }

          result.push(
            (compact || inline2 ? '' : indent) + jsesc(value, options),
          );
        });

        if (isEmpty) {
          return '[]';
        }

        if (inline2) {
          return '[' + result.join(', ') + ']';
        }

        return (
          '[' +
          newLine +
          result.join(',' + newLine) +
          newLine +
          (compact ? '' : oldIndent) +
          ']'
        );
      } else if (isNumber(argument)) {
        if (json) {
          // Some number values (e.g. `Infinity`) cannot be represented in JSON.
          return JSON.stringify(argument);
        }

        if (useDecNumbers) {
          return String(argument);
        }

        if (useHexNumbers) {
          let hexadecimal = argument.toString(16);

          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }

          return '0x' + hexadecimal;
        }

        if (useBinNumbers) {
          return '0b' + argument.toString(2);
        }

        if (useOctNumbers) {
          return '0o' + argument.toString(8);
        }
      } else if (!isObject(argument)) {
        if (json) {
          // For some values (e.g. `undefined`, `function` objects),
          // `JSON.stringify(value)` returns `undefined` (which isn’t valid
          // JSON) instead of `'null'`.
          return JSON.stringify(argument) || 'null';
        }

        return String(argument);
      } else {
        // it’s an object
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, (key, value) => {
          isEmpty = false;
          result.push(
            (compact ? '' : indent) +
              jsesc(key, options) +
              ':' +
              (compact ? '' : ' ') +
              jsesc(value, options),
          );
        });

        if (isEmpty) {
          return '{}';
        }

        return (
          '{' +
          newLine +
          result.join(',' + newLine) +
          newLine +
          (compact ? '' : oldIndent) +
          '}'
        );
      }
    }

    const string = argument; // Loop over each code unit in the string and escape it

    let index = -1;
    const length = string.length;
    result = '';

    while (++index < length) {
      const character = string.charAt(index);

      if (options.es6) {
        const first = string.charCodeAt(index);

        if (
          // check if it’s the start of a surrogate pair
          first >= 0xd800 &&
          first <= 0xdbff && // high surrogate
          length > index + 1 // there is a next code unit
        ) {
          const second = string.charCodeAt(index + 1);

          if (second >= 0xdc00 && second <= 0xdfff) {
            // low surrogate
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            const codePoint =
              (first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000;
            let hexadecimal = codePoint.toString(16);

            if (!lowercaseHex) {
              hexadecimal = hexadecimal.toUpperCase();
            }

            result += '\\u{' + hexadecimal + '}';
            ++index;
            continue;
          }
        }
      }

      if (!options.escapeEverything) {
        if (regexWhitelist.test(character)) {
          // It’s a printable ASCII character that is not `"`, `'` or `\`,
          // so don’t escape it.
          result += character;
          continue;
        }

        if (character == '"') {
          result += quote == character ? '\\"' : character;
          continue;
        }

        if (character == '`') {
          result += quote == character ? '\\`' : character;
          continue;
        }

        if (character == "'") {
          result += quote == character ? "\\'" : character;
          continue;
        }
      }

      if (
        character == '\0' &&
        !json &&
        !regexDigit.test(string.charAt(index + 1))
      ) {
        result += '\\0';
        continue;
      }

      if (regexSingleEscape.test(character)) {
        // no need for a `hasOwnProperty` check here
        result += singleEscapes[character];
        continue;
      }

      const charCode = character.charCodeAt(0);

      if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
        result += character;
        continue;
      }

      let hexadecimal = charCode.toString(16);

      if (!lowercaseHex) {
        hexadecimal = hexadecimal.toUpperCase();
      }

      const longhand = hexadecimal.length > 2 || json;
      const escaped =
        '\\' +
        (longhand ? 'u' : 'x') +
        ('0000' + hexadecimal).slice(longhand ? -4 : -2);
      result += escaped;
      continue;
    }

    if (options.wrap) {
      result = quote + result + quote;
    }

    if (quote == '`') {
      result = result.replace(/\$\{/g, '\\${');
    }

    if (options.isScriptContext) {
      // https://mathiasbynens.be/notes/etago
      return result
        .replace(/<\/(script|style)/gi, '<\\/$1')
        .replace(/<!--/g, json ? '\\u003C!--' : '\\x3C!--');
    }

    return result;
  };

  jsesc.version = '2.5.2';
  var jsesc_1 = jsesc;

  var types$2 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.Identifier = Identifier;
    exports.ArgumentPlaceholder = ArgumentPlaceholder;
    exports.SpreadElement = exports.RestElement = RestElement;
    exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
    exports.ObjectMethod = ObjectMethod;
    exports.ObjectProperty = ObjectProperty;
    exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
    exports.RecordExpression = RecordExpression;
    exports.TupleExpression = TupleExpression;
    exports.RegExpLiteral = RegExpLiteral;
    exports.BooleanLiteral = BooleanLiteral;
    exports.NullLiteral = NullLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.StringLiteral = StringLiteral;
    exports.BigIntLiteral = BigIntLiteral;
    exports.DecimalLiteral = DecimalLiteral;
    exports.PipelineTopicExpression = PipelineTopicExpression;
    exports.PipelineBareFunction = PipelineBareFunction;
    exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function Identifier(node) {
      this.exactSource(node.loc, () => {
        this.word(node.name);
      });
    }

    function ArgumentPlaceholder() {
      this.token('?');
    }

    function RestElement(node) {
      this.token('...');
      this.print(node.argument, node);
    }

    function ObjectExpression(node) {
      const props = node.properties;
      this.token('{');
      this.printInnerComments(node);

      if (props.length) {
        this.space();
        this.printList(props, node, {
          indent: true,
          statement: true,
        });
        this.space();
      }

      this.token('}');
    }

    function ObjectMethod(node) {
      this.printJoin(node.decorators, node);

      this._methodHead(node);

      this.space();
      this.print(node.body, node);
    }

    function ObjectProperty(node) {
      this.printJoin(node.decorators, node);

      if (node.computed) {
        this.token('[');
        this.print(node.key, node);
        this.token(']');
      } else {
        if (
          t.isAssignmentPattern(node.value) &&
          t.isIdentifier(node.key) &&
          node.key.name === node.value.left.name
        ) {
          this.print(node.value, node);
          return;
        }

        this.print(node.key, node);

        if (
          node.shorthand &&
          t.isIdentifier(node.key) &&
          t.isIdentifier(node.value) &&
          node.key.name === node.value.name
        ) {
          return;
        }
      }

      this.token(':');
      this.space();
      this.print(node.value, node);
    }

    function ArrayExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      this.token('[');
      this.printInnerComments(node);

      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];

        if (elem) {
          if (i > 0) this.space();
          this.print(elem, node);
          if (i < len - 1) this.token(',');
        } else {
          this.token(',');
        }
      }

      this.token(']');
    }

    function RecordExpression(node) {
      const props = node.properties;
      let startToken;
      let endToken;

      if (this.format.recordAndTupleSyntaxType === 'bar') {
        startToken = '{|';
        endToken = '|}';
      } else if (this.format.recordAndTupleSyntaxType === 'hash') {
        startToken = '#{';
        endToken = '}';
      } else {
        throw new Error(
          `The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(
            this.format.recordAndTupleSyntaxType,
          )} received).`,
        );
      }

      this.token(startToken);
      this.printInnerComments(node);

      if (props.length) {
        this.space();
        this.printList(props, node, {
          indent: true,
          statement: true,
        });
        this.space();
      }

      this.token(endToken);
    }

    function TupleExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      let startToken;
      let endToken;

      if (this.format.recordAndTupleSyntaxType === 'bar') {
        startToken = '[|';
        endToken = '|]';
      } else if (this.format.recordAndTupleSyntaxType === 'hash') {
        startToken = '#[';
        endToken = ']';
      } else {
        throw new Error(
          `${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`,
        );
      }

      this.token(startToken);
      this.printInnerComments(node);

      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];

        if (elem) {
          if (i > 0) this.space();
          this.print(elem, node);
          if (i < len - 1) this.token(',');
        }
      }

      this.token(endToken);
    }

    function RegExpLiteral(node) {
      this.word(`/${node.pattern}/${node.flags}`);
    }

    function BooleanLiteral(node) {
      this.word(node.value ? 'true' : 'false');
    }

    function NullLiteral() {
      this.word('null');
    }

    function NumericLiteral(node) {
      const raw = this.getPossibleRaw(node);
      const opts = this.format.jsescOption;
      const value = node.value + '';

      if (opts.numbers) {
        this.number(jsesc_1(node.value, opts));
      } else if (raw == null) {
        this.number(value);
      } else if (this.format.minified) {
        this.number(raw.length < value.length ? raw : value);
      } else {
        this.number(raw);
      }
    }

    function StringLiteral(node) {
      const raw = this.getPossibleRaw(node);

      if (!this.format.minified && raw != null) {
        this.token(raw);
        return;
      }

      const val = jsesc_1(
        node.value,
        Object.assign(
          this.format.jsescOption,
          this.format.jsonCompatibleStrings && {
            json: true,
          },
        ),
      );
      return this.token(val);
    }

    function BigIntLiteral(node) {
      const raw = this.getPossibleRaw(node);

      if (!this.format.minified && raw != null) {
        this.word(raw);
        return;
      }

      this.word(node.value + 'n');
    }

    function DecimalLiteral(node) {
      const raw = this.getPossibleRaw(node);

      if (!this.format.minified && raw != null) {
        this.word(raw);
        return;
      }

      this.word(node.value + 'm');
    }

    function PipelineTopicExpression(node) {
      this.print(node.expression, node);
    }

    function PipelineBareFunction(node) {
      this.print(node.callee, node);
    }

    function PipelinePrimaryTopicReference() {
      this.token('#');
    }
  });

  var flow$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.AnyTypeAnnotation = AnyTypeAnnotation;
    exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports.DeclareClass = DeclareClass;
    exports.DeclareFunction = DeclareFunction;
    exports.InferredPredicate = InferredPredicate;
    exports.DeclaredPredicate = DeclaredPredicate;
    exports.DeclareInterface = DeclareInterface;
    exports.DeclareModule = DeclareModule;
    exports.DeclareModuleExports = DeclareModuleExports;
    exports.DeclareTypeAlias = DeclareTypeAlias;
    exports.DeclareOpaqueType = DeclareOpaqueType;
    exports.DeclareVariable = DeclareVariable;
    exports.DeclareExportDeclaration = DeclareExportDeclaration;
    exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports.EnumDeclaration = EnumDeclaration;
    exports.EnumBooleanBody = EnumBooleanBody;
    exports.EnumNumberBody = EnumNumberBody;
    exports.EnumStringBody = EnumStringBody;
    exports.EnumSymbolBody = EnumSymbolBody;
    exports.EnumDefaultedMember = EnumDefaultedMember;
    exports.EnumBooleanMember = EnumBooleanMember;
    exports.EnumNumberMember = EnumNumberMember;
    exports.EnumStringMember = EnumStringMember;
    exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.FunctionTypeParam = FunctionTypeParam;
    exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
    exports._interfaceish = _interfaceish;
    exports._variance = _variance;
    exports.InterfaceDeclaration = InterfaceDeclaration;
    exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports.MixedTypeAnnotation = MixedTypeAnnotation;
    exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    exports.NumberTypeAnnotation = NumberTypeAnnotation;
    exports.StringTypeAnnotation = StringTypeAnnotation;
    exports.ThisTypeAnnotation = ThisTypeAnnotation;
    exports.TupleTypeAnnotation = TupleTypeAnnotation;
    exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports.TypeAlias = TypeAlias;
    exports.TypeAnnotation = TypeAnnotation;
    exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
    exports.TypeParameter = TypeParameter;
    exports.OpaqueType = OpaqueType;
    exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports.ObjectTypeIndexer = ObjectTypeIndexer;
    exports.ObjectTypeProperty = ObjectTypeProperty;
    exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.TypeCastExpression = TypeCastExpression;
    exports.Variance = Variance;
    exports.VoidTypeAnnotation = VoidTypeAnnotation;
    Object.defineProperty(exports, 'NumberLiteralTypeAnnotation', {
      enumerable: true,
      get: function () {
        return types$2.NumericLiteral;
      },
    });
    Object.defineProperty(exports, 'StringLiteralTypeAnnotation', {
      enumerable: true,
      get: function () {
        return types$2.StringLiteral;
      },
    });

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function AnyTypeAnnotation() {
      this.word('any');
    }

    function ArrayTypeAnnotation(node) {
      this.print(node.elementType, node);
      this.token('[');
      this.token(']');
    }

    function BooleanTypeAnnotation() {
      this.word('boolean');
    }

    function BooleanLiteralTypeAnnotation(node) {
      this.word(node.value ? 'true' : 'false');
    }

    function NullLiteralTypeAnnotation() {
      this.word('null');
    }

    function DeclareClass(node, parent) {
      if (!t.isDeclareExportDeclaration(parent)) {
        this.word('declare');
        this.space();
      }

      this.word('class');
      this.space();

      this._interfaceish(node);
    }

    function DeclareFunction(node, parent) {
      if (!t.isDeclareExportDeclaration(parent)) {
        this.word('declare');
        this.space();
      }

      this.word('function');
      this.space();
      this.print(node.id, node);
      this.print(node.id.typeAnnotation.typeAnnotation, node);

      if (node.predicate) {
        this.space();
        this.print(node.predicate, node);
      }

      this.semicolon();
    }

    function InferredPredicate() {
      this.token('%');
      this.word('checks');
    }

    function DeclaredPredicate(node) {
      this.token('%');
      this.word('checks');
      this.token('(');
      this.print(node.value, node);
      this.token(')');
    }

    function DeclareInterface(node) {
      this.word('declare');
      this.space();
      this.InterfaceDeclaration(node);
    }

    function DeclareModule(node) {
      this.word('declare');
      this.space();
      this.word('module');
      this.space();
      this.print(node.id, node);
      this.space();
      this.print(node.body, node);
    }

    function DeclareModuleExports(node) {
      this.word('declare');
      this.space();
      this.word('module');
      this.token('.');
      this.word('exports');
      this.print(node.typeAnnotation, node);
    }

    function DeclareTypeAlias(node) {
      this.word('declare');
      this.space();
      this.TypeAlias(node);
    }

    function DeclareOpaqueType(node, parent) {
      if (!t.isDeclareExportDeclaration(parent)) {
        this.word('declare');
        this.space();
      }

      this.OpaqueType(node);
    }

    function DeclareVariable(node, parent) {
      if (!t.isDeclareExportDeclaration(parent)) {
        this.word('declare');
        this.space();
      }

      this.word('var');
      this.space();
      this.print(node.id, node);
      this.print(node.id.typeAnnotation, node);
      this.semicolon();
    }

    function DeclareExportDeclaration(node) {
      this.word('declare');
      this.space();
      this.word('export');
      this.space();

      if (node.default) {
        this.word('default');
        this.space();
      }

      FlowExportDeclaration.apply(this, arguments);
    }

    function DeclareExportAllDeclaration() {
      this.word('declare');
      this.space();

      modules.ExportAllDeclaration.apply(this, arguments);
    }

    function EnumDeclaration(node) {
      const {id, body} = node;
      this.word('enum');
      this.space();
      this.print(id, node);
      this.print(body, node);
    }

    function enumExplicitType(context, name, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word('of');
        context.space();
        context.word(name);
      }

      context.space();
    }

    function enumBody(context, node) {
      const {members} = node;
      context.token('{');
      context.indent();
      context.newline();

      for (const member of members) {
        context.print(member, node);
        context.newline();
      }

      if (node.hasUnknownMembers) {
        context.token('...');
        context.newline();
      }

      context.dedent();
      context.token('}');
    }

    function EnumBooleanBody(node) {
      const {explicitType} = node;
      enumExplicitType(this, 'boolean', explicitType);
      enumBody(this, node);
    }

    function EnumNumberBody(node) {
      const {explicitType} = node;
      enumExplicitType(this, 'number', explicitType);
      enumBody(this, node);
    }

    function EnumStringBody(node) {
      const {explicitType} = node;
      enumExplicitType(this, 'string', explicitType);
      enumBody(this, node);
    }

    function EnumSymbolBody(node) {
      enumExplicitType(this, 'symbol', true);
      enumBody(this, node);
    }

    function EnumDefaultedMember(node) {
      const {id} = node;
      this.print(id, node);
      this.token(',');
    }

    function enumInitializedMember(context, node) {
      const {id, init} = node;
      context.print(id, node);
      context.space();
      context.token('=');
      context.space();
      context.print(init, node);
      context.token(',');
    }

    function EnumBooleanMember(node) {
      enumInitializedMember(this, node);
    }

    function EnumNumberMember(node) {
      enumInitializedMember(this, node);
    }

    function EnumStringMember(node) {
      enumInitializedMember(this, node);
    }

    function FlowExportDeclaration(node) {
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar, node);
        if (!t.isStatement(declar)) this.semicolon();
      } else {
        this.token('{');

        if (node.specifiers.length) {
          this.space();
          this.printList(node.specifiers, node);
          this.space();
        }

        this.token('}');

        if (node.source) {
          this.space();
          this.word('from');
          this.space();
          this.print(node.source, node);
        }

        this.semicolon();
      }
    }

    function ExistsTypeAnnotation() {
      this.token('*');
    }

    function FunctionTypeAnnotation(node, parent) {
      this.print(node.typeParameters, node);
      this.token('(');

      if (node.this) {
        this.word('this');
        this.token(':');
        this.space();
        this.print(node.this.typeAnnotation, node);

        if (node.params.length || node.rest) {
          this.token(',');
          this.space();
        }
      }

      this.printList(node.params, node);

      if (node.rest) {
        if (node.params.length) {
          this.token(',');
          this.space();
        }

        this.token('...');
        this.print(node.rest, node);
      }

      this.token(')');

      if (
        parent.type === 'ObjectTypeCallProperty' ||
        parent.type === 'DeclareFunction' ||
        (parent.type === 'ObjectTypeProperty' && parent.method)
      ) {
        this.token(':');
      } else {
        this.space();
        this.token('=>');
      }

      this.space();
      this.print(node.returnType, node);
    }

    function FunctionTypeParam(node) {
      this.print(node.name, node);
      if (node.optional) this.token('?');

      if (node.name) {
        this.token(':');
        this.space();
      }

      this.print(node.typeAnnotation, node);
    }

    function InterfaceExtends(node) {
      this.print(node.id, node);
      this.print(node.typeParameters, node);
    }

    function _interfaceish(node) {
      var _node$extends;

      this.print(node.id, node);
      this.print(node.typeParameters, node);

      if ((_node$extends = node.extends) != null && _node$extends.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(node.extends, node);
      }

      if (node.mixins && node.mixins.length) {
        this.space();
        this.word('mixins');
        this.space();
        this.printList(node.mixins, node);
      }

      if (node.implements && node.implements.length) {
        this.space();
        this.word('implements');
        this.space();
        this.printList(node.implements, node);
      }

      this.space();
      this.print(node.body, node);
    }

    function _variance(node) {
      if (node.variance) {
        if (node.variance.kind === 'plus') {
          this.token('+');
        } else if (node.variance.kind === 'minus') {
          this.token('-');
        }
      }
    }

    function InterfaceDeclaration(node) {
      this.word('interface');
      this.space();

      this._interfaceish(node);
    }

    function andSeparator() {
      this.space();
      this.token('&');
      this.space();
    }

    function InterfaceTypeAnnotation(node) {
      this.word('interface');

      if (node.extends && node.extends.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(node.extends, node);
      }

      this.space();
      this.print(node.body, node);
    }

    function IntersectionTypeAnnotation(node) {
      this.printJoin(node.types, node, {
        separator: andSeparator,
      });
    }

    function MixedTypeAnnotation() {
      this.word('mixed');
    }

    function EmptyTypeAnnotation() {
      this.word('empty');
    }

    function NullableTypeAnnotation(node) {
      this.token('?');
      this.print(node.typeAnnotation, node);
    }

    function NumberTypeAnnotation() {
      this.word('number');
    }

    function StringTypeAnnotation() {
      this.word('string');
    }

    function ThisTypeAnnotation() {
      this.word('this');
    }

    function TupleTypeAnnotation(node) {
      this.token('[');
      this.printList(node.types, node);
      this.token(']');
    }

    function TypeofTypeAnnotation(node) {
      this.word('typeof');
      this.space();
      this.print(node.argument, node);
    }

    function TypeAlias(node) {
      this.word('type');
      this.space();
      this.print(node.id, node);
      this.print(node.typeParameters, node);
      this.space();
      this.token('=');
      this.space();
      this.print(node.right, node);
      this.semicolon();
    }

    function TypeAnnotation(node) {
      this.token(':');
      this.space();
      if (node.optional) this.token('?');
      this.print(node.typeAnnotation, node);
    }

    function TypeParameterInstantiation(node) {
      this.token('<');
      this.printList(node.params, node, {});
      this.token('>');
    }

    function TypeParameter(node) {
      this._variance(node);

      this.word(node.name);

      if (node.bound) {
        this.print(node.bound, node);
      }

      if (node.default) {
        this.space();
        this.token('=');
        this.space();
        this.print(node.default, node);
      }
    }

    function OpaqueType(node) {
      this.word('opaque');
      this.space();
      this.word('type');
      this.space();
      this.print(node.id, node);
      this.print(node.typeParameters, node);

      if (node.supertype) {
        this.token(':');
        this.space();
        this.print(node.supertype, node);
      }

      if (node.impltype) {
        this.space();
        this.token('=');
        this.space();
        this.print(node.impltype, node);
      }

      this.semicolon();
    }

    function ObjectTypeAnnotation(node) {
      if (node.exact) {
        this.token('{|');
      } else {
        this.token('{');
      }

      const props = [
        ...node.properties,
        ...(node.callProperties || []),
        ...(node.indexers || []),
        ...(node.internalSlots || []),
      ];

      if (props.length) {
        this.space();
        this.printJoin(props, node, {
          addNewlines(leading) {
            if (leading && !props[0]) return 1;
          },

          indent: true,
          statement: true,
          iterator: () => {
            if (props.length !== 1 || node.inexact) {
              this.token(',');
              this.space();
            }
          },
        });
        this.space();
      }

      if (node.inexact) {
        this.indent();
        this.token('...');

        if (props.length) {
          this.newline();
        }

        this.dedent();
      }

      if (node.exact) {
        this.token('|}');
      } else {
        this.token('}');
      }
    }

    function ObjectTypeInternalSlot(node) {
      if (node.static) {
        this.word('static');
        this.space();
      }

      this.token('[');
      this.token('[');
      this.print(node.id, node);
      this.token(']');
      this.token(']');
      if (node.optional) this.token('?');

      if (!node.method) {
        this.token(':');
        this.space();
      }

      this.print(node.value, node);
    }

    function ObjectTypeCallProperty(node) {
      if (node.static) {
        this.word('static');
        this.space();
      }

      this.print(node.value, node);
    }

    function ObjectTypeIndexer(node) {
      if (node.static) {
        this.word('static');
        this.space();
      }

      this._variance(node);

      this.token('[');

      if (node.id) {
        this.print(node.id, node);
        this.token(':');
        this.space();
      }

      this.print(node.key, node);
      this.token(']');
      this.token(':');
      this.space();
      this.print(node.value, node);
    }

    function ObjectTypeProperty(node) {
      if (node.proto) {
        this.word('proto');
        this.space();
      }

      if (node.static) {
        this.word('static');
        this.space();
      }

      if (node.kind === 'get' || node.kind === 'set') {
        this.word(node.kind);
        this.space();
      }

      this._variance(node);

      this.print(node.key, node);
      if (node.optional) this.token('?');

      if (!node.method) {
        this.token(':');
        this.space();
      }

      this.print(node.value, node);
    }

    function ObjectTypeSpreadProperty(node) {
      this.token('...');
      this.print(node.argument, node);
    }

    function QualifiedTypeIdentifier(node) {
      this.print(node.qualification, node);
      this.token('.');
      this.print(node.id, node);
    }

    function SymbolTypeAnnotation() {
      this.word('symbol');
    }

    function orSeparator() {
      this.space();
      this.token('|');
      this.space();
    }

    function UnionTypeAnnotation(node) {
      this.printJoin(node.types, node, {
        separator: orSeparator,
      });
    }

    function TypeCastExpression(node) {
      this.token('(');
      this.print(node.expression, node);
      this.print(node.typeAnnotation, node);
      this.token(')');
    }

    function Variance(node) {
      if (node.kind === 'plus') {
        this.token('+');
      } else {
        this.token('-');
      }
    }

    function VoidTypeAnnotation() {
      this.word('void');
    }
  });

  var File_1 = File;
  var Program_1 = Program;
  var BlockStatement_1 = BlockStatement;
  var Directive_1 = Directive;
  var DirectiveLiteral_1 = DirectiveLiteral;
  var InterpreterDirective_1 = InterpreterDirective;
  var Placeholder_1 = Placeholder;

  _interopRequireWildcard$9(lib$2);

  function _getRequireWildcardCache$9() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$9 = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$9(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$9();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function File(node) {
    if (node.program) {
      this.print(node.program.interpreter, node);
    }

    this.print(node.program, node);
  }

  function Program(node) {
    this.printInnerComments(node, false);
    this.printSequence(node.directives, node);
    if (node.directives && node.directives.length) this.newline();
    this.printSequence(node.body, node);
  }

  function BlockStatement(node) {
    var _node$directives;

    this.token('{');
    this.printInnerComments(node);
    const hasDirectives =
      (_node$directives = node.directives) == null
        ? void 0
        : _node$directives.length;

    if (node.body.length || hasDirectives) {
      this.newline();
      this.printSequence(node.directives, node, {
        indent: true,
      });
      if (hasDirectives) this.newline();
      this.printSequence(node.body, node, {
        indent: true,
      });
      this.removeTrailingNewline();
      this.source('end', node.loc);
      if (!this.endsWith('\n')) this.newline();
      this.rightBrace();
    } else {
      this.source('end', node.loc);
      this.token('}');
    }
  }

  function Directive(node) {
    this.print(node.value, node);
    this.semicolon();
  }

  const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;

  function DirectiveLiteral(node) {
    const raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
      return;
    }

    const {value} = node;

    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token(`"${value}"`);
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token(`'${value}'`);
    } else {
      throw new Error(
        'Malformed AST: it is not possible to print a directive containing' +
          ' both unescaped single and double quotes.',
      );
    }
  }

  function InterpreterDirective(node) {
    this.token(`#!${node.value}\n`);
  }

  function Placeholder(node) {
    this.token('%%');
    this.print(node.name);
    this.token('%%');

    if (node.expectedNode === 'Statement') {
      this.semicolon();
    }
  }

  var base = /*#__PURE__*/ Object.defineProperty(
    {
      File: File_1,
      Program: Program_1,
      BlockStatement: BlockStatement_1,
      Directive: Directive_1,
      DirectiveLiteral: DirectiveLiteral_1,
      InterpreterDirective: InterpreterDirective_1,
      Placeholder: Placeholder_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var JSXAttribute_1 = JSXAttribute;
  var JSXIdentifier_1 = JSXIdentifier;
  var JSXNamespacedName_1 = JSXNamespacedName;
  var JSXMemberExpression_1 = JSXMemberExpression;
  var JSXSpreadAttribute_1 = JSXSpreadAttribute;
  var JSXExpressionContainer_1 = JSXExpressionContainer;
  var JSXSpreadChild_1 = JSXSpreadChild;
  var JSXText_1 = JSXText;
  var JSXElement_1 = JSXElement;
  var JSXOpeningElement_1 = JSXOpeningElement;
  var JSXClosingElement_1 = JSXClosingElement;
  var JSXEmptyExpression_1 = JSXEmptyExpression;
  var JSXFragment_1 = JSXFragment;
  var JSXOpeningFragment_1 = JSXOpeningFragment;
  var JSXClosingFragment_1 = JSXClosingFragment;

  _interopRequireWildcard$a(lib$2);

  function _getRequireWildcardCache$a() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$a = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$a(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$a();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function JSXAttribute(node) {
    this.print(node.name, node);

    if (node.value) {
      this.token('=');
      this.print(node.value, node);
    }
  }

  function JSXIdentifier(node) {
    this.word(node.name);
  }

  function JSXNamespacedName(node) {
    this.print(node.namespace, node);
    this.token(':');
    this.print(node.name, node);
  }

  function JSXMemberExpression(node) {
    this.print(node.object, node);
    this.token('.');
    this.print(node.property, node);
  }

  function JSXSpreadAttribute(node) {
    this.token('{');
    this.token('...');
    this.print(node.argument, node);
    this.token('}');
  }

  function JSXExpressionContainer(node) {
    this.token('{');
    this.print(node.expression, node);
    this.token('}');
  }

  function JSXSpreadChild(node) {
    this.token('{');
    this.token('...');
    this.print(node.expression, node);
    this.token('}');
  }

  function JSXText(node) {
    const raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
    } else {
      this.token(node.value);
    }
  }

  function JSXElement(node) {
    const open = node.openingElement;
    this.print(open, node);
    if (open.selfClosing) return;
    this.indent();

    for (const child of node.children) {
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingElement, node);
  }

  function spaceSeparator() {
    this.space();
  }

  function JSXOpeningElement(node) {
    this.token('<');
    this.print(node.name, node);
    this.print(node.typeParameters, node);

    if (node.attributes.length > 0) {
      this.space();
      this.printJoin(node.attributes, node, {
        separator: spaceSeparator,
      });
    }

    if (node.selfClosing) {
      this.space();
      this.token('/>');
    } else {
      this.token('>');
    }
  }

  function JSXClosingElement(node) {
    this.token('</');
    this.print(node.name, node);
    this.token('>');
  }

  function JSXEmptyExpression(node) {
    this.printInnerComments(node);
  }

  function JSXFragment(node) {
    this.print(node.openingFragment, node);
    this.indent();

    for (const child of node.children) {
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingFragment, node);
  }

  function JSXOpeningFragment() {
    this.token('<');
    this.token('>');
  }

  function JSXClosingFragment() {
    this.token('</');
    this.token('>');
  }

  var jsx$1 = /*#__PURE__*/ Object.defineProperty(
    {
      JSXAttribute: JSXAttribute_1,
      JSXIdentifier: JSXIdentifier_1,
      JSXNamespacedName: JSXNamespacedName_1,
      JSXMemberExpression: JSXMemberExpression_1,
      JSXSpreadAttribute: JSXSpreadAttribute_1,
      JSXExpressionContainer: JSXExpressionContainer_1,
      JSXSpreadChild: JSXSpreadChild_1,
      JSXText: JSXText_1,
      JSXElement: JSXElement_1,
      JSXOpeningElement: JSXOpeningElement_1,
      JSXClosingElement: JSXClosingElement_1,
      JSXEmptyExpression: JSXEmptyExpression_1,
      JSXFragment: JSXFragment_1,
      JSXOpeningFragment: JSXOpeningFragment_1,
      JSXClosingFragment: JSXClosingFragment_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var typescript$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.TSTypeAnnotation = TSTypeAnnotation;
    exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports.TSTypeParameter = TSTypeParameter;
    exports.TSParameterProperty = TSParameterProperty;
    exports.TSDeclareFunction = TSDeclareFunction;
    exports.TSDeclareMethod = TSDeclareMethod;
    exports.TSQualifiedName = TSQualifiedName;
    exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports.TSPropertySignature = TSPropertySignature;
    exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports.TSMethodSignature = TSMethodSignature;
    exports.TSIndexSignature = TSIndexSignature;
    exports.TSAnyKeyword = TSAnyKeyword;
    exports.TSBigIntKeyword = TSBigIntKeyword;
    exports.TSUnknownKeyword = TSUnknownKeyword;
    exports.TSNumberKeyword = TSNumberKeyword;
    exports.TSObjectKeyword = TSObjectKeyword;
    exports.TSBooleanKeyword = TSBooleanKeyword;
    exports.TSStringKeyword = TSStringKeyword;
    exports.TSSymbolKeyword = TSSymbolKeyword;
    exports.TSVoidKeyword = TSVoidKeyword;
    exports.TSUndefinedKeyword = TSUndefinedKeyword;
    exports.TSNullKeyword = TSNullKeyword;
    exports.TSNeverKeyword = TSNeverKeyword;
    exports.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports.TSThisType = TSThisType;
    exports.TSFunctionType = TSFunctionType;
    exports.TSConstructorType = TSConstructorType;
    exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports.TSTypeReference = TSTypeReference;
    exports.TSTypePredicate = TSTypePredicate;
    exports.TSTypeQuery = TSTypeQuery;
    exports.TSTypeLiteral = TSTypeLiteral;
    exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
    exports.tsPrintBraced = tsPrintBraced;
    exports.TSArrayType = TSArrayType;
    exports.TSTupleType = TSTupleType;
    exports.TSOptionalType = TSOptionalType;
    exports.TSRestType = TSRestType;
    exports.TSNamedTupleMember = TSNamedTupleMember;
    exports.TSUnionType = TSUnionType;
    exports.TSIntersectionType = TSIntersectionType;
    exports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
    exports.TSConditionalType = TSConditionalType;
    exports.TSInferType = TSInferType;
    exports.TSParenthesizedType = TSParenthesizedType;
    exports.TSTypeOperator = TSTypeOperator;
    exports.TSIndexedAccessType = TSIndexedAccessType;
    exports.TSMappedType = TSMappedType;
    exports.TSLiteralType = TSLiteralType;
    exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
    exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports.TSInterfaceBody = TSInterfaceBody;
    exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports.TSAsExpression = TSAsExpression;
    exports.TSTypeAssertion = TSTypeAssertion;
    exports.TSEnumDeclaration = TSEnumDeclaration;
    exports.TSEnumMember = TSEnumMember;
    exports.TSModuleDeclaration = TSModuleDeclaration;
    exports.TSModuleBlock = TSModuleBlock;
    exports.TSImportType = TSImportType;
    exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports.TSExternalModuleReference = TSExternalModuleReference;
    exports.TSNonNullExpression = TSNonNullExpression;
    exports.TSExportAssignment = TSExportAssignment;
    exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;

    _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function TSTypeAnnotation(node) {
      this.token(':');
      this.space();
      if (node.optional) this.token('?');
      this.print(node.typeAnnotation, node);
    }

    function TSTypeParameterInstantiation(node) {
      this.token('<');
      this.printList(node.params, node, {});
      this.token('>');
    }

    function TSTypeParameter(node) {
      this.word(node.name);

      if (node.constraint) {
        this.space();
        this.word('extends');
        this.space();
        this.print(node.constraint, node);
      }

      if (node.default) {
        this.space();
        this.token('=');
        this.space();
        this.print(node.default, node);
      }
    }

    function TSParameterProperty(node) {
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }

      if (node.readonly) {
        this.word('readonly');
        this.space();
      }

      this._param(node.parameter);
    }

    function TSDeclareFunction(node) {
      if (node.declare) {
        this.word('declare');
        this.space();
      }

      this._functionHead(node);

      this.token(';');
    }

    function TSDeclareMethod(node) {
      this._classMethodHead(node);

      this.token(';');
    }

    function TSQualifiedName(node) {
      this.print(node.left, node);
      this.token('.');
      this.print(node.right, node);
    }

    function TSCallSignatureDeclaration(node) {
      this.tsPrintSignatureDeclarationBase(node);
      this.token(';');
    }

    function TSConstructSignatureDeclaration(node) {
      this.word('new');
      this.space();
      this.tsPrintSignatureDeclarationBase(node);
      this.token(';');
    }

    function TSPropertySignature(node) {
      const {readonly, initializer} = node;

      if (readonly) {
        this.word('readonly');
        this.space();
      }

      this.tsPrintPropertyOrMethodName(node);
      this.print(node.typeAnnotation, node);

      if (initializer) {
        this.space();
        this.token('=');
        this.space();
        this.print(initializer, node);
      }

      this.token(';');
    }

    function tsPrintPropertyOrMethodName(node) {
      if (node.computed) {
        this.token('[');
      }

      this.print(node.key, node);

      if (node.computed) {
        this.token(']');
      }

      if (node.optional) {
        this.token('?');
      }
    }

    function TSMethodSignature(node) {
      this.tsPrintPropertyOrMethodName(node);
      this.tsPrintSignatureDeclarationBase(node);
      this.token(';');
    }

    function TSIndexSignature(node) {
      const {readonly} = node;

      if (readonly) {
        this.word('readonly');
        this.space();
      }

      this.token('[');

      this._parameters(node.parameters, node);

      this.token(']');
      this.print(node.typeAnnotation, node);
      this.token(';');
    }

    function TSAnyKeyword() {
      this.word('any');
    }

    function TSBigIntKeyword() {
      this.word('bigint');
    }

    function TSUnknownKeyword() {
      this.word('unknown');
    }

    function TSNumberKeyword() {
      this.word('number');
    }

    function TSObjectKeyword() {
      this.word('object');
    }

    function TSBooleanKeyword() {
      this.word('boolean');
    }

    function TSStringKeyword() {
      this.word('string');
    }

    function TSSymbolKeyword() {
      this.word('symbol');
    }

    function TSVoidKeyword() {
      this.word('void');
    }

    function TSUndefinedKeyword() {
      this.word('undefined');
    }

    function TSNullKeyword() {
      this.word('null');
    }

    function TSNeverKeyword() {
      this.word('never');
    }

    function TSIntrinsicKeyword() {
      this.word('intrinsic');
    }

    function TSThisType() {
      this.word('this');
    }

    function TSFunctionType(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }

    function TSConstructorType(node) {
      if (node.abstract) {
        this.word('abstract');
        this.space();
      }

      this.word('new');
      this.space();
      this.tsPrintFunctionOrConstructorType(node);
    }

    function tsPrintFunctionOrConstructorType(node) {
      const {typeParameters, parameters} = node;
      this.print(typeParameters, node);
      this.token('(');

      this._parameters(parameters, node);

      this.token(')');
      this.space();
      this.token('=>');
      this.space();
      this.print(node.typeAnnotation.typeAnnotation, node);
    }

    function TSTypeReference(node) {
      this.print(node.typeName, node);
      this.print(node.typeParameters, node);
    }

    function TSTypePredicate(node) {
      if (node.asserts) {
        this.word('asserts');
        this.space();
      }

      this.print(node.parameterName);

      if (node.typeAnnotation) {
        this.space();
        this.word('is');
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
      }
    }

    function TSTypeQuery(node) {
      this.word('typeof');
      this.space();
      this.print(node.exprName);
    }

    function TSTypeLiteral(node) {
      this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
    }

    function tsPrintTypeLiteralOrInterfaceBody(members, node) {
      this.tsPrintBraced(members, node);
    }

    function tsPrintBraced(members, node) {
      this.token('{');

      if (members.length) {
        this.indent();
        this.newline();

        for (const member of members) {
          this.print(member, node);
          this.newline();
        }

        this.dedent();
        this.rightBrace();
      } else {
        this.token('}');
      }
    }

    function TSArrayType(node) {
      this.print(node.elementType, node);
      this.token('[]');
    }

    function TSTupleType(node) {
      this.token('[');
      this.printList(node.elementTypes, node);
      this.token(']');
    }

    function TSOptionalType(node) {
      this.print(node.typeAnnotation, node);
      this.token('?');
    }

    function TSRestType(node) {
      this.token('...');
      this.print(node.typeAnnotation, node);
    }

    function TSNamedTupleMember(node) {
      this.print(node.label, node);
      if (node.optional) this.token('?');
      this.token(':');
      this.space();
      this.print(node.elementType, node);
    }

    function TSUnionType(node) {
      this.tsPrintUnionOrIntersectionType(node, '|');
    }

    function TSIntersectionType(node) {
      this.tsPrintUnionOrIntersectionType(node, '&');
    }

    function tsPrintUnionOrIntersectionType(node, sep) {
      this.printJoin(node.types, node, {
        separator() {
          this.space();
          this.token(sep);
          this.space();
        },
      });
    }

    function TSConditionalType(node) {
      this.print(node.checkType);
      this.space();
      this.word('extends');
      this.space();
      this.print(node.extendsType);
      this.space();
      this.token('?');
      this.space();
      this.print(node.trueType);
      this.space();
      this.token(':');
      this.space();
      this.print(node.falseType);
    }

    function TSInferType(node) {
      this.token('infer');
      this.space();
      this.print(node.typeParameter);
    }

    function TSParenthesizedType(node) {
      this.token('(');
      this.print(node.typeAnnotation, node);
      this.token(')');
    }

    function TSTypeOperator(node) {
      this.word(node.operator);
      this.space();
      this.print(node.typeAnnotation, node);
    }

    function TSIndexedAccessType(node) {
      this.print(node.objectType, node);
      this.token('[');
      this.print(node.indexType, node);
      this.token(']');
    }

    function TSMappedType(node) {
      const {nameType, optional, readonly, typeParameter} = node;
      this.token('{');
      this.space();

      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word('readonly');
        this.space();
      }

      this.token('[');
      this.word(typeParameter.name);
      this.space();
      this.word('in');
      this.space();
      this.print(typeParameter.constraint, typeParameter);

      if (nameType) {
        this.space();
        this.word('as');
        this.space();
        this.print(nameType, node);
      }

      this.token(']');

      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.token('?');
      }

      this.token(':');
      this.space();
      this.print(node.typeAnnotation, node);
      this.space();
      this.token('}');
    }

    function tokenIfPlusMinus(self, tok) {
      if (tok !== true) {
        self.token(tok);
      }
    }

    function TSLiteralType(node) {
      this.print(node.literal, node);
    }

    function TSExpressionWithTypeArguments(node) {
      this.print(node.expression, node);
      this.print(node.typeParameters, node);
    }

    function TSInterfaceDeclaration(node) {
      const {declare, id, typeParameters, extends: extendz, body} = node;

      if (declare) {
        this.word('declare');
        this.space();
      }

      this.word('interface');
      this.space();
      this.print(id, node);
      this.print(typeParameters, node);

      if (extendz != null && extendz.length) {
        this.space();
        this.word('extends');
        this.space();
        this.printList(extendz, node);
      }

      this.space();
      this.print(body, node);
    }

    function TSInterfaceBody(node) {
      this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
    }

    function TSTypeAliasDeclaration(node) {
      const {declare, id, typeParameters, typeAnnotation} = node;

      if (declare) {
        this.word('declare');
        this.space();
      }

      this.word('type');
      this.space();
      this.print(id, node);
      this.print(typeParameters, node);
      this.space();
      this.token('=');
      this.space();
      this.print(typeAnnotation, node);
      this.token(';');
    }

    function TSAsExpression(node) {
      const {expression, typeAnnotation} = node;
      this.print(expression, node);
      this.space();
      this.word('as');
      this.space();
      this.print(typeAnnotation, node);
    }

    function TSTypeAssertion(node) {
      const {typeAnnotation, expression} = node;
      this.token('<');
      this.print(typeAnnotation, node);
      this.token('>');
      this.space();
      this.print(expression, node);
    }

    function TSEnumDeclaration(node) {
      const {declare, const: isConst, id, members} = node;

      if (declare) {
        this.word('declare');
        this.space();
      }

      if (isConst) {
        this.word('const');
        this.space();
      }

      this.word('enum');
      this.space();
      this.print(id, node);
      this.space();
      this.tsPrintBraced(members, node);
    }

    function TSEnumMember(node) {
      const {id, initializer} = node;
      this.print(id, node);

      if (initializer) {
        this.space();
        this.token('=');
        this.space();
        this.print(initializer, node);
      }

      this.token(',');
    }

    function TSModuleDeclaration(node) {
      const {declare, id} = node;

      if (declare) {
        this.word('declare');
        this.space();
      }

      if (!node.global) {
        this.word(id.type === 'Identifier' ? 'namespace' : 'module');
        this.space();
      }

      this.print(id, node);

      if (!node.body) {
        this.token(';');
        return;
      }

      let body = node.body;

      while (body.type === 'TSModuleDeclaration') {
        this.token('.');
        this.print(body.id, body);
        body = body.body;
      }

      this.space();
      this.print(body, node);
    }

    function TSModuleBlock(node) {
      this.tsPrintBraced(node.body, node);
    }

    function TSImportType(node) {
      const {argument, qualifier, typeParameters} = node;
      this.word('import');
      this.token('(');
      this.print(argument, node);
      this.token(')');

      if (qualifier) {
        this.token('.');
        this.print(qualifier, node);
      }

      if (typeParameters) {
        this.print(typeParameters, node);
      }
    }

    function TSImportEqualsDeclaration(node) {
      const {isExport, id, moduleReference} = node;

      if (isExport) {
        this.word('export');
        this.space();
      }

      this.word('import');
      this.space();
      this.print(id, node);
      this.space();
      this.token('=');
      this.space();
      this.print(moduleReference, node);
      this.token(';');
    }

    function TSExternalModuleReference(node) {
      this.token('require(');
      this.print(node.expression, node);
      this.token(')');
    }

    function TSNonNullExpression(node) {
      this.print(node.expression, node);
      this.token('!');
    }

    function TSExportAssignment(node) {
      this.word('export');
      this.space();
      this.token('=');
      this.space();
      this.print(node.expression, node);
      this.token(';');
    }

    function TSNamespaceExportDeclaration(node) {
      this.word('export');
      this.space();
      this.word('as');
      this.space();
      this.word('namespace');
      this.space();
      this.print(node.id, node);
    }

    function tsPrintSignatureDeclarationBase(node) {
      const {typeParameters, parameters} = node;
      this.print(typeParameters, node);
      this.token('(');

      this._parameters(parameters, node);

      this.token(')');
      this.print(node.typeAnnotation, node);
    }

    function tsPrintClassMemberModifiers(node, isField) {
      if (isField && node.declare) {
        this.word('declare');
        this.space();
      }

      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }

      if (node.static) {
        this.word('static');
        this.space();
      }

      if (node.abstract) {
        this.word('abstract');
        this.space();
      }

      if (isField && node.readonly) {
        this.word('readonly');
        this.space();
      }
    }
  });
  /*@__PURE__*/ getDefaultExportFromCjs(typescript$1);

  var generators = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.keys(templateLiterals).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === templateLiterals[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return templateLiterals[key];
        },
      });
    });
    Object.keys(expressions).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === expressions[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return expressions[key];
        },
      });
    });
    Object.keys(statements).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === statements[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return statements[key];
        },
      });
    });
    Object.keys(classes).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === classes[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return classes[key];
        },
      });
    });
    Object.keys(methods).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === methods[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return methods[key];
        },
      });
    });
    Object.keys(modules).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === modules[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return modules[key];
        },
      });
    });
    Object.keys(types$2).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === types$2[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return types$2[key];
        },
      });
    });
    Object.keys(flow$1).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === flow$1[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return flow$1[key];
        },
      });
    });
    Object.keys(base).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === base[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return base[key];
        },
      });
    });
    Object.keys(jsx$1).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === jsx$1[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return jsx$1[key];
        },
      });
    });
    Object.keys(typescript$1).forEach(function (key) {
      if (key === 'default' || key === '__esModule') return;
      if (key in exports && exports[key] === typescript$1[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return typescript$1[key];
        },
      });
    });
  });

  var printer = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    var _buffer = _interopRequireDefault(buffer);

    var n = _interopRequireWildcard(node$1);

    var t = _interopRequireWildcard(lib$2);

    var generatorFunctions = _interopRequireWildcard(generators);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    const SCIENTIFIC_NOTATION = /e/i;
    const ZERO_DECIMAL_INTEGER = /\.0+$/;
    const NON_DECIMAL_LITERAL = /^0[box]/;
    const PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;

    class Printer {
      constructor(format, map) {
        this.inForStatementInitCounter = 0;
        this._printStack = [];
        this._indent = 0;
        this._insideAux = false;
        this._printedCommentStarts = {};
        this._parenPushNewlineState = null;
        this._noLineTerminator = false;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = new WeakSet();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this.format = format;
        this._buf = new _buffer.default(map);
      }

      generate(ast) {
        this.print(ast);

        this._maybeAddAuxComment();

        return this._buf.get();
      }

      indent() {
        if (this.format.compact || this.format.concise) return;
        this._indent++;
      }

      dedent() {
        if (this.format.compact || this.format.concise) return;
        this._indent--;
      }

      semicolon(force = false) {
        this._maybeAddAuxComment();

        this._append(';', !force);
      }

      rightBrace() {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }

        this.token('}');
      }

      space(force = false) {
        if (this.format.compact) return;

        if (
          (this._buf.hasContent() &&
            !this.endsWith(' ') &&
            !this.endsWith('\n')) ||
          force
        ) {
          this._space();
        }
      }

      word(str) {
        if (
          this._endsWithWord ||
          (this.endsWith('/') && str.indexOf('/') === 0)
        ) {
          this._space();
        }

        this._maybeAddAuxComment();

        this._append(str);

        this._endsWithWord = true;
      }

      number(str) {
        this.word(str);
        this._endsWithInteger =
          Number.isInteger(+str) &&
          !NON_DECIMAL_LITERAL.test(str) &&
          !SCIENTIFIC_NOTATION.test(str) &&
          !ZERO_DECIMAL_INTEGER.test(str) &&
          str[str.length - 1] !== '.';
      }

      token(str) {
        if (
          (str === '--' && this.endsWith('!')) ||
          (str[0] === '+' && this.endsWith('+')) ||
          (str[0] === '-' && this.endsWith('-')) ||
          (str[0] === '.' && this._endsWithInteger)
        ) {
          this._space();
        }

        this._maybeAddAuxComment();

        this._append(str);
      }

      newline(i) {
        if (this.format.retainLines || this.format.compact) return;

        if (this.format.concise) {
          this.space();
          return;
        }

        if (this.endsWith('\n\n')) return;
        if (typeof i !== 'number') i = 1;
        i = Math.min(2, i);
        if (this.endsWith('{\n') || this.endsWith(':\n')) i--;
        if (i <= 0) return;

        for (let j = 0; j < i; j++) {
          this._newline();
        }
      }

      endsWith(str) {
        return this._buf.endsWith(str);
      }

      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }

      exactSource(loc, cb) {
        this._catchUp('start', loc);

        this._buf.exactSource(loc, cb);
      }

      source(prop, loc) {
        this._catchUp(prop, loc);

        this._buf.source(prop, loc);
      }

      withSource(prop, loc, cb) {
        this._catchUp(prop, loc);

        this._buf.withSource(prop, loc, cb);
      }

      _space() {
        this._append(' ', true);
      }

      _newline() {
        this._append('\n', true);
      }

      _append(str, queue = false) {
        this._maybeAddParen(str);

        this._maybeIndent(str);

        if (queue) this._buf.queue(str);
        else this._buf.append(str);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }

      _maybeIndent(str) {
        if (this._indent && this.endsWith('\n') && str[0] !== '\n') {
          this._buf.queue(this._getIndent());
        }
      }

      _maybeAddParen(str) {
        const parenPushNewlineState = this._parenPushNewlineState;
        if (!parenPushNewlineState) return;
        let i;

        for (i = 0; i < str.length && str[i] === ' '; i++) continue;

        if (i === str.length) {
          return;
        }

        const cha = str[i];

        if (cha !== '\n') {
          if (cha !== '/' || i + 1 === str.length) {
            this._parenPushNewlineState = null;
            return;
          }

          const chaPost = str[i + 1];

          if (chaPost === '*') {
            if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
              return;
            }
          } else if (chaPost !== '/') {
            this._parenPushNewlineState = null;
            return;
          }
        }

        this.token('(');
        this.indent();
        parenPushNewlineState.printed = true;
      }

      _catchUp(prop, loc) {
        if (!this.format.retainLines) return;
        const pos = loc ? loc[prop] : null;

        if ((pos == null ? void 0 : pos.line) != null) {
          const count = pos.line - this._buf.getCurrentLine();

          for (let i = 0; i < count; i++) {
            this._newline();
          }
        }
      }

      _getIndent() {
        return this.format.indent.style.repeat(this._indent);
      }

      startTerminatorless(isLabel = false) {
        if (isLabel) {
          this._noLineTerminator = true;
          return null;
        } else {
          return (this._parenPushNewlineState = {
            printed: false,
          });
        }
      }

      endTerminatorless(state) {
        this._noLineTerminator = false;

        if (state != null && state.printed) {
          this.dedent();
          this.newline();
          this.token(')');
        }
      }

      print(node, parent) {
        if (!node) return;
        const oldConcise = this.format.concise;

        if (node._compact) {
          this.format.concise = true;
        }

        const printMethod = this[node.type];

        if (!printMethod) {
          throw new ReferenceError(
            `unknown node of type ${JSON.stringify(
              node.type,
            )} with constructor ${JSON.stringify(
              node == null ? void 0 : node.constructor.name,
            )}`,
          );
        }

        this._printStack.push(node);

        const oldInAux = this._insideAux;
        this._insideAux = !node.loc;

        this._maybeAddAuxComment(this._insideAux && !oldInAux);

        let needsParens = n.needsParens(node, parent, this._printStack);

        if (
          this.format.retainFunctionParens &&
          node.type === 'FunctionExpression' &&
          node.extra &&
          node.extra.parenthesized
        ) {
          needsParens = true;
        }

        if (needsParens) this.token('(');

        this._printLeadingComments(node);

        const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;
        this.withSource('start', loc, () => {
          printMethod.call(this, node, parent);
        });

        this._printTrailingComments(node);

        if (needsParens) this.token(')');

        this._printStack.pop();

        this.format.concise = oldConcise;
        this._insideAux = oldInAux;
      }

      _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode) this._printAuxBeforeComment();
        if (!this._insideAux) this._printAuxAfterComment();
      }

      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = true;
        const comment = this.format.auxiliaryCommentBefore;

        if (comment) {
          this._printComment({
            type: 'CommentBlock',
            value: comment,
          });
        }
      }

      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = false;
        const comment = this.format.auxiliaryCommentAfter;

        if (comment) {
          this._printComment({
            type: 'CommentBlock',
            value: comment,
          });
        }
      }

      getPossibleRaw(node) {
        const extra = node.extra;

        if (
          extra &&
          extra.raw != null &&
          extra.rawValue != null &&
          node.value === extra.rawValue
        ) {
          return extra.raw;
        }
      }

      printJoin(nodes, parent, opts = {}) {
        if (!(nodes != null && nodes.length)) return;
        if (opts.indent) this.indent();
        const newlineOpts = {
          addNewlines: opts.addNewlines,
        };

        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!node) continue;
          if (opts.statement)
            this._printNewline(true, node, parent, newlineOpts);
          this.print(node, parent);

          if (opts.iterator) {
            opts.iterator(node, i);
          }

          if (opts.separator && i < nodes.length - 1) {
            opts.separator.call(this);
          }

          if (opts.statement)
            this._printNewline(false, node, parent, newlineOpts);
        }

        if (opts.indent) this.dedent();
      }

      printAndIndentOnComments(node, parent) {
        const indent = node.leadingComments && node.leadingComments.length > 0;
        if (indent) this.indent();
        this.print(node, parent);
        if (indent) this.dedent();
      }

      printBlock(parent) {
        const node = parent.body;

        if (!t.isEmptyStatement(node)) {
          this.space();
        }

        this.print(node, parent);
      }

      _printTrailingComments(node) {
        this._printComments(this._getComments(false, node));
      }

      _printLeadingComments(node) {
        this._printComments(this._getComments(true, node), true);
      }

      printInnerComments(node, indent = true) {
        var _node$innerComments;

        if (
          !(
            (_node$innerComments = node.innerComments) != null &&
            _node$innerComments.length
          )
        )
          return;
        if (indent) this.indent();

        this._printComments(node.innerComments);

        if (indent) this.dedent();
      }

      printSequence(nodes, parent, opts = {}) {
        opts.statement = true;
        return this.printJoin(nodes, parent, opts);
      }

      printList(items, parent, opts = {}) {
        if (opts.separator == null) {
          opts.separator = commaSeparator;
        }

        return this.printJoin(items, parent, opts);
      }

      _printNewline(leading, node, parent, opts) {
        if (this.format.retainLines || this.format.compact) return;

        if (this.format.concise) {
          this.space();
          return;
        }

        let lines = 0;

        if (this._buf.hasContent()) {
          if (!leading) lines++;
          if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
          const needs = leading
            ? n.needsWhitespaceBefore
            : n.needsWhitespaceAfter;
          if (needs(node, parent)) lines++;
        }

        this.newline(lines);
      }

      _getComments(leading, node) {
        return (
          (node && (leading ? node.leadingComments : node.trailingComments)) ||
          []
        );
      }

      _printComment(comment, skipNewLines) {
        if (!this.format.shouldPrintComment(comment.value)) return;
        if (comment.ignore) return;
        if (this._printedComments.has(comment)) return;

        this._printedComments.add(comment);

        if (comment.start != null) {
          if (this._printedCommentStarts[comment.start]) return;
          this._printedCommentStarts[comment.start] = true;
        }

        const isBlockComment = comment.type === 'CommentBlock';
        const printNewLines =
          isBlockComment && !skipNewLines && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent()) this.newline(1);
        if (!this.endsWith('[') && !this.endsWith('{')) this.space();
        let val =
          !isBlockComment && !this._noLineTerminator
            ? `//${comment.value}\n`
            : `/*${comment.value}*/`;

        if (isBlockComment && this.format.indent.adjustMultilineComment) {
          var _comment$loc;

          const offset =
            (_comment$loc = comment.loc) == null
              ? void 0
              : _comment$loc.start.column;

          if (offset) {
            const newlineRegex = new RegExp('\\n\\s{1,' + offset + '}', 'g');
            val = val.replace(newlineRegex, '\n');
          }

          const indentSize = Math.max(
            this._getIndent().length,
            this.format.retainLines ? 0 : this._buf.getCurrentColumn(),
          );
          val = val.replace(/\n(?!$)/g, `\n${' '.repeat(indentSize)}`);
        }

        if (this.endsWith('/')) this._space();
        this.withSource('start', comment.loc, () => {
          this._append(val);
        });
        if (printNewLines) this.newline(1);
      }

      _printComments(comments, inlinePureAnnotation) {
        if (!(comments != null && comments.length)) return;

        if (
          inlinePureAnnotation &&
          comments.length === 1 &&
          PURE_ANNOTATION_RE.test(comments[0].value)
        ) {
          this._printComment(
            comments[0],
            this._buf.hasContent() && !this.endsWith('\n'),
          );
        } else {
          for (const comment of comments) {
            this._printComment(comment);
          }
        }
      }

      printAssertions(node) {
        var _node$assertions;

        if (
          (_node$assertions = node.assertions) != null &&
          _node$assertions.length
        ) {
          this.space();
          this.word('assert');
          this.space();
          this.token('{');
          this.space();
          this.printList(node.assertions, node);
          this.space();
          this.token('}');
        }
      }
    }

    Object.assign(Printer.prototype, generatorFunctions);
    {
      Printer.prototype.Noop = function Noop() {};
    }
    var _default = Printer;
    exports.default = _default;

    function commaSeparator() {
      this.token(',');
      this.space();
    }
  });

  var lib$4 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = generate;
    exports.CodeGenerator = void 0;

    var _sourceMap = _interopRequireDefault(sourceMap_1);

    var _printer = _interopRequireDefault(printer);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    class Generator extends _printer.default {
      constructor(ast, opts = {}, code) {
        const format = normalizeOptions(code, opts);
        const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
        super(format, map);
        this.ast = void 0;
        this.ast = ast;
      }

      generate() {
        return super.generate(this.ast);
      }
    }

    function normalizeOptions(code, opts) {
      const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: '  ',
          base: 0,
        },
        decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
        jsescOption: Object.assign(
          {
            quotes: 'double',
            wrap: true,
            minimal: false,
          },
          opts.jsescOption,
        ),
        recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,
      };
      {
        format.jsonCompatibleStrings = opts.jsonCompatibleStrings;
      }

      if (format.minified) {
        format.compact = true;

        format.shouldPrintComment =
          format.shouldPrintComment || (() => format.comments);
      } else {
        format.shouldPrintComment =
          format.shouldPrintComment ||
          ((value) =>
            format.comments ||
            value.indexOf('@license') >= 0 ||
            value.indexOf('@preserve') >= 0);
      }

      if (format.compact === 'auto') {
        format.compact = code.length > 500000;

        if (format.compact) {
          console.error(
            '[BABEL] Note: The code generator has deoptimised the styling of ' +
              `${opts.filename} as it exceeds the max of ${'500KB'}.`,
          );
        }
      }

      if (format.compact) {
        format.indent.adjustMultilineComment = false;
      }

      return format;
    }

    class CodeGenerator {
      constructor(ast, opts, code) {
        this._generator = void 0;
        this._generator = new Generator(ast, opts, code);
      }

      generate() {
        return this._generator.generate();
      }
    }

    exports.CodeGenerator = CodeGenerator;

    function generate(ast, opts, code) {
      const gen = new Generator(ast, opts, code);
      return gen.generate();
    }
  });
  var generate = /*@__PURE__*/ getDefaultExportFromCjs(lib$4);

  var findParent_1 = findParent;
  var find_1 = find$1;
  var getFunctionParent_1 = getFunctionParent;
  var getStatementParent_1 = getStatementParent;
  var getEarliestCommonAncestorFrom_1 = getEarliestCommonAncestorFrom;
  var getDeepestCommonAncestorFrom_1 = getDeepestCommonAncestorFrom;
  var getAncestry_1 = getAncestry;
  var isAncestor_1 = isAncestor;
  var isDescendant_1 = isDescendant;
  var inType_1 = inType;

  var t$3 = _interopRequireWildcard$b(lib$2);

  _interopRequireDefault$u(path);

  function _interopRequireDefault$u(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function _getRequireWildcardCache$b() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$b = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$b(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$b();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function findParent(callback) {
    let path = this;

    while ((path = path.parentPath)) {
      if (callback(path)) return path;
    }

    return null;
  }

  function find$1(callback) {
    let path = this;

    do {
      if (callback(path)) return path;
    } while ((path = path.parentPath));

    return null;
  }

  function getFunctionParent() {
    return this.findParent((p) => p.isFunction());
  }

  function getStatementParent() {
    let path = this;

    do {
      if (
        !path.parentPath ||
        (Array.isArray(path.container) && path.isStatement())
      ) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);

    if (path && (path.isProgram() || path.isFile())) {
      throw new Error(
        "File/Program node, we can't possibly find a statement parent to this",
      );
    }

    return path;
  }

  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function (
      deepest,
      i,
      ancestries,
    ) {
      let earliest;
      const keys = t$3.VISITOR_KEYS[deepest.type];

      for (const ancestry of ancestries) {
        const path = ancestry[i + 1];

        if (!earliest) {
          earliest = path;
          continue;
        }

        if (path.listKey && earliest.listKey === path.listKey) {
          if (path.key < earliest.key) {
            earliest = path;
            continue;
          }
        }

        const earliestKeyIndex = keys.indexOf(earliest.parentKey);
        const currentKeyIndex = keys.indexOf(path.parentKey);

        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path;
        }
      }

      return earliest;
    });
  }

  function getDeepestCommonAncestorFrom(paths, filter) {
    if (!paths.length) {
      return this;
    }

    if (paths.length === 1) {
      return paths[0];
    }

    let minDepth = Infinity;
    let lastCommonIndex, lastCommon;
    const ancestries = paths.map((path) => {
      const ancestry = [];

      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== this);

      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }

      return ancestry;
    });
    const first = ancestries[0];

    depthLoop: for (let i = 0; i < minDepth; i++) {
      const shouldMatch = first[i];

      for (const ancestry of ancestries) {
        if (ancestry[i] !== shouldMatch) {
          break depthLoop;
        }
      }

      lastCommonIndex = i;
      lastCommon = shouldMatch;
    }

    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }

  function getAncestry() {
    let path = this;
    const paths = [];

    do {
      paths.push(path);
    } while ((path = path.parentPath));

    return paths;
  }

  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }

  function isDescendant(maybeAncestor) {
    return !!this.findParent((parent) => parent === maybeAncestor);
  }

  function inType(...candidateTypes) {
    let path = this;

    while (path) {
      for (const type of candidateTypes) {
        if (path.node.type === type) return true;
      }

      path = path.parentPath;
    }

    return false;
  }

  var ancestry_1 = /*#__PURE__*/ Object.defineProperty(
    {
      findParent: findParent_1,
      find: find_1,
      getFunctionParent: getFunctionParent_1,
      getStatementParent: getStatementParent_1,
      getEarliestCommonAncestorFrom: getEarliestCommonAncestorFrom_1,
      getDeepestCommonAncestorFrom: getDeepestCommonAncestorFrom_1,
      getAncestry: getAncestry_1,
      isAncestor: isAncestor_1,
      isDescendant: isDescendant_1,
      inType: inType_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var default_1 = _default$X;

  var t$4 = _interopRequireWildcard$c(lib$2);

  function _getRequireWildcardCache$c() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$c = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$c(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$c();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _default$X(node) {
    if (!this.isReferenced()) return;
    const binding = this.scope.getBinding(node.name);

    if (binding) {
      if (binding.identifier.typeAnnotation) {
        return binding.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(
          binding,
          this,
          node.name,
        );
      }
    }

    if (node.name === 'undefined') {
      return t$4.voidTypeAnnotation();
    } else if (node.name === 'NaN' || node.name === 'Infinity') {
      return t$4.numberTypeAnnotation();
    } else if (node.name === 'arguments');
  }

  function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    const types = [];
    const functionConstantViolations = [];
    let constantViolations = getConstantViolationsBefore(
      binding,
      path,
      functionConstantViolations,
    );
    const testType = getConditionalAnnotation(binding, path, name);

    if (testType) {
      const testConstantViolations = getConstantViolationsBefore(
        binding,
        testType.ifStatement,
      );
      constantViolations = constantViolations.filter(
        (path) => testConstantViolations.indexOf(path) < 0,
      );
      types.push(testType.typeAnnotation);
    }

    if (constantViolations.length) {
      constantViolations = constantViolations.concat(
        functionConstantViolations,
      );

      for (const violation of constantViolations) {
        types.push(violation.getTypeAnnotation());
      }
    }

    if (!types.length) {
      return;
    }

    if (t$4.isTSTypeAnnotation(types[0]) && t$4.createTSUnionType) {
      return t$4.createTSUnionType(types);
    }

    if (t$4.createFlowUnionType) {
      return t$4.createFlowUnionType(types);
    }

    return t$4.createUnionTypeAnnotation(types);
  }

  function getConstantViolationsBefore(binding, path, functions) {
    const violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter((violation) => {
      violation = violation.resolve();

      const status = violation._guessExecutionStatusRelativeTo(path);

      if (functions && status === 'unknown') functions.push(violation);
      return status === 'before';
    });
  }

  function inferAnnotationFromBinaryExpression(name, path) {
    const operator = path.node.operator;
    const right = path.get('right').resolve();
    const left = path.get('left').resolve();
    let target;

    if (
      left.isIdentifier({
        name,
      })
    ) {
      target = right;
    } else if (
      right.isIdentifier({
        name,
      })
    ) {
      target = left;
    }

    if (target) {
      if (operator === '===') {
        return target.getTypeAnnotation();
      }

      if (t$4.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t$4.numberTypeAnnotation();
      }

      return;
    }

    if (operator !== '===' && operator !== '==') return;
    let typeofPath;
    let typePath;

    if (
      left.isUnaryExpression({
        operator: 'typeof',
      })
    ) {
      typeofPath = left;
      typePath = right;
    } else if (
      right.isUnaryExpression({
        operator: 'typeof',
      })
    ) {
      typeofPath = right;
      typePath = left;
    }

    if (!typeofPath) return;
    if (
      !typeofPath.get('argument').isIdentifier({
        name,
      })
    )
      return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral()) return;
    const typeValue = typePath.node.value;
    if (typeof typeValue !== 'string') return;
    return t$4.createTypeAnnotationBasedOnTypeof(typeValue);
  }

  function getParentConditionalPath(binding, path, name) {
    let parentPath;

    while ((parentPath = path.parentPath)) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path.key === 'test') {
          return;
        }

        return parentPath;
      }

      if (parentPath.isFunction()) {
        if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
      }

      path = parentPath;
    }
  }

  function getConditionalAnnotation(binding, path, name) {
    const ifStatement = getParentConditionalPath(binding, path, name);
    if (!ifStatement) return;
    const test = ifStatement.get('test');
    const paths = [test];
    const types = [];

    for (let i = 0; i < paths.length; i++) {
      const path = paths[i];

      if (path.isLogicalExpression()) {
        if (path.node.operator === '&&') {
          paths.push(path.get('left'));
          paths.push(path.get('right'));
        }
      } else if (path.isBinaryExpression()) {
        const type = inferAnnotationFromBinaryExpression(name, path);
        if (type) types.push(type);
      }
    }

    if (types.length) {
      if (t$4.isTSTypeAnnotation(types[0]) && t$4.createTSUnionType) {
        return {
          typeAnnotation: t$4.createTSUnionType(types),
          ifStatement,
        };
      }

      if (t$4.createFlowUnionType) {
        return {
          typeAnnotation: t$4.createFlowUnionType(types),
          ifStatement,
        };
      }

      return {
        typeAnnotation: t$4.createUnionTypeAnnotation(types),
        ifStatement,
      };
    }

    return getConditionalAnnotation(ifStatement, name);
  }

  var infererReference = /*#__PURE__*/ Object.defineProperty(
    {
      default: default_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var inferers = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.VariableDeclarator = VariableDeclarator;
    exports.TypeCastExpression = TypeCastExpression;
    exports.NewExpression = NewExpression;
    exports.TemplateLiteral = TemplateLiteral;
    exports.UnaryExpression = UnaryExpression;
    exports.BinaryExpression = BinaryExpression;
    exports.LogicalExpression = LogicalExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.SequenceExpression = SequenceExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.AssignmentExpression = AssignmentExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.StringLiteral = StringLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.BooleanLiteral = BooleanLiteral;
    exports.NullLiteral = NullLiteral;
    exports.RegExpLiteral = RegExpLiteral;
    exports.ObjectExpression = ObjectExpression;
    exports.ArrayExpression = ArrayExpression;
    exports.RestElement = RestElement;
    exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
    exports.CallExpression = CallExpression;
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    Object.defineProperty(exports, 'Identifier', {
      enumerable: true,
      get: function () {
        return _infererReference.default;
      },
    });

    var t = _interopRequireWildcard(lib$2);

    var _infererReference = _interopRequireDefault(infererReference);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function VariableDeclarator() {
      var _type;

      const id = this.get('id');
      if (!id.isIdentifier()) return;
      const init = this.get('init');
      let type = init.getTypeAnnotation();

      if (
        ((_type = type) == null ? void 0 : _type.type) === 'AnyTypeAnnotation'
      ) {
        if (
          init.isCallExpression() &&
          init.get('callee').isIdentifier({
            name: 'Array',
          }) &&
          !init.scope.hasBinding('Array', true)
        ) {
          type = ArrayExpression();
        }
      }

      return type;
    }

    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }

    TypeCastExpression.validParent = true;

    function NewExpression(node) {
      if (this.get('callee').isIdentifier()) {
        return t.genericTypeAnnotation(node.callee);
      }
    }

    function TemplateLiteral() {
      return t.stringTypeAnnotation();
    }

    function UnaryExpression(node) {
      const operator = node.operator;

      if (operator === 'void') {
        return t.voidTypeAnnotation();
      } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t.numberTypeAnnotation();
      } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t.stringTypeAnnotation();
      } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t.booleanTypeAnnotation();
      }
    }

    function BinaryExpression(node) {
      const operator = node.operator;

      if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t.numberTypeAnnotation();
      } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t.booleanTypeAnnotation();
      } else if (operator === '+') {
        const right = this.get('right');
        const left = this.get('left');

        if (left.isBaseType('number') && right.isBaseType('number')) {
          return t.numberTypeAnnotation();
        } else if (left.isBaseType('string') || right.isBaseType('string')) {
          return t.stringTypeAnnotation();
        }

        return t.unionTypeAnnotation([
          t.stringTypeAnnotation(),
          t.numberTypeAnnotation(),
        ]);
      }
    }

    function LogicalExpression() {
      const argumentTypes = [
        this.get('left').getTypeAnnotation(),
        this.get('right').getTypeAnnotation(),
      ];

      if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {
        return t.createTSUnionType(argumentTypes);
      }

      if (t.createFlowUnionType) {
        return t.createFlowUnionType(argumentTypes);
      }

      return t.createUnionTypeAnnotation(argumentTypes);
    }

    function ConditionalExpression() {
      const argumentTypes = [
        this.get('consequent').getTypeAnnotation(),
        this.get('alternate').getTypeAnnotation(),
      ];

      if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {
        return t.createTSUnionType(argumentTypes);
      }

      if (t.createFlowUnionType) {
        return t.createFlowUnionType(argumentTypes);
      }

      return t.createUnionTypeAnnotation(argumentTypes);
    }

    function SequenceExpression() {
      return this.get('expressions').pop().getTypeAnnotation();
    }

    function ParenthesizedExpression() {
      return this.get('expression').getTypeAnnotation();
    }

    function AssignmentExpression() {
      return this.get('right').getTypeAnnotation();
    }

    function UpdateExpression(node) {
      const operator = node.operator;

      if (operator === '++' || operator === '--') {
        return t.numberTypeAnnotation();
      }
    }

    function StringLiteral() {
      return t.stringTypeAnnotation();
    }

    function NumericLiteral() {
      return t.numberTypeAnnotation();
    }

    function BooleanLiteral() {
      return t.booleanTypeAnnotation();
    }

    function NullLiteral() {
      return t.nullLiteralTypeAnnotation();
    }

    function RegExpLiteral() {
      return t.genericTypeAnnotation(t.identifier('RegExp'));
    }

    function ObjectExpression() {
      return t.genericTypeAnnotation(t.identifier('Object'));
    }

    function ArrayExpression() {
      return t.genericTypeAnnotation(t.identifier('Array'));
    }

    function RestElement() {
      return ArrayExpression();
    }

    RestElement.validParent = true;

    function Func() {
      return t.genericTypeAnnotation(t.identifier('Function'));
    }

    const isArrayFrom = t.buildMatchMemberExpression('Array.from');
    const isObjectKeys = t.buildMatchMemberExpression('Object.keys');
    const isObjectValues = t.buildMatchMemberExpression('Object.values');
    const isObjectEntries = t.buildMatchMemberExpression('Object.entries');

    function CallExpression() {
      const {callee} = this.node;

      if (isObjectKeys(callee)) {
        return t.arrayTypeAnnotation(t.stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee)) {
        return t.arrayTypeAnnotation(t.anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return t.arrayTypeAnnotation(
          t.tupleTypeAnnotation([
            t.stringTypeAnnotation(),
            t.anyTypeAnnotation(),
          ]),
        );
      }

      return resolveCall(this.get('callee'));
    }

    function TaggedTemplateExpression() {
      return resolveCall(this.get('tag'));
    }

    function resolveCall(callee) {
      callee = callee.resolve();

      if (callee.isFunction()) {
        if (callee.is('async')) {
          if (callee.is('generator')) {
            return t.genericTypeAnnotation(t.identifier('AsyncIterator'));
          } else {
            return t.genericTypeAnnotation(t.identifier('Promise'));
          }
        } else {
          if (callee.node.returnType) {
            return callee.node.returnType;
          }
        }
      }
    }
  });

  var getTypeAnnotation_1 = getTypeAnnotation;
  var _getTypeAnnotation_1 = _getTypeAnnotation;
  var isBaseType_1 = isBaseType;
  var couldBeBaseType_1 = couldBeBaseType;
  var baseTypeStrictlyMatches_1 = baseTypeStrictlyMatches;
  var isGenericType_1 = isGenericType;

  var inferers$1 = _interopRequireWildcard$d(inferers);

  var t$5 = _interopRequireWildcard$d(lib$2);

  function _getRequireWildcardCache$d() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$d = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$d(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$d();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function getTypeAnnotation() {
    if (this.typeAnnotation) return this.typeAnnotation;
    let type = this._getTypeAnnotation() || t$5.anyTypeAnnotation();
    if (t$5.isTypeAnnotation(type)) type = type.typeAnnotation;
    return (this.typeAnnotation = type);
  }

  const typeAnnotationInferringNodes = new WeakSet();

  function _getTypeAnnotation() {
    const node = this.node;

    if (!node) {
      if (this.key === 'init' && this.parentPath.isVariableDeclarator()) {
        const declar = this.parentPath.parentPath;
        const declarParent = declar.parentPath;

        if (declar.key === 'left' && declarParent.isForInStatement()) {
          return t$5.stringTypeAnnotation();
        }

        if (declar.key === 'left' && declarParent.isForOfStatement()) {
          return t$5.anyTypeAnnotation();
        }

        return t$5.voidTypeAnnotation();
      } else {
        return;
      }
    }

    if (node.typeAnnotation) {
      return node.typeAnnotation;
    }

    if (typeAnnotationInferringNodes.has(node)) {
      return;
    }

    typeAnnotationInferringNodes.add(node);

    try {
      var _inferer;

      let inferer = inferers$1[node.type];

      if (inferer) {
        return inferer.call(this, node);
      }

      inferer = inferers$1[this.parentPath.type];

      if ((_inferer = inferer) != null && _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes.delete(node);
    }
  }

  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }

  function _isBaseType(baseName, type, soft) {
    if (baseName === 'string') {
      return t$5.isStringTypeAnnotation(type);
    } else if (baseName === 'number') {
      return t$5.isNumberTypeAnnotation(type);
    } else if (baseName === 'boolean') {
      return t$5.isBooleanTypeAnnotation(type);
    } else if (baseName === 'any') {
      return t$5.isAnyTypeAnnotation(type);
    } else if (baseName === 'mixed') {
      return t$5.isMixedTypeAnnotation(type);
    } else if (baseName === 'empty') {
      return t$5.isEmptyTypeAnnotation(type);
    } else if (baseName === 'void') {
      return t$5.isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error(`Unknown base type ${baseName}`);
      }
    }
  }

  function couldBeBaseType(name) {
    const type = this.getTypeAnnotation();
    if (t$5.isAnyTypeAnnotation(type)) return true;

    if (t$5.isUnionTypeAnnotation(type)) {
      for (const type2 of type.types) {
        if (t$5.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }

      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }

  function baseTypeStrictlyMatches(rightArg) {
    const left = this.getTypeAnnotation();
    const right = rightArg.getTypeAnnotation();

    if (!t$5.isAnyTypeAnnotation(left) && t$5.isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }

    return false;
  }

  function isGenericType(genericName) {
    const type = this.getTypeAnnotation();
    return (
      t$5.isGenericTypeAnnotation(type) &&
      t$5.isIdentifier(type.id, {
        name: genericName,
      })
    );
  }

  var inference = /*#__PURE__*/ Object.defineProperty(
    {
      getTypeAnnotation: getTypeAnnotation_1,
      _getTypeAnnotation: _getTypeAnnotation_1,
      isBaseType: isBaseType_1,
      couldBeBaseType: couldBeBaseType_1,
      baseTypeStrictlyMatches: baseTypeStrictlyMatches_1,
      isGenericType: isGenericType_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  // Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
  // License: MIT. (See LICENSE.)
  // This regex comes from regex.coffee, and is inserted here by generate-index.js
  // (run `npm run build`).
  var _default$Y = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

  var matchToToken = function (match) {
    var token = {
      type: 'invalid',
      value: match[0],
      closed: undefined,
    };
    if (match[1])
      (token.type = 'string'), (token.closed = !!(match[3] || match[4]));
    else if (match[5]) token.type = 'comment';
    else if (match[6]) (token.type = 'comment'), (token.closed = !!match[7]);
    else if (match[8]) token.type = 'regex';
    else if (match[9]) token.type = 'number';
    else if (match[10]) token.type = 'name';
    else if (match[11]) token.type = 'punctuator';
    else if (match[12]) token.type = 'whitespace';
    return token;
  };

  var jsTokens = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$Y,
      matchToToken: matchToToken,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  var escapeStringRegexp = function (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    return str.replace(matchOperatorsRe, '\\$&');
  };

  var colorName = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  };

  /* MIT license */
  var conversions = createCommonjsModule(function (module) {
    // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)
    var reverseKeywords = {};

    for (var key in colorName) {
      if (colorName.hasOwnProperty(key)) {
        reverseKeywords[colorName[key]] = key;
      }
    }

    var convert = (module.exports = {
      rgb: {
        channels: 3,
        labels: 'rgb',
      },
      hsl: {
        channels: 3,
        labels: 'hsl',
      },
      hsv: {
        channels: 3,
        labels: 'hsv',
      },
      hwb: {
        channels: 3,
        labels: 'hwb',
      },
      cmyk: {
        channels: 4,
        labels: 'cmyk',
      },
      xyz: {
        channels: 3,
        labels: 'xyz',
      },
      lab: {
        channels: 3,
        labels: 'lab',
      },
      lch: {
        channels: 3,
        labels: 'lch',
      },
      hex: {
        channels: 1,
        labels: ['hex'],
      },
      keyword: {
        channels: 1,
        labels: ['keyword'],
      },
      ansi16: {
        channels: 1,
        labels: ['ansi16'],
      },
      ansi256: {
        channels: 1,
        labels: ['ansi256'],
      },
      hcg: {
        channels: 3,
        labels: ['h', 'c', 'g'],
      },
      apple: {
        channels: 3,
        labels: ['r16', 'g16', 'b16'],
      },
      gray: {
        channels: 1,
        labels: ['gray'],
      },
    }); // hide .channels and .labels properties

    for (var model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!('channels' in convert[model])) {
          throw new Error('missing channels property: ' + model);
        }

        if (!('labels' in convert[model])) {
          throw new Error('missing channel labels property: ' + model);
        }

        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error('channel and label counts mismatch: ' + model);
        }

        var channels = convert[model].channels;
        var labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], 'channels', {
          value: channels,
        });
        Object.defineProperty(convert[model], 'labels', {
          value: labels,
        });
      }
    }

    convert.rgb.hsl = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    };

    convert.rgb.hsv = function (rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);

      var diffc = function (c) {
        return (v - c) / 6 / diff + 1 / 2;
      };

      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);

        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }

        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }

      return [h * 360, s * 100, v * 100];
    };

    convert.rgb.hwb = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = (1 / 255) * Math.min(r, Math.min(g, b));
      b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };

    convert.rgb.cmyk = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    /**
     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
     * */

    function comparativeDistance(x, y) {
      return (
        Math.pow(x[0] - y[0], 2) +
        Math.pow(x[1] - y[1], 2) +
        Math.pow(x[2] - y[2], 2)
      );
    }

    convert.rgb.keyword = function (rgb) {
      var reversed = reverseKeywords[rgb];

      if (reversed) {
        return reversed;
      }

      var currentClosestDistance = Infinity;
      var currentClosestKeyword;

      for (var keyword in colorName) {
        if (colorName.hasOwnProperty(keyword)) {
          var value = colorName[keyword]; // Compute comparative distance

          var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }

      return currentClosestKeyword;
    };

    convert.keyword.rgb = function (keyword) {
      return colorName[keyword];
    };

    convert.rgb.xyz = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };

    convert.rgb.lab = function (rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.hsl.rgb = function (hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;

      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + (1 / 3) * -(i - 1);

        if (t3 < 0) {
          t3++;
        }

        if (t3 > 1) {
          t3--;
        }

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    };

    convert.hsl.hsv = function (hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
      return [h, sv * 100, v * 100];
    };

    convert.hsv.rgb = function (hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    };

    convert.hsv.hsl = function (hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb

    convert.hwb.rgb = function (hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) !== 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      var r;
      var g;
      var b;

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    };

    convert.cmyk.rgb = function (cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.rgb = function (xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.lab = function (xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.lab.xyz = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };

    convert.lab.lch = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = (hr * 360) / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };

    convert.lch.lab = function (lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = (h / 360) * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };

    convert.rgb.ansi16 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

      value = Math.round(value / 50);

      if (value === 0) {
        return 30;
      }

      var ansi =
        30 +
        ((Math.round(b / 255) << 2) |
          (Math.round(g / 255) << 1) |
          Math.round(r / 255));

      if (value === 2) {
        ansi += 60;
      }

      return ansi;
    };

    convert.hsv.ansi16 = function (args) {
      // optimization here; we already know the value and don't need to get
      // it converted for us.
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };

    convert.rgb.ansi256 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2]; // we use the extended greyscale palette here, with the exception of
      // black and white. normal palette only has 4 greyscale shades.

      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }

        if (r > 248) {
          return 231;
        }

        return Math.round(((r - 8) / 247) * 24) + 232;
      }

      var ansi =
        16 +
        36 * Math.round((r / 255) * 5) +
        6 * Math.round((g / 255) * 5) +
        Math.round((b / 255) * 5);
      return ansi;
    };

    convert.ansi16.rgb = function (args) {
      var color = args % 10; // handle greyscale

      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }

        color = (color / 10.5) * 255;
        return [color, color, color];
      }

      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = ((color >> 1) & 1) * mult * 255;
      var b = ((color >> 2) & 1) * mult * 255;
      return [r, g, b];
    };

    convert.ansi256.rgb = function (args) {
      // handle greyscale
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }

      args -= 16;
      var rem;
      var r = (Math.floor(args / 36) / 5) * 255;
      var g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
      var b = ((rem % 6) / 5) * 255;
      return [r, g, b];
    };

    convert.rgb.hex = function (args) {
      var integer =
        ((Math.round(args[0]) & 0xff) << 16) +
        ((Math.round(args[1]) & 0xff) << 8) +
        (Math.round(args[2]) & 0xff);
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.hex.rgb = function (args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

      if (!match) {
        return [0, 0, 0];
      }

      var colorString = match[0];

      if (match[0].length === 3) {
        colorString = colorString
          .split('')
          .map(function (char) {
            return char + char;
          })
          .join('');
      }

      var integer = parseInt(colorString, 16);
      var r = (integer >> 16) & 0xff;
      var g = (integer >> 8) & 0xff;
      var b = integer & 0xff;
      return [r, g, b];
    };

    convert.rgb.hcg = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;

      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }

      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = ((g - b) / chroma) % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }

      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };

    convert.hsl.hcg = function (hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;

      if (l < 0.5) {
        c = 2.0 * s * l;
      } else {
        c = 2.0 * s * (1.0 - l);
      }

      if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
      }

      return [hsl[0], c * 100, f * 100];
    };

    convert.hsv.hcg = function (hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;

      if (c < 1.0) {
        f = (v - c) / (1 - c);
      }

      return [hsv[0], c * 100, f * 100];
    };

    convert.hcg.rgb = function (hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;

      if (c === 0.0) {
        return [g * 255, g * 255, g * 255];
      }

      var pure = [0, 0, 0];
      var hi = (h % 1) * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;

      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;

        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;

        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;

        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;

        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;

        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }

      mg = (1.0 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255,
      ];
    };

    convert.hcg.hsv = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      var f = 0;

      if (v > 0.0) {
        f = c / v;
      }

      return [hcg[0], f * 100, v * 100];
    };

    convert.hcg.hsl = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1.0 - c) + 0.5 * c;
      var s = 0;

      if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
      }

      return [hcg[0], s * 100, l * 100];
    };

    convert.hcg.hwb = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };

    convert.hwb.hcg = function (hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;

      if (c < 1) {
        g = (v - c) / (1 - c);
      }

      return [hwb[0], c * 100, g * 100];
    };

    convert.apple.rgb = function (apple) {
      return [
        (apple[0] / 65535) * 255,
        (apple[1] / 65535) * 255,
        (apple[2] / 65535) * 255,
      ];
    };

    convert.rgb.apple = function (rgb) {
      return [
        (rgb[0] / 255) * 65535,
        (rgb[1] / 255) * 65535,
        (rgb[2] / 255) * 65535,
      ];
    };

    convert.gray.rgb = function (args) {
      return [
        (args[0] / 100) * 255,
        (args[0] / 100) * 255,
        (args[0] / 100) * 255,
      ];
    };

    convert.gray.hsl = convert.gray.hsv = function (args) {
      return [0, 0, args[0]];
    };

    convert.gray.hwb = function (gray) {
      return [0, 100, gray[0]];
    };

    convert.gray.cmyk = function (gray) {
      return [0, 0, 0, gray[0]];
    };

    convert.gray.lab = function (gray) {
      return [gray[0], 0, 0];
    };

    convert.gray.hex = function (gray) {
      var val = Math.round((gray[0] / 100) * 255) & 0xff;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.rgb.gray = function (rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [(val / 255) * 100];
    };
  });

  /*
  	this function routes a model to all other models.

  	all functions that are routed have a property `.conversion` attached
  	to the returned synthetic function. This property is an array
  	of strings, each with the steps in between the 'from' and 'to'
  	color models (inclusive).

  	conversions that are not possible simply are not included.
  */

  function buildGraph() {
    var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

    var models = Object.keys(conversions);

    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null,
      };
    }

    return graph;
  } // https://en.wikipedia.org/wiki/Breadth-first_search

  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel]; // unshift -> queue -> pop

    graph[fromModel].distance = 0;

    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);

      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  var route = function (fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);

    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];

      if (node.parent === null) {
        // no possible conversion, or this node is the source model.
        continue;
      }

      conversion[toModel] = wrapConversion(toModel, graph);
    }

    return conversion;
  };

  var convert = {};
  var models = Object.keys(conversions);

  function wrapRaw(fn) {
    var wrappedFn = function (args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      return fn(args);
    }; // preserve .conversion property if there is one

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded(fn) {
    var wrappedFn = function (args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      var result = fn(args); // we're assuming the result is an array here.
      // see notice in conversions.js; don't use box types
      // in conversion functions.

      if (typeof result === 'object') {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    }; // preserve .conversion property if there is one

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models.forEach(function (fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels,
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: conversions[fromModel].labels,
    });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function (toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert;

  var ansiStyles = createCommonjsModule(function (module) {
    const wrapAnsi16 = (fn, offset) =>
      function () {
        const code = fn.apply(colorConvert, arguments);
        return `\u001B[${code + offset}m`;
      };

    const wrapAnsi256 = (fn, offset) =>
      function () {
        const code = fn.apply(colorConvert, arguments);
        return `\u001B[${38 + offset};5;${code}m`;
      };

    const wrapAnsi16m = (fn, offset) =>
      function () {
        const rgb = fn.apply(colorConvert, arguments);
        return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };

    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29],
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39],
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49],
        },
      }; // Fix humans

      styles.color.grey = styles.color.gray;

      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];

        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\u001B[${style[0]}m`,
            close: `\u001B[${style[1]}m`,
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }

        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false,
        });
        Object.defineProperty(styles, 'codes', {
          value: codes,
          enumerable: false,
        });
      }

      const ansi2ansi = (n) => n;

      const rgb2rgb = (r, g, b) => [r, g, b];

      styles.color.close = '\u001B[39m';
      styles.bgColor.close = '\u001B[49m';
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0),
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0),
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0),
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10),
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10),
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10),
      };

      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== 'object') {
          continue;
        }

        const suite = colorConvert[key];

        if (key === 'ansi16') {
          key = 'ansi';
        }

        if ('ansi16' in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }

        if ('ansi256' in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }

        if ('rgb' in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }

      return styles;
    } // Make the export immutable

    Object.defineProperty(module, 'exports', {
      enumerable: true,
      get: assembleStyles,
    });
  });

  /*
  The MIT License (MIT)

  Copyright (c) 2016 CoderPuppy

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  */
  var _endianness;

  function endianness() {
    if (typeof _endianness === 'undefined') {
      var a = new ArrayBuffer(2);
      var b = new Uint8Array(a);
      var c = new Uint16Array(a);
      b[0] = 1;
      b[1] = 2;

      if (c[0] === 258) {
        _endianness = 'BE';
      } else if (c[0] === 513) {
        _endianness = 'LE';
      } else {
        throw new Error('unable to figure out endianess');
      }
    }

    return _endianness;
  }
  function hostname() {
    if (typeof global$1.location !== 'undefined') {
      return global$1.location.hostname;
    } else return '';
  }
  function loadavg() {
    return [];
  }
  function uptime$1() {
    return 0;
  }
  function freemem() {
    return Number.MAX_VALUE;
  }
  function totalmem() {
    return Number.MAX_VALUE;
  }
  function cpus() {
    return [];
  }
  function type() {
    return 'Browser';
  }
  function release$1() {
    if (typeof global$1.navigator !== 'undefined') {
      return global$1.navigator.appVersion;
    }

    return '';
  }
  function networkInterfaces() {}
  function getNetworkInterfaces() {}
  function arch() {
    return 'javascript';
  }
  function platform$1() {
    return 'browser';
  }
  function tmpDir() {
    return '/tmp';
  }
  var tmpdir = tmpDir;
  var EOL = '\n';
  var os = {
    EOL: EOL,
    tmpdir: tmpdir,
    tmpDir: tmpDir,
    networkInterfaces: networkInterfaces,
    getNetworkInterfaces: getNetworkInterfaces,
    release: release$1,
    type: type,
    cpus: cpus,
    totalmem: totalmem,
    freemem: freemem,
    uptime: uptime$1,
    loadavg: loadavg,
    hostname: hostname,
    endianness: endianness,
  };

  var os$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    endianness: endianness,
    hostname: hostname,
    loadavg: loadavg,
    uptime: uptime$1,
    freemem: freemem,
    totalmem: totalmem,
    cpus: cpus,
    type: type,
    release: release$1,
    networkInterfaces: networkInterfaces,
    getNetworkInterfaces: getNetworkInterfaces,
    arch: arch,
    platform: platform$1,
    tmpDir: tmpDir,
    tmpdir: tmpdir,
    EOL: EOL,
    default: os,
  });

  var hasFlag = (flag, argv) => {
    argv = argv || browser$1.argv;
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf('--');
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };

  var os$2 = /*@__PURE__*/ getAugmentedNamespace(os$1);

  const env$1 = browser$1.env;
  let forceColor;

  if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
    forceColor = false;
  } else if (
    hasFlag('color') ||
    hasFlag('colors') ||
    hasFlag('color=true') ||
    hasFlag('color=always')
  ) {
    forceColor = true;
  }

  if ('FORCE_COLOR' in env$1) {
    forceColor =
      env$1.FORCE_COLOR.length === 0 || parseInt(env$1.FORCE_COLOR, 10) !== 0;
  }

  function translateLevel(level) {
    if (level === 0) {
      return false;
    }

    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3,
    };
  }

  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }

    if (
      hasFlag('color=16m') ||
      hasFlag('color=full') ||
      hasFlag('color=truecolor')
    ) {
      return 3;
    }

    if (hasFlag('color=256')) {
      return 2;
    }

    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }

    const min = forceColor ? 1 : 0;

    if (browser$1.platform === 'win32') {
      // Node.js 7.5.0 is the first version of Node.js to include a patch to
      // libuv that enables 256 color output on Windows. Anything earlier and it
      // won't work. However, here we target Node.js 8 at minimum as it is an LTS
      // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
      // release that supports 256 colors. Windows 10 build 14931 is the first release
      // that supports 16m/TrueColor.
      const osRelease = os$2.release().split('.');

      if (
        Number(browser$1.versions.node.split('.')[0]) >= 8 &&
        Number(osRelease[0]) >= 10 &&
        Number(osRelease[2]) >= 10586
      ) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }

      return 1;
    }

    if ('CI' in env$1) {
      if (
        ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(
          (sign) => sign in env$1,
        ) ||
        env$1.CI_NAME === 'codeship'
      ) {
        return 1;
      }

      return min;
    }

    if ('TEAMCITY_VERSION' in env$1) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION)
        ? 1
        : 0;
    }

    if (env$1.COLORTERM === 'truecolor') {
      return 3;
    }

    if ('TERM_PROGRAM' in env$1) {
      const version = parseInt(
        (env$1.TERM_PROGRAM_VERSION || '').split('.')[0],
        10,
      );

      switch (env$1.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;

        case 'Apple_Terminal':
          return 2;
        // No default
      }
    }

    if (/-256(color)?$/i.test(env$1.TERM)) {
      return 2;
    }

    if (
      /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
        env$1.TERM,
      )
    ) {
      return 1;
    }

    if ('COLORTERM' in env$1) {
      return 1;
    }

    if (env$1.TERM === 'dumb') {
      return min;
    }

    return min;
  }

  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }

  var supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(browser$1.stdout),
    stderr: getSupportLevel(browser$1.stderr),
  };

  const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = new Map([
    ['n', '\n'],
    ['r', '\r'],
    ['t', '\t'],
    ['b', '\b'],
    ['f', '\f'],
    ['v', '\v'],
    ['0', '\0'],
    ['\\', '\\'],
    ['e', '\u001B'],
    ['a', '\u0007'],
  ]);

  function unescape(c) {
    if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }

    return ESCAPES.get(c) || c;
  }

  function parseArguments(name, args) {
    const results = [];
    const chunks = args.trim().split(/\s*,\s*/g);
    let matches;

    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if ((matches = chunk.match(STRING_REGEX))) {
        results.push(
          matches[2].replace(ESCAPE_REGEX, (m, escape, chr) =>
            escape ? unescape(escape) : chr,
          ),
        );
      } else {
        throw new Error(
          `Invalid Chalk template style argument: ${chunk} (in style '${name}')`,
        );
      }
    }

    return results;
  }

  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;

    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];

      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }

    return results;
  }

  function buildStyle(chalk, styles) {
    const enabled = {};

    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }

    let current = chalk;

    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }

        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }

    return current;
  }

  var templates = (chalk, tmp) => {
    const styles = [];
    const chunks = [];
    let chunk = []; // eslint-disable-next-line max-params

    tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
      if (escapeChar) {
        chunk.push(unescape(escapeChar));
      } else if (style) {
        const str = chunk.join('');
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({
          inverse,
          styles: parseStyle(style),
        });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error('Found extraneous } in Chalk template literal');
        }

        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(''));

    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${
        styles.length
      } closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
      throw new Error(errMsg);
    }

    return chunks.join('');
  };

  var chalk = createCommonjsModule(function (module) {
    const stdoutColor = supportsColor_1.stdout;
    const isSimpleWindowsTerm =
      browser$1.platform === 'win32' &&
      !(browser$1.env.TERM || '').toLowerCase().startsWith('xterm'); // `supportsColor.level` → `ansiStyles.color[name]` mapping

    const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']; // `color-convert` models to exclude from the Chalk API due to conflicts and such

    const skipModels = new Set(['gray']);
    const styles = Object.create(null);

    function applyOptions(obj, options) {
      options = options || {}; // Detect level if not set manually

      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === undefined ? scLevel : options.level;
      obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
    }

    function Chalk(options) {
      // We check for this.template here since calling `chalk.constructor()`
      // by itself will have a `this` of a previously constructed chalk object
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);

        chalk.template = function () {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };

        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }

      applyOptions(this, options);
    } // Use bright blue on Windows as the normal blue color is illegible

    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = '\u001B[94m';
    }

    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(
        escapeStringRegexp(ansiStyles[key].close),
        'g',
      );
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(
            this,
            this._styles ? this._styles.concat(codes) : [codes],
            this._empty,
            key,
          );
        },
      };
    }

    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, 'visible');
      },
    };
    ansiStyles.color.closeRe = new RegExp(
      escapeStringRegexp(ansiStyles.color.close),
      'g',
    );

    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }

      styles[model] = {
        get() {
          const level = this.level;
          return function () {
            const open = ansiStyles.color[levelMapping[level]][model].apply(
              null,
              arguments,
            );
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe,
            };
            return build.call(
              this,
              this._styles ? this._styles.concat(codes) : [codes],
              this._empty,
              model,
            );
          };
        },
      };
    }

    ansiStyles.bgColor.closeRe = new RegExp(
      escapeStringRegexp(ansiStyles.bgColor.close),
      'g',
    );

    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }

      const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function () {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(
              null,
              arguments,
            );
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe,
            };
            return build.call(
              this,
              this._styles ? this._styles.concat(codes) : [codes],
              this._empty,
              model,
            );
          };
        },
      };
    }

    const proto = Object.defineProperties(() => {}, styles);

    function build(_styles, _empty, key) {
      const builder = function () {
        return applyStyle.apply(builder, arguments);
      };

      builder._styles = _styles;
      builder._empty = _empty;
      const self = this;
      Object.defineProperty(builder, 'level', {
        enumerable: true,

        get() {
          return self.level;
        },

        set(level) {
          self.level = level;
        },
      });
      Object.defineProperty(builder, 'enabled', {
        enumerable: true,

        get() {
          return self.enabled;
        },

        set(enabled) {
          self.enabled = enabled;
        },
      }); // See below for fix regarding invisible grey/dim combination on Windows

      builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'; // `__proto__` is used because we must return a function, but there is
      // no way to create a function with a different prototype

      builder.__proto__ = proto; // eslint-disable-line no-proto

      return builder;
    }

    function applyStyle() {
      // Support varags, but simply cast to string in case there's only one arg
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);

      if (argsLen === 0) {
        return '';
      }

      if (argsLen > 1) {
        // Don't slice `arguments`, it prevents V8 optimizations
        for (let a = 1; a < argsLen; a++) {
          str += ' ' + args[a];
        }
      }

      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? '' : str;
      } // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
      // see https://github.com/chalk/chalk/issues/58
      // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.

      const originalDim = ansiStyles.dim.open;

      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = '';
      }

      for (const code of this._styles.slice().reverse()) {
        // Replace any instances already present with a re-opening code
        // otherwise only the part of the string until said closing code
        // will be colored, and the rest will simply be 'plain'.
        str = code.open + str.replace(code.closeRe, code.open) + code.close; // Close the styling before a linebreak and reopen
        // after next line to fix a bleed issue on macOS
        // https://github.com/chalk/chalk/pull/92

        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      } // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue

      ansiStyles.dim.open = originalDim;
      return str;
    }

    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        // If chalk() was called by itself or with a string,
        // return the string itself as a string.
        return [].slice.call(arguments, 1).join(' ');
      }

      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];

      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
        parts.push(String(strings.raw[i]));
      }

      return templates(chalk, parts.join(''));
    }

    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk(); // eslint-disable-line new-cap

    module.exports.supportsColor = stdoutColor;
    module.exports.default = module.exports; // For TypeScript
  });

  var shouldHighlight_1 = shouldHighlight;
  var getChalk_1 = getChalk;
  var _default$Z = highlight;
  const sometimesKeywords = new Set([
    'as',
    'async',
    'from',
    'get',
    'of',
    'set',
  ]);

  function getDefs(chalk) {
    return {
      keyword: chalk.cyan,
      capitalized: chalk.yellow,
      jsxIdentifier: chalk.yellow,
      punctuator: chalk.yellow,
      number: chalk.magenta,
      string: chalk.green,
      regex: chalk.magenta,
      comment: chalk.grey,
      invalid: chalk.white.bgRed.bold,
    };
  }

  const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  const BRACKET = /^[()[\]{}]$/;
  let tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;

    const getTokenType = function (token, offset, text) {
      if (token.type === 'name') {
        if (
          (0, lib$1.isKeyword)(token.value) ||
          (0, lib$1.isStrictReservedWord)(token.value, true) ||
          sometimesKeywords.has(token.value)
        ) {
          return 'keyword';
        }

        if (
          JSX_TAG.test(token.value) &&
          (text[offset - 1] === '<' || text.substr(offset - 2, 2) == '</')
        ) {
          return 'jsxIdentifier';
        }

        if (token.value[0] !== token.value[0].toLowerCase()) {
          return 'capitalized';
        }
      }

      if (token.type === 'punctuator' && BRACKET.test(token.value)) {
        return 'bracket';
      }

      if (
        token.type === 'invalid' &&
        (token.value === '@' || token.value === '#')
      ) {
        return 'punctuator';
      }

      return token.type;
    };

    tokenize = function* (text) {
      let match;

      while ((match = jsTokens.default.exec(text))) {
        const token = jsTokens.matchToToken(match);
        yield {
          type: getTokenType(token, match.index, text),
          value: token.value,
        };
      }
    };
  }

  function highlightTokens(defs, text) {
    let highlighted = '';

    for (const {type, value} of tokenize(text)) {
      const colorize = defs[type];

      if (colorize) {
        highlighted += value
          .split(NEWLINE)
          .map((str) => colorize(str))
          .join('\n');
      } else {
        highlighted += value;
      }
    }

    return highlighted;
  }

  function shouldHighlight(options) {
    return !!chalk.supportsColor || options.forceColor;
  }

  function getChalk(options) {
    return options.forceColor
      ? new chalk.constructor({
          enabled: true,
          level: 1,
        })
      : chalk;
  }

  function highlight(code, options = {}) {
    if (shouldHighlight(options)) {
      const chalk = getChalk(options);
      const defs = getDefs(chalk);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }

  var lib$5 = /*#__PURE__*/ Object.defineProperty(
    {
      shouldHighlight: shouldHighlight_1,
      getChalk: getChalk_1,
      default: _default$Z,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var codeFrameColumns_1 = codeFrameColumns;
  var default_1$1 = _default$_;

  var _highlight = _interopRequireWildcard$e(lib$5);

  function _getRequireWildcardCache$e() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$e = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$e(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$e();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  let deprecationWarningShown = false;

  function getDefs$1(chalk) {
    return {
      gutter: chalk.grey,
      marker: chalk.red.bold,
      message: chalk.red.bold,
    };
  }

  const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;

  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign(
      {
        column: 0,
        line: -1,
      },
      loc.start,
    );
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {linesAbove = 2, linesBelow = 3} = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);

    if (startLine === -1) {
      start = 0;
    }

    if (endLine === -1) {
      end = source.length;
    }

    const lineDiff = endLine - startLine;
    const markerLines = {};

    if (lineDiff) {
      for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;

        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [
            startColumn,
            sourceLength - startColumn + 1,
          ];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }

    return {
      start,
      end,
      markerLines,
    };
  }

  function codeFrameColumns(rawLines, loc, opts = {}) {
    const highlighted =
      (opts.highlightCode || opts.forceColor) &&
      (0, _highlight.shouldHighlight)(opts);
    const chalk = (0, _highlight.getChalk)(opts);
    const defs = getDefs$1(chalk);

    const maybeHighlight = (chalkFn, string) => {
      return highlighted ? chalkFn(string) : string;
    };

    const lines = rawLines.split(NEWLINE$1);
    const {start, end, markerLines} = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === 'number';
    const numberMaxWidth = String(end).length;
    const highlightedLines = highlighted
      ? (0, _highlight.default)(rawLines, opts)
      : rawLines;
    let frame = highlightedLines
      .split(NEWLINE$1)
      .slice(start, end)
      .map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];

        if (hasMarker) {
          let markerLine = '';

          if (Array.isArray(hasMarker)) {
            const markerSpacing = line
              .slice(0, Math.max(hasMarker[0] - 1, 0))
              .replace(/[^\t]/g, ' ');
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = [
              '\n ',
              maybeHighlight(defs.gutter, gutter.replace(/\d/g, ' ')),
              ' ',
              markerSpacing,
              maybeHighlight(defs.marker, '^').repeat(numberOfMarkers),
            ].join('');

            if (lastMarkerLine && opts.message) {
              markerLine += ' ' + maybeHighlight(defs.message, opts.message);
            }
          }

          return [
            maybeHighlight(defs.marker, '>'),
            maybeHighlight(defs.gutter, gutter),
            line.length > 0 ? ` ${line}` : '',
            markerLine,
          ].join('');
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${
            line.length > 0 ? ` ${line}` : ''
          }`;
        }
      })
      .join('\n');

    if (opts.message && !hasColumns) {
      frame = `${' '.repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
    }

    if (highlighted) {
      return chalk.reset(frame);
    } else {
      return frame;
    }
  }

  function _default$_(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message =
        'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.';

      if (browser$1.emitWarning) {
        browser$1.emitWarning(message, 'DeprecationWarning');
      } else {
        const deprecationError = new Error(message);
        deprecationError.name = 'DeprecationWarning';
        console.warn(new Error(message));
      }
    }

    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber,
      },
    };
    return codeFrameColumns(rawLines, location, opts);
  }

  var lib$6 = /*#__PURE__*/ Object.defineProperty(
    {
      codeFrameColumns: codeFrameColumns_1,
      default: default_1$1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var replaceWithMultiple_1 = replaceWithMultiple;
  var replaceWithSourceString_1 = replaceWithSourceString;
  var replaceWith_1 = replaceWith;
  var _replaceWith_1 = _replaceWith;
  var replaceExpressionWithStatements_1 = replaceExpressionWithStatements;
  var replaceInline_1 = replaceInline;

  var _index = _interopRequireDefault$v(lib$a);

  var _index2 = _interopRequireDefault$v(path);

  var t$6 = _interopRequireWildcard$f(lib$2);

  function _getRequireWildcardCache$f() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$f = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$f(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$f();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _interopRequireDefault$v(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  const hoistVariablesVisitor = {
    Function(path) {
      path.skip();
    },

    VariableDeclaration(path) {
      if (path.node.kind !== 'var') return;
      const bindings = path.getBindingIdentifiers();

      for (const key of Object.keys(bindings)) {
        path.scope.push({
          id: bindings[key],
        });
      }

      const exprs = [];

      for (const declar of path.node.declarations) {
        if (declar.init) {
          exprs.push(
            t$6.expressionStatement(
              t$6.assignmentExpression('=', declar.id, declar.init),
            ),
          );
        }
      }

      path.replaceWithMultiple(exprs);
    },
  };

  function replaceWithMultiple(nodes) {
    var _pathCache$get;

    this.resync();
    nodes = this._verifyNodeList(nodes);
    t$6.inheritLeadingComments(nodes[0], this.node);
    t$6.inheritTrailingComments(nodes[nodes.length - 1], this.node);
    (_pathCache$get = cache.path.get(this.parent)) == null
      ? void 0
      : _pathCache$get.delete(this.node);
    this.node = this.container[this.key] = null;
    const paths = this.insertAfter(nodes);

    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }

    return paths;
  }

  function replaceWithSourceString(replacement) {
    this.resync();

    try {
      replacement = `(${replacement})`;
      replacement = (0, lib.parse)(replacement);
    } catch (err) {
      const loc = err.loc;

      if (loc) {
        err.message +=
          ' - make sure this is an expression.\n' +
          (0, lib$6.codeFrameColumns)(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1,
            },
          });
        err.code = 'BABEL_REPLACE_SOURCE_ERROR';
      }

      throw err;
    }

    replacement = replacement.program.body[0].expression;

    lib$a.default.removeProperties(replacement);

    return this.replaceWith(replacement);
  }

  function replaceWith(replacement) {
    this.resync();

    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }

    if (replacement instanceof path.default) {
      replacement = replacement.node;
    }

    if (!replacement) {
      throw new Error(
        'You passed `path.replaceWith()` a falsy node, use `path.remove()` instead',
      );
    }

    if (this.node === replacement) {
      return [this];
    }

    if (this.isProgram() && !t$6.isProgram(replacement)) {
      throw new Error(
        'You can only replace a Program root node with another Program node',
      );
    }

    if (Array.isArray(replacement)) {
      throw new Error(
        "Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`",
      );
    }

    if (typeof replacement === 'string') {
      throw new Error(
        "Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`",
      );
    }

    let nodePath = '';

    if (this.isNodeType('Statement') && t$6.isExpression(replacement)) {
      if (
        !this.canHaveVariableDeclarationOrExpression() &&
        !this.canSwapBetweenExpressionAndStatement(replacement) &&
        !this.parentPath.isExportDefaultDeclaration()
      ) {
        replacement = t$6.expressionStatement(replacement);
        nodePath = 'expression';
      }
    }

    if (this.isNodeType('Expression') && t$6.isStatement(replacement)) {
      if (
        !this.canHaveVariableDeclarationOrExpression() &&
        !this.canSwapBetweenExpressionAndStatement(replacement)
      ) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }

    const oldNode = this.node;

    if (oldNode) {
      t$6.inheritsComments(replacement, oldNode);
      t$6.removeComments(oldNode);
    }

    this._replaceWith(replacement);

    this.type = replacement.type;
    this.setScope();
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }

  function _replaceWith(node) {
    var _pathCache$get2;

    if (!this.container) {
      throw new ReferenceError('Container is falsy');
    }

    if (this.inList) {
      t$6.validate(this.parent, this.key, [node]);
    } else {
      t$6.validate(this.parent, this.key, node);
    }

    this.debug(`Replace with ${node == null ? void 0 : node.type}`);
    (_pathCache$get2 = cache.path.get(this.parent)) == null
      ? void 0
      : _pathCache$get2.set(node, this).delete(this.node);
    this.node = this.container[this.key] = node;
  }

  function replaceExpressionWithStatements(nodes) {
    this.resync();
    const toSequenceExpression = t$6.toSequenceExpression(nodes, this.scope);

    if (toSequenceExpression) {
      return this.replaceWith(toSequenceExpression)[0].get('expressions');
    }

    const functionParent = this.getFunctionParent();
    const isParentAsync =
      functionParent == null ? void 0 : functionParent.is('async');
    const isParentGenerator =
      functionParent == null ? void 0 : functionParent.is('generator');
    const container = t$6.arrowFunctionExpression(
      [],
      t$6.blockStatement(nodes),
    );
    this.replaceWith(t$6.callExpression(container, []));
    this.traverse(hoistVariablesVisitor);
    const completionRecords = this.get('callee').getCompletionRecords();

    for (const path of completionRecords) {
      if (!path.isExpressionStatement()) continue;
      const loop = path.findParent((path) => path.isLoop());

      if (loop) {
        let uid = loop.getData('expressionReplacementReturnUid');

        if (!uid) {
          const callee = this.get('callee');
          uid = callee.scope.generateDeclaredUidIdentifier('ret');
          callee
            .get('body')
            .pushContainer('body', t$6.returnStatement(t$6.cloneNode(uid)));
          loop.setData('expressionReplacementReturnUid', uid);
        } else {
          uid = t$6.identifier(uid.name);
        }

        path
          .get('expression')
          .replaceWith(
            t$6.assignmentExpression(
              '=',
              t$6.cloneNode(uid),
              path.node.expression,
            ),
          );
      } else {
        path.replaceWith(t$6.returnStatement(path.node.expression));
      }
    }

    const callee = this.get('callee');
    callee.arrowFunctionToExpression();

    const needToAwaitFunction =
      isParentAsync &&
      lib$a.default.hasType(
        this.get('callee.body').node,
        'AwaitExpression',
        t$6.FUNCTION_TYPES,
      );

    const needToYieldFunction =
      isParentGenerator &&
      lib$a.default.hasType(
        this.get('callee.body').node,
        'YieldExpression',
        t$6.FUNCTION_TYPES,
      );

    if (needToAwaitFunction) {
      callee.set('async', true);

      if (!needToYieldFunction) {
        this.replaceWith(t$6.awaitExpression(this.node));
      }
    }

    if (needToYieldFunction) {
      callee.set('generator', true);
      this.replaceWith(t$6.yieldExpression(this.node, true));
    }

    return callee.get('body.body');
  }

  function replaceInline(nodes) {
    this.resync();

    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = this._verifyNodeList(nodes);

        const paths = this._containerInsertAfter(nodes);

        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }

  var replacement = /*#__PURE__*/ Object.defineProperty(
    {
      replaceWithMultiple: replaceWithMultiple_1,
      replaceWithSourceString: replaceWithSourceString_1,
      replaceWith: replaceWith_1,
      _replaceWith: _replaceWith_1,
      replaceExpressionWithStatements: replaceExpressionWithStatements_1,
      replaceInline: replaceInline_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var evaluateTruthy_1 = evaluateTruthy;
  var evaluate_1 = evaluate;
  const VALID_CALLEES = ['String', 'Number', 'Math'];
  const INVALID_METHODS = ['random'];

  function evaluateTruthy() {
    const res = this.evaluate();
    if (res.confident) return !!res.value;
  }

  function deopt(path, state) {
    if (!state.confident) return;
    state.deoptPath = path;
    state.confident = false;
  }

  function evaluateCached(path, state) {
    const {node} = path;
    const {seen} = state;

    if (seen.has(node)) {
      const existing = seen.get(node);

      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path, state);
        return;
      }
    } else {
      const item = {
        resolved: false,
      };
      seen.set(node, item);

      const val = _evaluate(path, state);

      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }

      return val;
    }
  }

  function _evaluate(path, state) {
    if (!state.confident) return;

    if (path.isSequenceExpression()) {
      const exprs = path.get('expressions');
      return evaluateCached(exprs[exprs.length - 1], state);
    }

    if (
      path.isStringLiteral() ||
      path.isNumericLiteral() ||
      path.isBooleanLiteral()
    ) {
      return path.node.value;
    }

    if (path.isNullLiteral()) {
      return null;
    }

    if (path.isTemplateLiteral()) {
      return evaluateQuasis(path, path.node.quasis, state);
    }

    if (
      path.isTaggedTemplateExpression() &&
      path.get('tag').isMemberExpression()
    ) {
      const object = path.get('tag.object');
      const {
        node: {name},
      } = object;
      const property = path.get('tag.property');

      if (
        object.isIdentifier() &&
        name === 'String' &&
        !path.scope.getBinding(name) &&
        property.isIdentifier() &&
        property.node.name === 'raw'
      ) {
        return evaluateQuasis(path, path.node.quasi.quasis, state, true);
      }
    }

    if (path.isConditionalExpression()) {
      const testResult = evaluateCached(path.get('test'), state);
      if (!state.confident) return;

      if (testResult) {
        return evaluateCached(path.get('consequent'), state);
      } else {
        return evaluateCached(path.get('alternate'), state);
      }
    }

    if (path.isExpressionWrapper()) {
      return evaluateCached(path.get('expression'), state);
    }

    if (
      path.isMemberExpression() &&
      !path.parentPath.isCallExpression({
        callee: path.node,
      })
    ) {
      const property = path.get('property');
      const object = path.get('object');

      if (object.isLiteral() && property.isIdentifier()) {
        const value = object.node.value;
        const type = typeof value;

        if (type === 'number' || type === 'string') {
          return value[property.node.name];
        }
      }
    }

    if (path.isReferencedIdentifier()) {
      const binding = path.scope.getBinding(path.node.name);

      if (binding && binding.constantViolations.length > 0) {
        return deopt(binding.path, state);
      }

      if (binding && path.node.start < binding.path.node.end) {
        return deopt(binding.path, state);
      }

      if (binding != null && binding.hasValue) {
        return binding.value;
      } else {
        if (path.node.name === 'undefined') {
          return binding ? deopt(binding.path, state) : undefined;
        } else if (path.node.name === 'Infinity') {
          return binding ? deopt(binding.path, state) : Infinity;
        } else if (path.node.name === 'NaN') {
          return binding ? deopt(binding.path, state) : NaN;
        }

        const resolved = path.resolve();

        if (resolved === path) {
          return deopt(path, state);
        } else {
          return evaluateCached(resolved, state);
        }
      }
    }

    if (
      path.isUnaryExpression({
        prefix: true,
      })
    ) {
      if (path.node.operator === 'void') {
        return undefined;
      }

      const argument = path.get('argument');

      if (
        path.node.operator === 'typeof' &&
        (argument.isFunction() || argument.isClass())
      ) {
        return 'function';
      }

      const arg = evaluateCached(argument, state);
      if (!state.confident) return;

      switch (path.node.operator) {
        case '!':
          return !arg;

        case '+':
          return +arg;

        case '-':
          return -arg;

        case '~':
          return ~arg;

        case 'typeof':
          return typeof arg;
      }
    }

    if (path.isArrayExpression()) {
      const arr = [];
      const elems = path.get('elements');

      for (const elem of elems) {
        const elemValue = elem.evaluate();

        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          return deopt(elemValue.deopt, state);
        }
      }

      return arr;
    }

    if (path.isObjectExpression()) {
      const obj = {};
      const props = path.get('properties');

      for (const prop of props) {
        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          return deopt(prop, state);
        }

        const keyPath = prop.get('key');
        let key = keyPath;

        if (prop.node.computed) {
          key = key.evaluate();

          if (!key.confident) {
            return deopt(key.deopt, state);
          }

          key = key.value;
        } else if (key.isIdentifier()) {
          key = key.node.name;
        } else {
          key = key.node.value;
        }

        const valuePath = prop.get('value');
        let value = valuePath.evaluate();

        if (!value.confident) {
          return deopt(value.deopt, state);
        }

        value = value.value;
        obj[key] = value;
      }

      return obj;
    }

    if (path.isLogicalExpression()) {
      const wasConfident = state.confident;
      const left = evaluateCached(path.get('left'), state);
      const leftConfident = state.confident;
      state.confident = wasConfident;
      const right = evaluateCached(path.get('right'), state);
      const rightConfident = state.confident;

      switch (path.node.operator) {
        case '||':
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident) return;
          return left || right;

        case '&&':
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident) return;
          return left && right;
      }
    }

    if (path.isBinaryExpression()) {
      const left = evaluateCached(path.get('left'), state);
      if (!state.confident) return;
      const right = evaluateCached(path.get('right'), state);
      if (!state.confident) return;

      switch (path.node.operator) {
        case '-':
          return left - right;

        case '+':
          return left + right;

        case '/':
          return left / right;

        case '*':
          return left * right;

        case '%':
          return left % right;

        case '**':
          return Math.pow(left, right);

        case '<':
          return left < right;

        case '>':
          return left > right;

        case '<=':
          return left <= right;

        case '>=':
          return left >= right;

        case '==':
          return left == right;

        case '!=':
          return left != right;

        case '===':
          return left === right;

        case '!==':
          return left !== right;

        case '|':
          return left | right;

        case '&':
          return left & right;

        case '^':
          return left ^ right;

        case '<<':
          return left << right;

        case '>>':
          return left >> right;

        case '>>>':
          return left >>> right;
      }
    }

    if (path.isCallExpression()) {
      const callee = path.get('callee');
      let context;
      let func;

      if (
        callee.isIdentifier() &&
        !path.scope.getBinding(callee.node.name) &&
        VALID_CALLEES.indexOf(callee.node.name) >= 0
      ) {
        func = commonjsGlobal[callee.node.name];
      }

      if (callee.isMemberExpression()) {
        const object = callee.get('object');
        const property = callee.get('property');

        if (
          object.isIdentifier() &&
          property.isIdentifier() &&
          VALID_CALLEES.indexOf(object.node.name) >= 0 &&
          INVALID_METHODS.indexOf(property.node.name) < 0
        ) {
          context = commonjsGlobal[object.node.name];
          func = context[property.node.name];
        }

        if (object.isLiteral() && property.isIdentifier()) {
          const type = typeof object.node.value;

          if (type === 'string' || type === 'number') {
            context = object.node.value;
            func = context[property.node.name];
          }
        }
      }

      if (func) {
        const args = path
          .get('arguments')
          .map((arg) => evaluateCached(arg, state));
        if (!state.confident) return;
        return func.apply(context, args);
      }
    }

    deopt(path, state);
  }

  function evaluateQuasis(path, quasis, state, raw = false) {
    let str = '';
    let i = 0;
    const exprs = path.get('expressions');

    for (const elem of quasis) {
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      const expr = exprs[i++];
      if (expr) str += String(evaluateCached(expr, state));
    }

    if (!state.confident) return;
    return str;
  }

  function evaluate() {
    const state = {
      confident: true,
      deoptPath: null,
      seen: new Map(),
    };
    let value = evaluateCached(this, state);
    if (!state.confident) value = undefined;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value: value,
    };
  }

  var evaluation = /*#__PURE__*/ Object.defineProperty(
    {
      evaluateTruthy: evaluateTruthy_1,
      evaluate: evaluate_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var default_1$2 = _default$$;

  var t$7 = _interopRequireWildcard$g(lib$2);

  function _getRequireWildcardCache$g() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$g = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$g(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$g();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _default$$(node) {
    const params = node.params;

    for (let i = 0; i < params.length; i++) {
      const param = params[i];

      if (t$7.isAssignmentPattern(param) || t$7.isRestElement(param)) {
        return i;
      }
    }

    return params.length;
  }

  var lib$7 = /*#__PURE__*/ Object.defineProperty(
    {
      default: default_1$2,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var formatters = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.program = exports.expression = exports.statement = exports.statements = exports.smart = void 0;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function makeStatementFormatter(fn) {
      return {
        code: (str) => `/* @babel/template */;\n${str}`,
        validate: () => {},
        unwrap: (ast) => {
          return fn(ast.program.body.slice(1));
        },
      };
    }

    const smart = makeStatementFormatter((body) => {
      if (body.length > 1) {
        return body;
      } else {
        return body[0];
      }
    });
    exports.smart = smart;
    const statements = makeStatementFormatter((body) => body);
    exports.statements = statements;
    const statement = makeStatementFormatter((body) => {
      if (body.length === 0) {
        throw new Error('Found nothing to return.');
      }

      if (body.length > 1) {
        throw new Error('Found multiple statements but wanted one');
      }

      return body[0];
    });
    exports.statement = statement;
    const expression = {
      code: (str) => `(\n${str}\n)`,
      validate: (ast) => {
        if (ast.program.body.length > 1) {
          throw new Error('Found multiple statements but wanted one');
        }

        if (expression.unwrap(ast).start === 0) {
          throw new Error('Parse result included parens.');
        }
      },
      unwrap: ({program}) => {
        const [stmt] = program.body;
        t.assertExpressionStatement(stmt);
        return stmt.expression;
      },
    };
    exports.expression = expression;
    const program = {
      code: (str) => str,
      validate: () => {},
      unwrap: (ast) => ast.program,
    };
    exports.program = program;
  });

  var merge_1 = merge;
  var validate_1$1 = validate$1;
  var normalizeReplacements_1 = normalizeReplacements;

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function merge(a, b) {
    const {
      placeholderWhitelist = a.placeholderWhitelist,
      placeholderPattern = a.placeholderPattern,
      preserveComments = a.preserveComments,
      syntacticPlaceholders = a.syntacticPlaceholders,
    } = b;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders,
    };
  }

  function validate$1(opts) {
    if (opts != null && typeof opts !== 'object') {
      throw new Error('Unknown template options.');
    }

    const _ref = opts || {},
      {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders,
      } = _ref,
      parser = _objectWithoutPropertiesLoose(_ref, [
        'placeholderWhitelist',
        'placeholderPattern',
        'preserveComments',
        'syntacticPlaceholders',
      ]);

    if (
      placeholderWhitelist != null &&
      !(placeholderWhitelist instanceof Set)
    ) {
      throw new Error(
        "'.placeholderWhitelist' must be a Set, null, or undefined",
      );
    }

    if (
      placeholderPattern != null &&
      !(placeholderPattern instanceof RegExp) &&
      placeholderPattern !== false
    ) {
      throw new Error(
        "'.placeholderPattern' must be a RegExp, false, null, or undefined",
      );
    }

    if (preserveComments != null && typeof preserveComments !== 'boolean') {
      throw new Error(
        "'.preserveComments' must be a boolean, null, or undefined",
      );
    }

    if (
      syntacticPlaceholders != null &&
      typeof syntacticPlaceholders !== 'boolean'
    ) {
      throw new Error(
        "'.syntacticPlaceholders' must be a boolean, null, or undefined",
      );
    }

    if (
      syntacticPlaceholders === true &&
      (placeholderWhitelist != null || placeholderPattern != null)
    ) {
      throw new Error(
        "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" +
          " with '.syntacticPlaceholders: true'",
      );
    }

    return {
      parser,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern:
        placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders:
        syntacticPlaceholders == null ? undefined : syntacticPlaceholders,
    };
  }

  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce((acc, replacement, i) => {
        acc['$' + i] = replacement;
        return acc;
      }, {});
    } else if (typeof replacements === 'object' || replacements == null) {
      return replacements || undefined;
    }

    throw new Error(
      'Template replacements must be an array, object, null, or undefined',
    );
  }

  var options = /*#__PURE__*/ Object.defineProperty(
    {
      merge: merge_1,
      validate: validate_1$1,
      normalizeReplacements: normalizeReplacements_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$10 = parseAndBuildMetadata;

  var t$8 = _interopRequireWildcard$h(lib$2);

  function _getRequireWildcardCache$h() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$h = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$h(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$h();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  const PATTERN = /^[_$A-Z0-9]+$/;

  function parseAndBuildMetadata(formatter, code, opts) {
    const {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders,
    } = opts;
    const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    t$8.removePropertiesDeep(ast, {
      preserveComments,
    });
    formatter.validate(ast);
    const syntactic = {
      placeholders: [],
      placeholderNames: new Set(),
    };
    const legacy = {
      placeholders: [],
      placeholderNames: new Set(),
    };
    const isLegacyRef = {
      value: undefined,
    };
    t$8.traverse(ast, placeholderVisitorHandler, {
      syntactic,
      legacy,
      isLegacyRef,
      placeholderWhitelist,
      placeholderPattern,
      syntacticPlaceholders,
    });
    return Object.assign(
      {
        ast,
      },
      isLegacyRef.value ? legacy : syntactic,
    );
  }

  function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;

    let name;

    if (t$8.isPlaceholder(node)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error(
          "%%foo%%-style placeholders can't be used when " +
            "'.syntacticPlaceholders' is false.",
        );
      } else {
        name = node.name.name;
        state.isLegacyRef.value = false;
      }
    } else if (
      state.isLegacyRef.value === false ||
      state.syntacticPlaceholders
    ) {
      return;
    } else if (t$8.isIdentifier(node) || t$8.isJSXIdentifier(node)) {
      name = node.name;
      state.isLegacyRef.value = true;
    } else if (t$8.isStringLiteral(node)) {
      name = node.value;
      state.isLegacyRef.value = true;
    } else {
      return;
    }

    if (
      !state.isLegacyRef.value &&
      (state.placeholderPattern != null || state.placeholderWhitelist != null)
    ) {
      throw new Error(
        "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" +
          " with '.syntacticPlaceholders: true'",
      );
    }

    if (
      state.isLegacyRef.value &&
      (state.placeholderPattern === false ||
        !(state.placeholderPattern || PATTERN).test(name)) &&
      !((_state$placeholderWhi = state.placeholderWhitelist) == null
        ? void 0
        : _state$placeholderWhi.has(name))
    ) {
      return;
    }

    ancestors = ancestors.slice();
    const {node: parent, key} = ancestors[ancestors.length - 1];
    let type;

    if (
      t$8.isStringLiteral(node) ||
      t$8.isPlaceholder(node, {
        expectedNode: 'StringLiteral',
      })
    ) {
      type = 'string';
    } else if (
      (t$8.isNewExpression(parent) && key === 'arguments') ||
      (t$8.isCallExpression(parent) && key === 'arguments') ||
      (t$8.isFunction(parent) && key === 'params')
    ) {
      type = 'param';
    } else if (t$8.isExpressionStatement(parent) && !t$8.isPlaceholder(node)) {
      type = 'statement';
      ancestors = ancestors.slice(0, -1);
    } else if (t$8.isStatement(node) && t$8.isPlaceholder(node)) {
      type = 'statement';
    } else {
      type = 'other';
    }

    const {placeholders, placeholderNames} = state.isLegacyRef.value
      ? state.legacy
      : state.syntactic;
    placeholders.push({
      name,
      type,
      resolve: (ast) => resolveAncestors(ast, ancestors),
      isDuplicate: placeholderNames.has(name),
    });
    placeholderNames.add(name);
  }

  function resolveAncestors(ast, ancestors) {
    let parent = ast;

    for (let i = 0; i < ancestors.length - 1; i++) {
      const {key, index} = ancestors[i];

      if (index === undefined) {
        parent = parent[key];
      } else {
        parent = parent[key][index];
      }
    }

    const {key, index} = ancestors[ancestors.length - 1];
    return {
      parent,
      key,
      index,
    };
  }

  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();

    if (syntacticPlaceholders !== false) {
      plugins.push('placeholders');
    }

    parserOpts = Object.assign(
      {
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        sourceType: 'module',
      },
      parserOpts,
      {
        plugins,
      },
    );

    try {
      return (0, lib.parse)(code, parserOpts);
    } catch (err) {
      const loc = err.loc;

      if (loc) {
        err.message +=
          '\n' +
          (0, lib$6.codeFrameColumns)(code, {
            start: loc,
          });
        err.code = 'BABEL_TEMPLATE_PARSE_ERROR';
      }

      throw err;
    }
  }

  var parse$1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$10,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$11 = populatePlaceholders;

  var t$9 = _interopRequireWildcard$i(lib$2);

  function _getRequireWildcardCache$i() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$i = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$i(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$i();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function populatePlaceholders(metadata, replacements) {
    const ast = t$9.cloneNode(metadata.ast);

    if (replacements) {
      metadata.placeholders.forEach((placeholder) => {
        if (
          !Object.prototype.hasOwnProperty.call(replacements, placeholder.name)
        ) {
          const placeholderName = placeholder.name;
          throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
        }
      });
      Object.keys(replacements).forEach((key) => {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error(`Unknown substitution "${key}" given`);
        }
      });
    }

    metadata.placeholders
      .slice()
      .reverse()
      .forEach((placeholder) => {
        try {
          applyReplacement(
            placeholder,
            ast,
            (replacements && replacements[placeholder.name]) || null,
          );
        } catch (e) {
          e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
          throw e;
        }
      });
    return ast;
  }

  function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map((node) => t$9.cloneNode(node));
      } else if (typeof replacement === 'object') {
        replacement = t$9.cloneNode(replacement);
      }
    }

    const {parent, key, index} = placeholder.resolve(ast);

    if (placeholder.type === 'string') {
      if (typeof replacement === 'string') {
        replacement = t$9.stringLiteral(replacement);
      }

      if (!replacement || !t$9.isStringLiteral(replacement)) {
        throw new Error('Expected string substitution');
      }
    } else if (placeholder.type === 'statement') {
      if (index === undefined) {
        if (!replacement) {
          replacement = t$9.emptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = t$9.blockStatement(replacement);
        } else if (typeof replacement === 'string') {
          replacement = t$9.expressionStatement(t$9.identifier(replacement));
        } else if (!t$9.isStatement(replacement)) {
          replacement = t$9.expressionStatement(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === 'string') {
            replacement = t$9.identifier(replacement);
          }

          if (!t$9.isStatement(replacement)) {
            replacement = t$9.expressionStatement(replacement);
          }
        }
      }
    } else if (placeholder.type === 'param') {
      if (typeof replacement === 'string') {
        replacement = t$9.identifier(replacement);
      }

      if (index === undefined) throw new Error('Assertion failure.');
    } else {
      if (typeof replacement === 'string') {
        replacement = t$9.identifier(replacement);
      }

      if (Array.isArray(replacement)) {
        throw new Error('Cannot replace single expression with an array.');
      }
    }

    if (index === undefined) {
      t$9.validate(parent, key, replacement);
      parent[key] = replacement;
    } else {
      const items = parent[key].slice();

      if (placeholder.type === 'statement' || placeholder.type === 'param') {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice(index, 1, ...replacement);
        } else {
          items[index] = replacement;
        }
      } else {
        items[index] = replacement;
      }

      t$9.validate(parent, key, items);
      parent[key] = items;
    }
  }

  var populate = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$11,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$12 = stringTemplate;

  var _parse = _interopRequireDefault$w(parse$1);

  var _populate = _interopRequireDefault$w(populate);

  function _interopRequireDefault$w(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    let metadata;
    return (arg) => {
      const replacements = (0, options.normalizeReplacements)(arg);
      if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
      return formatter.unwrap((0, _populate.default)(metadata, replacements));
    };
  }

  var string = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$12,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$13 = literalTemplate;

  var _parse$1 = _interopRequireDefault$x(parse$1);

  var _populate$1 = _interopRequireDefault$x(populate);

  function _interopRequireDefault$x(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function literalTemplate(formatter, tpl, opts) {
    const {metadata, names} = buildLiteralData(formatter, tpl, opts);
    return (arg) => {
      const defaultReplacements = {};
      arg.forEach((replacement, i) => {
        defaultReplacements[names[i]] = replacement;
      });
      return (arg) => {
        const replacements = (0, options.normalizeReplacements)(arg);

        if (replacements) {
          Object.keys(replacements).forEach((key) => {
            if (
              Object.prototype.hasOwnProperty.call(defaultReplacements, key)
            ) {
              throw new Error('Unexpected replacement overlap.');
            }
          });
        }

        return formatter.unwrap(
          (0, _populate$1.default)(
            metadata,
            replacements
              ? Object.assign(replacements, defaultReplacements)
              : defaultReplacements,
          ),
        );
      };
    };
  }

  function buildLiteralData(formatter, tpl, opts) {
    let names;
    let nameSet;
    let metadata;
    let prefix = '';

    do {
      prefix += '$';
      const result = buildTemplateCode(tpl, prefix);
      names = result.names;
      nameSet = new Set(names);
      metadata = (0, _parse$1.default)(formatter, formatter.code(result.code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(
          result.names.concat(
            opts.placeholderWhitelist
              ? Array.from(opts.placeholderWhitelist)
              : [],
          ),
        ),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders,
      });
    } while (
      metadata.placeholders.some(
        (placeholder) =>
          placeholder.isDuplicate && nameSet.has(placeholder.name),
      )
    );

    return {
      metadata,
      names,
    };
  }

  function buildTemplateCode(tpl, prefix) {
    const names = [];
    let code = tpl[0];

    for (let i = 1; i < tpl.length; i++) {
      const value = `${prefix}${i - 1}`;
      names.push(value);
      code += value + tpl[i];
    }

    return {
      names,
      code,
    };
  }

  var literal = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$13,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var _default$14 = createTemplateBuilder;

  var _string = _interopRequireDefault$y(string);

  var _literal = _interopRequireDefault$y(literal);

  function _interopRequireDefault$y(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  const NO_PLACEHOLDER = (0, options.validate)({
    placeholderPattern: false,
  });

  function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache = new WeakMap();
    const templateAstCache = new WeakMap();
    const cachedOpts = defaultOpts || (0, options.validate)(null);
    return Object.assign(
      (tpl, ...args) => {
        if (typeof tpl === 'string') {
          if (args.length > 1) throw new Error('Unexpected extra params.');
          return extendedTrace(
            (0, _string.default)(
              formatter,
              tpl,
              (0, options.merge)(cachedOpts, (0, options.validate)(args[0])),
            ),
          );
        } else if (Array.isArray(tpl)) {
          let builder = templateFnCache.get(tpl);

          if (!builder) {
            builder = (0, _literal.default)(formatter, tpl, cachedOpts);
            templateFnCache.set(tpl, builder);
          }

          return extendedTrace(builder(args));
        } else if (typeof tpl === 'object' && tpl) {
          if (args.length > 0) throw new Error('Unexpected extra params.');
          return createTemplateBuilder(
            formatter,
            (0, options.merge)(cachedOpts, (0, options.validate)(tpl)),
          );
        }

        throw new Error(`Unexpected template param ${typeof tpl}`);
      },
      {
        ast: (tpl, ...args) => {
          if (typeof tpl === 'string') {
            if (args.length > 1) throw new Error('Unexpected extra params.');
            return (0, _string.default)(
              formatter,
              tpl,
              (0, options.merge)(
                (0, options.merge)(cachedOpts, (0, options.validate)(args[0])),
                NO_PLACEHOLDER,
              ),
            )();
          } else if (Array.isArray(tpl)) {
            let builder = templateAstCache.get(tpl);

            if (!builder) {
              builder = (0, _literal.default)(
                formatter,
                tpl,
                (0, options.merge)(cachedOpts, NO_PLACEHOLDER),
              );
              templateAstCache.set(tpl, builder);
            }

            return builder(args)();
          }

          throw new Error(`Unexpected template param ${typeof tpl}`);
        },
      },
    );
  }

  function extendedTrace(fn) {
    let rootStack = '';

    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split('\n').slice(3).join('\n');
      }
    }

    return (arg) => {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += `\n    =============\n${rootStack}`;
        throw err;
      }
    };
  }

  var builder$1 = /*#__PURE__*/ Object.defineProperty(
    {
      default: _default$14,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var lib$8 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = exports.program = exports.expression = exports.statements = exports.statement = exports.smart = void 0;

    var formatters$1 = _interopRequireWildcard(formatters);

    var _builder = _interopRequireDefault(builder$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    const smart = (0, _builder.default)(formatters$1.smart);
    exports.smart = smart;
    const statement = (0, _builder.default)(formatters$1.statement);
    exports.statement = statement;
    const statements = (0, _builder.default)(formatters$1.statements);
    exports.statements = statements;
    const expression = (0, _builder.default)(formatters$1.expression);
    exports.expression = expression;
    const program = (0, _builder.default)(formatters$1.program);
    exports.program = program;

    var _default = Object.assign(smart.bind(undefined), {
      smart,
      statement,
      statements,
      expression,
      program,
      ast: smart.ast,
    });

    exports.default = _default;
  });

  var default_1$3 = _default$15;

  var _helperGetFunctionArity = _interopRequireDefault$z(lib$7);

  var _template = _interopRequireDefault$z(lib$8);

  var t$a = _interopRequireWildcard$j(lib$2);

  function _getRequireWildcardCache$j() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$j = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$j(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$j();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _interopRequireDefault$z(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  const buildPropertyMethodAssignmentWrapper = (0, _template.default)(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
  const buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
  const visitor = {
    'ReferencedIdentifier|BindingIdentifier'(path, state) {
      if (path.node.name !== state.name) return;
      const localDeclar = path.scope.getBindingIdentifier(state.name);
      if (localDeclar !== state.outerDeclar) return;
      state.selfReference = true;
      path.stop();
    },
  };

  function getNameFromLiteralId(id) {
    if (t$a.isNullLiteral(id)) {
      return 'null';
    }

    if (t$a.isRegExpLiteral(id)) {
      return `_${id.pattern}_${id.flags}`;
    }

    if (t$a.isTemplateLiteral(id)) {
      return id.quasis.map((quasi) => quasi.value.raw).join('');
    }

    if (id.value !== undefined) {
      return id.value + '';
    }

    return '';
  }

  function wrap(state, method, id, scope) {
    if (state.selfReference) {
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
      } else {
        if (!t$a.isFunction(method)) return;
        let build = buildPropertyMethodAssignmentWrapper;

        if (method.generator) {
          build = buildGeneratorPropertyMethodAssignmentWrapper;
        }

        const template = build({
          FUNCTION: method,
          FUNCTION_ID: id,
          FUNCTION_KEY: scope.generateUidIdentifier(id.name),
        }).expression;
        const params = template.callee.body.body[0].params;

        for (
          let i = 0, len = (0, _helperGetFunctionArity.default)(method);
          i < len;
          i++
        ) {
          params.push(scope.generateUidIdentifier('x'));
        }

        return template;
      }
    }

    method.id = id;
    scope.getProgramParent().references[id.name] = true;
  }

  function visit(node, name, scope) {
    const state = {
      selfAssignment: false,
      selfReference: false,
      outerDeclar: scope.getBindingIdentifier(name),
      references: [],
      name: name,
    };
    const binding = scope.getOwnBinding(name);

    if (binding) {
      if (binding.kind === 'param') {
        state.selfReference = true;
      }
    } else if (state.outerDeclar || scope.hasGlobal(name)) {
      scope.traverse(node, visitor, state);
    }

    return state;
  }

  function _default$15({node, parent, scope, id}, localBinding = false) {
    if (node.id) return;

    if (
      (t$a.isObjectProperty(parent) ||
        t$a.isObjectMethod(parent, {
          kind: 'method',
        })) &&
      (!parent.computed || t$a.isLiteral(parent.key))
    ) {
      id = parent.key;
    } else if (t$a.isVariableDeclarator(parent)) {
      id = parent.id;

      if (t$a.isIdentifier(id) && !localBinding) {
        const binding = scope.parent.getBinding(id.name);

        if (
          binding &&
          binding.constant &&
          scope.getBinding(id.name) === binding
        ) {
          node.id = t$a.cloneNode(id);
          node.id[t$a.NOT_LOCAL_BINDING] = true;
          return;
        }
      }
    } else if (
      t$a.isAssignmentExpression(parent, {
        operator: '=',
      })
    ) {
      id = parent.left;
    } else if (!id) {
      return;
    }

    let name;

    if (id && t$a.isLiteral(id)) {
      name = getNameFromLiteralId(id);
    } else if (id && t$a.isIdentifier(id)) {
      name = id.name;
    }

    if (name === undefined) {
      return;
    }

    name = t$a.toBindingIdentifierName(name);
    id = t$a.identifier(name);
    id[t$a.NOT_LOCAL_BINDING] = true;
    const state = visit(node, name, scope);
    return wrap(state, node, id, scope) || node;
  }

  var lib$9 = /*#__PURE__*/ Object.defineProperty(
    {
      default: default_1$3,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var toComputedKey_1$1 = toComputedKey$1;
  var ensureBlock_1$1 = ensureBlock$1;
  var arrowFunctionToShadowed_1 = arrowFunctionToShadowed;
  var unwrapFunctionEnvironment_1 = unwrapFunctionEnvironment;
  var arrowFunctionToExpression_1 = arrowFunctionToExpression;

  var t$b = _interopRequireWildcard$k(lib$2);

  var _helperFunctionName = _interopRequireDefault$A(lib$9);

  function _interopRequireDefault$A(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function _getRequireWildcardCache$k() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$k = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$k(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$k();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function toComputedKey$1() {
    let key;

    if (this.isMemberExpression()) {
      key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = this.node.key;
    } else {
      throw new ReferenceError('todo');
    }

    if (!this.node.computed) {
      if (t$b.isIdentifier(key)) key = t$b.stringLiteral(key.name);
    }

    return key;
  }

  function ensureBlock$1() {
    const body = this.get('body');
    const bodyNode = body.node;

    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }

    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }

    if (body.isBlockStatement()) {
      return bodyNode;
    }

    const statements = [];
    let stringPath = 'body';
    let key;
    let listKey;

    if (body.isStatement()) {
      listKey = 'body';
      key = 0;
      statements.push(body.node);
    } else {
      stringPath += '.body.0';

      if (this.isFunction()) {
        key = 'argument';
        statements.push(t$b.returnStatement(body.node));
      } else {
        key = 'expression';
        statements.push(t$b.expressionStatement(body.node));
      }
    }

    this.node.body = t$b.blockStatement(statements);
    const parentPath = this.get(stringPath);
    body.setup(
      parentPath,
      listKey ? parentPath.node[listKey] : parentPath.node,
      listKey,
      key,
    );
    return this.node;
  }

  function arrowFunctionToShadowed() {
    if (!this.isArrowFunctionExpression()) return;
    this.arrowFunctionToExpression();
  }

  function unwrapFunctionEnvironment() {
    if (
      !this.isArrowFunctionExpression() &&
      !this.isFunctionExpression() &&
      !this.isFunctionDeclaration()
    ) {
      throw this.buildCodeFrameError(
        'Can only unwrap the environment of a function.',
      );
    }

    hoistFunctionEnvironment(this);
  }

  function arrowFunctionToExpression({
    allowInsertArrow = true,
    specCompliant = false,
    noNewArrows = !specCompliant,
  } = {}) {
    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError(
        'Cannot convert non-arrow function to a function expression.',
      );
    }

    const thisBinding = hoistFunctionEnvironment(
      this,
      noNewArrows,
      allowInsertArrow,
    );
    this.ensureBlock();
    this.node.type = 'FunctionExpression';

    if (!noNewArrows) {
      const checkBinding = thisBinding
        ? null
        : this.parentPath.scope.generateUidIdentifier('arrowCheckId');

      if (checkBinding) {
        this.parentPath.scope.push({
          id: checkBinding,
          init: t$b.objectExpression([]),
        });
      }

      this.get('body').unshiftContainer(
        'body',
        t$b.expressionStatement(
          t$b.callExpression(this.hub.addHelper('newArrowCheck'), [
            t$b.thisExpression(),
            checkBinding
              ? t$b.identifier(checkBinding.name)
              : t$b.identifier(thisBinding),
          ]),
        ),
      );
      this.replaceWith(
        t$b.callExpression(
          t$b.memberExpression(
            (0, _helperFunctionName.default)(this, true) || this.node,
            t$b.identifier('bind'),
          ),
          [
            checkBinding
              ? t$b.identifier(checkBinding.name)
              : t$b.thisExpression(),
          ],
        ),
      );
    }
  }

  function hoistFunctionEnvironment(
    fnPath,
    noNewArrows = true,
    allowInsertArrow = true,
  ) {
    const thisEnvFn = fnPath.findParent((p) => {
      return (
        (p.isFunction() && !p.isArrowFunctionExpression()) ||
        p.isProgram() ||
        p.isClassProperty({
          static: false,
        })
      );
    });
    const inConstructor =
      (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === 'constructor';

    if (thisEnvFn.isClassProperty()) {
      throw fnPath.buildCodeFrameError(
        'Unable to transform arrow inside class property',
      );
    }

    const {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls,
    } = getScopeInformation(fnPath);

    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError(
          'Unable to handle nested super() usage in arrow',
        );
      }

      const allSuperCalls = [];
      thisEnvFn.traverse({
        Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },

        ClassProperty(child) {
          child.skip();
        },

        CallExpression(child) {
          if (!child.get('callee').isSuper()) return;
          allSuperCalls.push(child);
        },
      });
      const superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach((superCall) => {
        const callee = t$b.identifier(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get('callee').replaceWith(callee);
      });
    }

    if (argumentsPaths.length > 0) {
      const argumentsBinding = getBinding(thisEnvFn, 'arguments', () =>
        t$b.identifier('arguments'),
      );
      argumentsPaths.forEach((argumentsChild) => {
        const argsRef = t$b.identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }

    if (newTargetPaths.length > 0) {
      const newTargetBinding = getBinding(thisEnvFn, 'newtarget', () =>
        t$b.metaProperty(t$b.identifier('new'), t$b.identifier('target')),
      );
      newTargetPaths.forEach((targetChild) => {
        const targetRef = t$b.identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }

    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError(
          'Unable to handle nested super.prop usage',
        );
      }

      const flatSuperProps = superProps.reduce(
        (acc, superProp) => acc.concat(standardizeSuperProperty(superProp)),
        [],
      );
      flatSuperProps.forEach((superProp) => {
        const key = superProp.node.computed
          ? ''
          : superProp.get('property').node.name;
        const isAssignment = superProp.parentPath.isAssignmentExpression({
          left: superProp.node,
        });
        const isCall = superProp.parentPath.isCallExpression({
          callee: superProp.node,
        });
        const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        const args = [];

        if (superProp.node.computed) {
          args.push(superProp.get('property').node);
        }

        if (isAssignment) {
          const value = superProp.parentPath.node.right;
          args.push(value);
        }

        const call = t$b.callExpression(t$b.identifier(superBinding), args);

        if (isCall) {
          superProp.parentPath.unshiftContainer(
            'arguments',
            t$b.thisExpression(),
          );
          superProp.replaceWith(
            t$b.memberExpression(call, t$b.identifier('call')),
          );
          thisPaths.push(superProp.parentPath.get('arguments.0'));
        } else if (isAssignment) {
          superProp.parentPath.replaceWith(call);
        } else {
          superProp.replaceWith(call);
        }
      });
    }

    let thisBinding;

    if (thisPaths.length > 0 || !noNewArrows) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);

      if (noNewArrows || (inConstructor && hasSuperClass(thisEnvFn))) {
        thisPaths.forEach((thisChild) => {
          const thisRef = thisChild.isJSX()
            ? t$b.jsxIdentifier(thisBinding)
            : t$b.identifier(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (!noNewArrows) thisBinding = null;
      }
    }

    return thisBinding;
  }

  function standardizeSuperProperty(superProp) {
    if (
      superProp.parentPath.isAssignmentExpression() &&
      superProp.parentPath.node.operator !== '='
    ) {
      const assignmentPath = superProp.parentPath;
      const op = assignmentPath.node.operator.slice(0, -1);
      const value = assignmentPath.node.right;
      assignmentPath.node.operator = '=';

      if (superProp.node.computed) {
        const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp');
        assignmentPath
          .get('left')
          .replaceWith(
            t$b.memberExpression(
              superProp.node.object,
              t$b.assignmentExpression('=', tmp, superProp.node.property),
              true,
            ),
          );
        assignmentPath
          .get('right')
          .replaceWith(
            t$b.binaryExpression(
              op,
              t$b.memberExpression(
                superProp.node.object,
                t$b.identifier(tmp.name),
                true,
              ),
              value,
            ),
          );
      } else {
        assignmentPath
          .get('left')
          .replaceWith(
            t$b.memberExpression(
              superProp.node.object,
              superProp.node.property,
            ),
          );
        assignmentPath
          .get('right')
          .replaceWith(
            t$b.binaryExpression(
              op,
              t$b.memberExpression(
                superProp.node.object,
                t$b.identifier(superProp.node.property.name),
              ),
              value,
            ),
          );
      }

      return [
        assignmentPath.get('left'),
        assignmentPath.get('right').get('left'),
      ];
    } else if (superProp.parentPath.isUpdateExpression()) {
      const updateExpr = superProp.parentPath;
      const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp');
      const computedKey = superProp.node.computed
        ? superProp.scope.generateDeclaredUidIdentifier('prop')
        : null;
      const parts = [
        t$b.assignmentExpression(
          '=',
          tmp,
          t$b.memberExpression(
            superProp.node.object,
            computedKey
              ? t$b.assignmentExpression(
                  '=',
                  computedKey,
                  superProp.node.property,
                )
              : superProp.node.property,
            superProp.node.computed,
          ),
        ),
        t$b.assignmentExpression(
          '=',
          t$b.memberExpression(
            superProp.node.object,
            computedKey
              ? t$b.identifier(computedKey.name)
              : superProp.node.property,
            superProp.node.computed,
          ),
          t$b.binaryExpression(
            '+',
            t$b.identifier(tmp.name),
            t$b.numericLiteral(1),
          ),
        ),
      ];

      if (!superProp.parentPath.node.prefix) {
        parts.push(t$b.identifier(tmp.name));
      }

      updateExpr.replaceWith(t$b.sequenceExpression(parts));
      const left = updateExpr.get('expressions.0.right');
      const right = updateExpr.get('expressions.1.left');
      return [left, right];
    }

    return [superProp];
  }

  function hasSuperClass(thisEnvFn) {
    return (
      thisEnvFn.isClassMethod() &&
      !!thisEnvFn.parentPath.parentPath.node.superClass
    );
  }

  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, 'this', (thisBinding) => {
      if (!inConstructor || !hasSuperClass(thisEnvFn))
        return t$b.thisExpression();
      const supers = new WeakSet();
      thisEnvFn.traverse({
        Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },

        ClassProperty(child) {
          child.skip();
        },

        CallExpression(child) {
          if (!child.get('callee').isSuper()) return;
          if (supers.has(child.node)) return;
          supers.add(child.node);
          child.replaceWithMultiple([
            child.node,
            t$b.assignmentExpression(
              '=',
              t$b.identifier(thisBinding),
              t$b.identifier('this'),
            ),
          ]);
        },
      });
    });
  }

  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, 'supercall', () => {
      const argsBinding = thisEnvFn.scope.generateUidIdentifier('args');
      return t$b.arrowFunctionExpression(
        [t$b.restElement(argsBinding)],
        t$b.callExpression(t$b.super(), [
          t$b.spreadElement(t$b.identifier(argsBinding.name)),
        ]),
      );
    });
  }

  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    const op = isAssignment ? 'set' : 'get';
    return getBinding(thisEnvFn, `superprop_${op}:${propName || ''}`, () => {
      const argsList = [];
      let fnBody;

      if (propName) {
        fnBody = t$b.memberExpression(t$b.super(), t$b.identifier(propName));
      } else {
        const method = thisEnvFn.scope.generateUidIdentifier('prop');
        argsList.unshift(method);
        fnBody = t$b.memberExpression(
          t$b.super(),
          t$b.identifier(method.name),
          true,
        );
      }

      if (isAssignment) {
        const valueIdent = thisEnvFn.scope.generateUidIdentifier('value');
        argsList.push(valueIdent);
        fnBody = t$b.assignmentExpression(
          '=',
          fnBody,
          t$b.identifier(valueIdent.name),
        );
      }

      return t$b.arrowFunctionExpression(argsList, fnBody);
    });
  }

  function getBinding(thisEnvFn, key, init) {
    const cacheKey = 'binding:' + key;
    let data = thisEnvFn.getData(cacheKey);

    if (!data) {
      const id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id: id,
        init: init(data),
      });
    }

    return data;
  }

  function getScopeInformation(fnPath) {
    const thisPaths = [];
    const argumentsPaths = [];
    const newTargetPaths = [];
    const superProps = [];
    const superCalls = [];
    fnPath.traverse({
      ClassProperty(child) {
        child.skip();
      },

      Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },

      ThisExpression(child) {
        thisPaths.push(child);
      },

      JSXIdentifier(child) {
        if (child.node.name !== 'this') return;

        if (
          !child.parentPath.isJSXMemberExpression({
            object: child.node,
          }) &&
          !child.parentPath.isJSXOpeningElement({
            name: child.node,
          })
        ) {
          return;
        }

        thisPaths.push(child);
      },

      CallExpression(child) {
        if (child.get('callee').isSuper()) superCalls.push(child);
      },

      MemberExpression(child) {
        if (child.get('object').isSuper()) superProps.push(child);
      },

      ReferencedIdentifier(child) {
        if (child.node.name !== 'arguments') return;
        argumentsPaths.push(child);
      },

      MetaProperty(child) {
        if (
          !child.get('meta').isIdentifier({
            name: 'new',
          })
        )
          return;
        if (
          !child.get('property').isIdentifier({
            name: 'target',
          })
        )
          return;
        newTargetPaths.push(child);
      },
    });
    return {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls,
    };
  }

  var conversion = /*#__PURE__*/ Object.defineProperty(
    {
      toComputedKey: toComputedKey_1$1,
      ensureBlock: ensureBlock_1$1,
      arrowFunctionToShadowed: arrowFunctionToShadowed_1,
      unwrapFunctionEnvironment: unwrapFunctionEnvironment_1,
      arrowFunctionToExpression: arrowFunctionToExpression_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var introspection = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.matchesPattern = matchesPattern;
    exports.has = has;
    exports.isStatic = isStatic;
    exports.isnt = isnt;
    exports.equals = equals;
    exports.isNodeType = isNodeType;
    exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports.isCompletionRecord = isCompletionRecord;
    exports.isStatementOrBlock = isStatementOrBlock;
    exports.referencesImport = referencesImport;
    exports.getSource = getSource;
    exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
    exports.resolve = resolve;
    exports._resolve = _resolve;
    exports.isConstantExpression = isConstantExpression;
    exports.isInStrictMode = isInStrictMode;
    exports.is = void 0;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function matchesPattern(pattern, allowPartial) {
      return t.matchesPattern(this.node, pattern, allowPartial);
    }

    function has(key) {
      const val = this.node && this.node[key];

      if (val && Array.isArray(val)) {
        return !!val.length;
      } else {
        return !!val;
      }
    }

    function isStatic() {
      return this.scope.isStatic(this.node);
    }

    const is = has;
    exports.is = is;

    function isnt(key) {
      return !this.has(key);
    }

    function equals(key, value) {
      return this.node[key] === value;
    }

    function isNodeType(type) {
      return t.isType(this.type, type);
    }

    function canHaveVariableDeclarationOrExpression() {
      return (
        (this.key === 'init' || this.key === 'left') && this.parentPath.isFor()
      );
    }

    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== 'body' || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }

      if (this.isExpression()) {
        return t.isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return t.isExpression(replacement);
      }

      return false;
    }

    function isCompletionRecord(allowInsideFunction) {
      let path = this;
      let first = true;

      do {
        const container = path.container;

        if (path.isFunction() && !first) {
          return !!allowInsideFunction;
        }

        first = false;

        if (Array.isArray(container) && path.key !== container.length - 1) {
          return false;
        }
      } while ((path = path.parentPath) && !path.isProgram());

      return true;
    }

    function isStatementOrBlock() {
      if (
        this.parentPath.isLabeledStatement() ||
        t.isBlockStatement(this.container)
      ) {
        return false;
      } else {
        return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }

    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (
          (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
          (this.node.computed
            ? t.isStringLiteral(this.node.property, {
                value: importName,
              })
            : this.node.property.name === importName)
        ) {
          const object = this.get('object');
          return (
            object.isReferencedIdentifier() &&
            object.referencesImport(moduleSource, '*')
          );
        }

        return false;
      }

      const binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== 'module') return false;
      const path = binding.path;
      const parent = path.parentPath;
      if (!parent.isImportDeclaration()) return false;

      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }

      if (path.isImportDefaultSpecifier() && importName === 'default') {
        return true;
      }

      if (path.isImportNamespaceSpecifier() && importName === '*') {
        return true;
      }

      if (
        path.isImportSpecifier() &&
        t.isIdentifier(path.node.imported, {
          name: importName,
        })
      ) {
        return true;
      }

      return false;
    }

    function getSource() {
      const node = this.node;

      if (node.end) {
        const code = this.hub.getCode();
        if (code) return code.slice(node.start, node.end);
      }

      return '';
    }

    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== 'after';
    }

    function getOuterFunction(path) {
      return (
        path.scope.getFunctionParent() || path.scope.getProgramParent()
      ).path;
    }

    function isExecutionUncertain(type, key) {
      switch (type) {
        case 'LogicalExpression':
          return key === 'right';

        case 'ConditionalExpression':
        case 'IfStatement':
          return key === 'consequent' || key === 'alternate';

        case 'WhileStatement':
        case 'DoWhileStatement':
        case 'ForInStatement':
        case 'ForOfStatement':
          return key === 'body';

        case 'ForStatement':
          return key === 'body' || key === 'update';

        case 'SwitchStatement':
          return key === 'cases';

        case 'TryStatement':
          return key === 'handler';

        case 'AssignmentPattern':
          return key === 'right';

        case 'OptionalMemberExpression':
          return key === 'property';

        case 'OptionalCallExpression':
          return key === 'arguments';

        default:
          return false;
      }
    }

    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path = paths[i];

        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
          return true;
        }
      }

      return false;
    }

    function _guessExecutionStatusRelativeTo(target) {
      const funcParent = {
        this: getOuterFunction(this),
        target: getOuterFunction(target),
      };

      if (funcParent.target.node !== funcParent.this.node) {
        return this._guessExecutionStatusRelativeToDifferentFunctions(
          funcParent.target,
        );
      }

      const paths = {
        target: target.getAncestry(),
        this: this.getAncestry(),
      };
      if (paths.target.indexOf(this) >= 0) return 'after';
      if (paths.this.indexOf(target) >= 0) return 'before';
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0,
      };

      while (!commonPath && commonIndex.this < paths.this.length) {
        const path = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path);

        if (commonIndex.target >= 0) {
          commonPath = path;
        } else {
          commonIndex.this++;
        }
      }

      if (!commonPath) {
        throw new Error(
          'Internal Babel error - The two compared nodes' +
            " don't appear to belong to the same program.",
        );
      }

      if (
        isExecutionUncertainInList(paths.this, commonIndex.this - 1) ||
        isExecutionUncertainInList(paths.target, commonIndex.target - 1)
      ) {
        return 'unknown';
      }

      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1],
      };

      if (
        divergence.target.listKey &&
        divergence.this.listKey &&
        divergence.target.container === divergence.this.container
      ) {
        return divergence.target.key > divergence.this.key ? 'before' : 'after';
      }

      const keys = t.VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey),
      };
      return keyPosition.target > keyPosition.this ? 'before' : 'after';
    }

    const executionOrderCheckedNodes = new WeakSet();

    function _guessExecutionStatusRelativeToDifferentFunctions(target) {
      if (
        !target.isFunctionDeclaration() ||
        target.parentPath.isExportDeclaration()
      ) {
        return 'unknown';
      }

      const binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return 'before';
      const referencePaths = binding.referencePaths;
      let allStatus;

      for (const path of referencePaths) {
        const childOfFunction = !!path.find(
          (path) => path.node === target.node,
        );
        if (childOfFunction) continue;

        if (path.key !== 'callee' || !path.parentPath.isCallExpression()) {
          return 'unknown';
        }

        if (executionOrderCheckedNodes.has(path.node)) continue;
        executionOrderCheckedNodes.add(path.node);

        const status = this._guessExecutionStatusRelativeTo(path);

        executionOrderCheckedNodes.delete(path.node);

        if (allStatus && allStatus !== status) {
          return 'unknown';
        } else {
          allStatus = status;
        }
      }

      return allStatus;
    }

    function resolve(dangerous, resolved) {
      return this._resolve(dangerous, resolved) || this;
    }

    function _resolve(dangerous, resolved) {
      if (resolved && resolved.indexOf(this) >= 0) return;
      resolved = resolved || [];
      resolved.push(this);

      if (this.isVariableDeclarator()) {
        if (this.get('id').isIdentifier()) {
          return this.get('init').resolve(dangerous, resolved);
        }
      } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return;
        if (!binding.constant) return;
        if (binding.kind === 'module') return;

        if (binding.path !== this) {
          const ret = binding.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret.node)) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get('expression').resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!t.isLiteral(targetKey)) return;
        const targetName = targetKey.value;
        const target = this.get('object').resolve(dangerous, resolved);

        if (target.isObjectExpression()) {
          const props = target.get('properties');

          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key = prop.get('key');
            let match =
              prop.isnt('computed') &&
              key.isIdentifier({
                name: targetName,
              });
            match =
              match ||
              key.isLiteral({
                value: targetName,
              });
            if (match) return prop.get('value').resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get('elements');
          const elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }

    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return false;
        return binding.constant;
      }

      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }

        if (this.isTemplateLiteral()) {
          return this.get('expressions').every((expression) =>
            expression.isConstantExpression(),
          );
        }

        return true;
      }

      if (this.isUnaryExpression()) {
        if (this.node.operator !== 'void') {
          return false;
        }

        return this.get('argument').isConstantExpression();
      }

      if (this.isBinaryExpression()) {
        return (
          this.get('left').isConstantExpression() &&
          this.get('right').isConstantExpression()
        );
      }

      return false;
    }

    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path) => {
        if (
          path.isProgram({
            sourceType: 'module',
          })
        )
          return true;
        if (path.isClass()) return true;
        if (!path.isProgram() && !path.isFunction()) return false;

        if (
          path.isArrowFunctionExpression() &&
          !path.get('body').isBlockStatement()
        ) {
          return false;
        }

        const body = path.isFunction() ? path.node.body : path.node;

        for (const directive of body.directives) {
          if (directive.value.value === 'use strict') {
            return true;
          }
        }
      });
      return !!strictParent;
    }
  });

  var context_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.call = call;
    exports._call = _call;
    exports.isBlacklisted = exports.isDenylisted = isDenylisted;
    exports.visit = visit;
    exports.skip = skip;
    exports.skipKey = skipKey;
    exports.stop = stop;
    exports.setScope = setScope;
    exports.setContext = setContext;
    exports.resync = resync;
    exports._resyncParent = _resyncParent;
    exports._resyncKey = _resyncKey;
    exports._resyncList = _resyncList;
    exports._resyncRemoved = _resyncRemoved;
    exports.popContext = popContext;
    exports.pushContext = pushContext;
    exports.setup = setup;
    exports.setKey = setKey;
    exports.requeue = requeue;
    exports._getQueueContexts = _getQueueContexts;

    var _index = _interopRequireDefault(lib$a);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    function call(key) {
      const opts = this.opts;
      this.debug(key);

      if (this.node) {
        if (this._call(opts[key])) return true;
      }

      if (this.node) {
        return this._call(opts[this.node.type] && opts[this.node.type][key]);
      }

      return false;
    }

    function _call(fns) {
      if (!fns) return false;

      for (const fn of fns) {
        if (!fn) continue;
        const node = this.node;
        if (!node) return true;
        const ret = fn.call(this.state, this, this.state);

        if (ret && typeof ret === 'object' && typeof ret.then === 'function') {
          throw new Error(
            `You appear to be using a plugin with an async traversal visitor, ` +
              `which your current version of Babel does not support. ` +
              `If you're using a published plugin, you may need to upgrade ` +
              `your @babel/core version.`,
          );
        }

        if (ret) {
          throw new Error(`Unexpected return value from visitor method ${fn}`);
        }

        if (this.node !== node) return true;
        if (this._traverseFlags > 0) return true;
      }

      return false;
    }

    function isDenylisted() {
      var _this$opts$denylist;

      const denylist =
        (_this$opts$denylist = this.opts.denylist) != null
          ? _this$opts$denylist
          : this.opts.blacklist;
      return denylist && denylist.indexOf(this.node.type) > -1;
    }

    function visit() {
      if (!this.node) {
        return false;
      }

      if (this.isDenylisted()) {
        return false;
      }

      if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
        return false;
      }

      if (this.shouldSkip || this.call('enter') || this.shouldSkip) {
        this.debug('Skip...');
        return this.shouldStop;
      }

      this.debug('Recursing into...');

      lib$a.default.node(
        this.node,
        this.opts,
        this.scope,
        this.state,
        this,
        this.skipKeys,
      );

      this.call('exit');
      return this.shouldStop;
    }

    function skip() {
      this.shouldSkip = true;
    }

    function skipKey(key) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }

      this.skipKeys[key] = true;
    }

    function stop() {
      this._traverseFlags |= path.SHOULD_SKIP | path.SHOULD_STOP;
    }

    function setScope() {
      if (this.opts && this.opts.noScope) return;
      let path = this.parentPath;
      if (this.key === 'key' && path.isMethod()) path = path.parentPath;
      let target;

      while (path && !target) {
        if (path.opts && path.opts.noScope) return;
        target = path.scope;
        path = path.parentPath;
      }

      this.scope = this.getScope(target);
      if (this.scope) this.scope.init();
    }

    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }

      this._traverseFlags = 0;

      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }

      this.setScope();
      return this;
    }

    function resync() {
      if (this.removed) return;

      this._resyncParent();

      this._resyncList();

      this._resyncKey();
    }

    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }

    function _resyncKey() {
      if (!this.container) return;
      if (this.node === this.container[this.key]) return;

      if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            return this.setKey(i);
          }
        }
      } else {
        for (const key of Object.keys(this.container)) {
          if (this.container[key] === this.node) {
            return this.setKey(key);
          }
        }
      }

      this.key = null;
    }

    function _resyncList() {
      if (!this.parent || !this.inList) return;
      const newContainer = this.parent[this.listKey];
      if (this.container === newContainer) return;
      this.container = newContainer || null;
    }

    function _resyncRemoved() {
      if (
        this.key == null ||
        !this.container ||
        this.container[this.key] !== this.node
      ) {
        this._markRemoved();
      }
    }

    function popContext() {
      this.contexts.pop();

      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(undefined);
      }
    }

    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }

    function setup(parentPath, container, listKey, key) {
      this.listKey = listKey;
      this.container = container;
      this.parentPath = parentPath || this.parentPath;
      this.setKey(key);
    }

    function setKey(key) {
      var _this$node;

      this.key = key;
      this.node = this.container[this.key];
      this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
    }

    function requeue(pathToQueue = this) {
      if (pathToQueue.removed) return;
      const contexts = this.contexts;

      for (const context of contexts) {
        context.maybeQueue(pathToQueue);
      }
    }

    function _getQueueContexts() {
      let path = this;
      let contexts = this.contexts;

      while (!contexts.length) {
        path = path.parentPath;
        if (!path) break;
        contexts = path.contexts;
      }

      return contexts;
    }
  });

  var removalHooks = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.hooks = void 0;
    const hooks = [
      function (self, parent) {
        const removeParent =
          (self.key === 'test' &&
            (parent.isWhile() || parent.isSwitchCase())) ||
          (self.key === 'declaration' && parent.isExportDeclaration()) ||
          (self.key === 'body' && parent.isLabeledStatement()) ||
          (self.listKey === 'declarations' &&
            parent.isVariableDeclaration() &&
            parent.node.declarations.length === 1) ||
          (self.key === 'expression' && parent.isExpressionStatement());

        if (removeParent) {
          parent.remove();
          return true;
        }
      },
      function (self, parent) {
        if (
          parent.isSequenceExpression() &&
          parent.node.expressions.length === 1
        ) {
          parent.replaceWith(parent.node.expressions[0]);
          return true;
        }
      },
      function (self, parent) {
        if (parent.isBinary()) {
          if (self.key === 'left') {
            parent.replaceWith(parent.node.right);
          } else {
            parent.replaceWith(parent.node.left);
          }

          return true;
        }
      },
      function (self, parent) {
        if (
          (parent.isIfStatement() &&
            (self.key === 'consequent' || self.key === 'alternate')) ||
          (self.key === 'body' &&
            (parent.isLoop() || parent.isArrowFunctionExpression()))
        ) {
          self.replaceWith({
            type: 'BlockStatement',
            body: [],
          });
          return true;
        }
      },
    ];
    exports.hooks = hooks;
  });

  var remove_1 = remove;
  var _removeFromScope_1 = _removeFromScope;
  var _callRemovalHooks_1 = _callRemovalHooks;
  var _remove_1 = _remove;
  var _markRemoved_1 = _markRemoved;
  var _assertUnremoved_1 = _assertUnremoved;

  var _index$1 = _interopRequireWildcard$l(path);

  function _getRequireWildcardCache$l() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$l = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$l(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$l();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function remove() {
    var _this$opts;

    this._assertUnremoved();

    this.resync();

    if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
      this._removeFromScope();
    }

    if (this._callRemovalHooks()) {
      this._markRemoved();

      return;
    }

    this.shareCommentsWithSiblings();

    this._remove();

    this._markRemoved();
  }

  function _removeFromScope() {
    const bindings = this.getBindingIdentifiers();
    Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
  }

  function _callRemovalHooks() {
    for (const fn of removalHooks.hooks) {
      if (fn(this, this.parentPath)) return true;
    }
  }

  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      this.updateSiblingKeys(this.key, -1);
    } else {
      this._replaceWith(null);
    }
  }

  function _markRemoved() {
    this._traverseFlags |= _index$1.SHOULD_SKIP | _index$1.REMOVED;
    if (this.parent) cache.path.get(this.parent).delete(this.node);
    this.node = null;
  }

  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError(
        'NodePath has been removed so is read-only.',
      );
    }
  }

  var removal = /*#__PURE__*/ Object.defineProperty(
    {
      remove: remove_1,
      _removeFromScope: _removeFromScope_1,
      _callRemovalHooks: _callRemovalHooks_1,
      _remove: _remove_1,
      _markRemoved: _markRemoved_1,
      _assertUnremoved: _assertUnremoved_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var hoister = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    const referenceVisitor = {
      ReferencedIdentifier(path, state) {
        if (
          path.isJSXIdentifier() &&
          t.react.isCompatTag(path.node.name) &&
          !path.parentPath.isJSXMemberExpression()
        ) {
          return;
        }

        if (path.node.name === 'this') {
          let scope = path.scope;

          do {
            if (
              scope.path.isFunction() &&
              !scope.path.isArrowFunctionExpression()
            ) {
              break;
            }
          } while ((scope = scope.parent));

          if (scope) state.breakOnScopePaths.push(scope.path);
        }

        const binding = path.scope.getBinding(path.node.name);
        if (!binding) return;

        for (const violation of binding.constantViolations) {
          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path.stop();
            return;
          }
        }

        if (binding !== state.scope.getBinding(path.node.name)) return;
        state.bindings[path.node.name] = binding;
      },
    };

    class PathHoister {
      constructor(path, scope) {
        this.breakOnScopePaths = void 0;
        this.bindings = void 0;
        this.mutableBinding = void 0;
        this.scopes = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.attachAfter = void 0;
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope;
        this.path = path;
        this.attachAfter = false;
      }

      isCompatibleScope(scope) {
        for (const key of Object.keys(this.bindings)) {
          const binding = this.bindings[key];

          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }

        return true;
      }

      getCompatibleScopes() {
        let scope = this.path.scope;

        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }

          if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
            break;
          }
        } while ((scope = scope.parent));
      }

      getAttachmentPath() {
        let path = this._getAttachmentPath();

        if (!path) return;
        let targetScope = path.scope;

        if (targetScope.path === path) {
          targetScope = path.scope.parent;
        }

        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (const name of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name)) continue;
            const binding = this.bindings[name];

            if (
              binding.kind === 'param' ||
              binding.path.parentKey === 'params'
            ) {
              continue;
            }

            const bindingParentPath = this.getAttachmentParentForPath(
              binding.path,
            );

            if (bindingParentPath.key >= path.key) {
              this.attachAfter = true;
              path = binding.path;

              for (const violationPath of binding.constantViolations) {
                if (
                  this.getAttachmentParentForPath(violationPath).key > path.key
                ) {
                  path = violationPath;
                }
              }
            }
          }
        }

        return path;
      }

      _getAttachmentPath() {
        const scopes = this.scopes;
        const scope = scopes.pop();
        if (!scope) return;

        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope) return;
            const bodies = scope.path.get('body').get('body');

            for (let i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist) continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }

      getNextScopeAttachmentParent() {
        const scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      }

      getAttachmentParentForPath(path) {
        do {
          if (
            !path.parentPath ||
            (Array.isArray(path.container) && path.isStatement())
          ) {
            return path;
          }
        } while ((path = path.parentPath));
      }

      hasOwnParamBindings(scope) {
        for (const name of Object.keys(this.bindings)) {
          if (!scope.hasOwnBinding(name)) continue;
          const binding = this.bindings[name];
          if (binding.kind === 'param' && binding.constant) return true;
        }

        return false;
      }

      run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding) return;
        this.getCompatibleScopes();
        const attachTo = this.getAttachmentPath();
        if (!attachTo) return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent())
          return;
        let uid = attachTo.scope.generateUidIdentifier('ref');
        const declarator = t.variableDeclarator(uid, this.path.node);
        const insertFn = this.attachAfter ? 'insertAfter' : 'insertBefore';
        const [attached] = attachTo[insertFn]([
          attachTo.isVariableDeclarator()
            ? declarator
            : t.variableDeclaration('var', [declarator]),
        ]);
        const parent = this.path.parentPath;

        if (
          parent.isJSXElement() &&
          this.path.container === parent.node.children
        ) {
          uid = t.jsxExpressionContainer(uid);
        }

        this.path.replaceWith(t.cloneNode(uid));
        return attachTo.isVariableDeclarator()
          ? attached.get('init')
          : attached.get('declarations.0.init');
      }
    }

    exports.default = PathHoister;
  });

  var insertBefore_1 = insertBefore;
  var _containerInsert_1 = _containerInsert;
  var _containerInsertBefore_1 = _containerInsertBefore;
  var _containerInsertAfter_1 = _containerInsertAfter;
  var insertAfter_1 = insertAfter;
  var updateSiblingKeys_1 = updateSiblingKeys;
  var _verifyNodeList_1 = _verifyNodeList;
  var unshiftContainer_1 = unshiftContainer;
  var pushContainer_1 = pushContainer;
  var hoist_1 = hoist;

  var _hoister = _interopRequireDefault$B(hoister);

  var _index$2 = _interopRequireDefault$B(path);

  var t$c = _interopRequireWildcard$m(lib$2);

  function _getRequireWildcardCache$m() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$m = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$m(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$m();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _interopRequireDefault$B(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  function insertBefore(nodes_) {
    this._assertUnremoved();

    const nodes = this._verifyNodeList(nodes_);

    const {parentPath} = this;

    if (
      parentPath.isExpressionStatement() ||
      parentPath.isLabeledStatement() ||
      parentPath.isExportNamedDeclaration() ||
      (parentPath.isExportDefaultDeclaration() && this.isDeclaration())
    ) {
      return parentPath.insertBefore(nodes);
    } else if (
      (this.isNodeType('Expression') && !this.isJSXElement()) ||
      (parentPath.isForStatement() && this.key === 'init')
    ) {
      if (this.node) nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      const node = this.node;
      const shouldInsertCurrentNode =
        node && (!this.isExpressionStatement() || node.expression != null);
      this.replaceWith(
        t$c.blockStatement(shouldInsertCurrentNode ? [node] : []),
      );
      return this.unshiftContainer('body', nodes);
    } else {
      throw new Error(
        "We don't know what to do with this node type. " +
          "We were previously a Statement but we can't fit in here?",
      );
    }
  }

  function _containerInsert(from, nodes) {
    this.updateSiblingKeys(from, nodes.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes);

    for (let i = 0; i < nodes.length; i++) {
      const to = from + i;
      const path = this.getSibling(to);
      paths.push(path);

      if (this.context && this.context.queue) {
        path.pushContext(this.context);
      }
    }

    const contexts = this._getQueueContexts();

    for (const path of paths) {
      path.setScope();
      path.debug('Inserted.');

      for (const context of contexts) {
        context.maybeQueue(path, true);
      }
    }

    return paths;
  }

  function _containerInsertBefore(nodes) {
    return this._containerInsert(this.key, nodes);
  }

  function _containerInsertAfter(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  }

  function insertAfter(nodes_) {
    this._assertUnremoved();

    const nodes = this._verifyNodeList(nodes_);

    const {parentPath} = this;

    if (
      parentPath.isExpressionStatement() ||
      parentPath.isLabeledStatement() ||
      parentPath.isExportNamedDeclaration() ||
      (parentPath.isExportDefaultDeclaration() && this.isDeclaration())
    ) {
      return parentPath.insertAfter(
        nodes.map((node) => {
          return t$c.isExpression(node) ? t$c.expressionStatement(node) : node;
        }),
      );
    } else if (
      (this.isNodeType('Expression') &&
        !this.isJSXElement() &&
        !parentPath.isJSXElement()) ||
      (parentPath.isForStatement() && this.key === 'init')
    ) {
      if (this.node) {
        const node = this.node;
        let {scope} = this;

        if (scope.path.isPattern()) {
          t$c.assertExpression(node);
          this.replaceWith(
            t$c.callExpression(t$c.arrowFunctionExpression([], node), []),
          );
          this.get('callee.body').insertAfter(nodes);
          return [this];
        }

        if (
          parentPath.isMethod({
            computed: true,
            key: node,
          })
        ) {
          scope = scope.parent;
        }

        const temp = scope.generateDeclaredUidIdentifier();
        nodes.unshift(
          t$c.expressionStatement(
            t$c.assignmentExpression('=', t$c.cloneNode(temp), node),
          ),
        );
        nodes.push(t$c.expressionStatement(t$c.cloneNode(temp)));
      }

      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      const node = this.node;
      const shouldInsertCurrentNode =
        node && (!this.isExpressionStatement() || node.expression != null);
      this.replaceWith(
        t$c.blockStatement(shouldInsertCurrentNode ? [node] : []),
      );
      return this.pushContainer('body', nodes);
    } else {
      throw new Error(
        "We don't know what to do with this node type. " +
          "We were previously a Statement but we can't fit in here?",
      );
    }
  }

  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent) return;

    const paths = cache.path.get(this.parent);

    for (const [, path] of paths) {
      if (path.key >= fromIndex) {
        path.key += incrementBy;
      }
    }
  }

  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }

    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      let msg;

      if (!node) {
        msg = 'has falsy node';
      } else if (typeof node !== 'object') {
        msg = 'contains a non-object node';
      } else if (!node.type) {
        msg = 'without a type';
      } else if (node instanceof _index$2.default) {
        msg = 'has a NodePath when it expected a raw object';
      }

      if (msg) {
        const type = Array.isArray(node) ? 'array' : typeof node;
        throw new Error(
          `Node list ${msg} with the index of ${i} and type of ${type}`,
        );
      }
    }

    return nodes;
  }

  function unshiftContainer(listKey, nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);

    const path = _index$2.default
      .get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0,
      })
      .setContext(this.context);

    return path._containerInsertBefore(nodes);
  }

  function pushContainer(listKey, nodes) {
    this._assertUnremoved();

    const verifiedNodes = this._verifyNodeList(nodes);

    const container = this.node[listKey];

    const path = _index$2.default
      .get({
        parentPath: this,
        parent: this.node,
        container: container,
        listKey,
        key: container.length,
      })
      .setContext(this.context);

    return path.replaceWithMultiple(verifiedNodes);
  }

  function hoist(scope = this.scope) {
    const hoister = new _hoister.default(this, scope);
    return hoister.run();
  }

  var modification = /*#__PURE__*/ Object.defineProperty(
    {
      insertBefore: insertBefore_1,
      _containerInsert: _containerInsert_1,
      _containerInsertBefore: _containerInsertBefore_1,
      _containerInsertAfter: _containerInsertAfter_1,
      insertAfter: insertAfter_1,
      updateSiblingKeys: updateSiblingKeys_1,
      _verifyNodeList: _verifyNodeList_1,
      unshiftContainer: unshiftContainer_1,
      pushContainer: pushContainer_1,
      hoist: hoist_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var getOpposite_1 = getOpposite;
  var getCompletionRecords_1 = getCompletionRecords;
  var getSibling_1 = getSibling;
  var getPrevSibling_1 = getPrevSibling;
  var getNextSibling_1 = getNextSibling;
  var getAllNextSiblings_1 = getAllNextSiblings;
  var getAllPrevSiblings_1 = getAllPrevSiblings;
  var get_1 = get;
  var _getKey_1 = _getKey;
  var _getPattern_1 = _getPattern;
  var getBindingIdentifiers_1$1 = getBindingIdentifiers$1;
  var getOuterBindingIdentifiers_1$1 = getOuterBindingIdentifiers;
  var getBindingIdentifierPaths_1 = getBindingIdentifierPaths;
  var getOuterBindingIdentifierPaths_1 = getOuterBindingIdentifierPaths;

  var _index$3 = _interopRequireDefault$C(path);

  var t$d = _interopRequireWildcard$n(lib$2);

  function _getRequireWildcardCache$n() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$n = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$n(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$n();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _interopRequireDefault$C(obj) {
    return obj && obj.__esModule
      ? obj
      : {
          default: obj,
        };
  }

  const NORMAL_COMPLETION = 0;
  const BREAK_COMPLETION = 1;

  function NormalCompletion(path) {
    return {
      type: NORMAL_COMPLETION,
      path,
    };
  }

  function BreakCompletion(path) {
    return {
      type: BREAK_COMPLETION,
      path,
    };
  }

  function getOpposite() {
    if (this.key === 'left') {
      return this.getSibling('right');
    } else if (this.key === 'right') {
      return this.getSibling('left');
    }

    return null;
  }

  function addCompletionRecords(path, records, context) {
    if (path) return records.concat(_getCompletionRecords(path, context));
    return records;
  }

  function completionRecordForSwitch(cases, records, context) {
    let lastNormalCompletions = [];

    for (let i = 0; i < cases.length; i++) {
      const casePath = cases[i];

      const caseCompletions = _getCompletionRecords(casePath, context);

      const normalCompletions = [];
      const breakCompletions = [];

      for (const c of caseCompletions) {
        if (c.type === NORMAL_COMPLETION) {
          normalCompletions.push(c);
        }

        if (c.type === BREAK_COMPLETION) {
          breakCompletions.push(c);
        }
      }

      if (normalCompletions.length) {
        lastNormalCompletions = normalCompletions;
      }

      records = records.concat(breakCompletions);
    }

    records = records.concat(lastNormalCompletions);
    return records;
  }

  function normalCompletionToBreak(completions) {
    completions.forEach((c) => {
      c.type = BREAK_COMPLETION;
    });
  }

  function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach((c) => {
      if (
        c.path.isBreakStatement({
          label: null,
        })
      ) {
        if (reachable) {
          c.path.replaceWith(
            t$d.unaryExpression('void', t$d.numericLiteral(0)),
          );
        } else {
          c.path.remove();
        }
      }
    });
  }

  function getStatementListCompletion(paths, context) {
    let completions = [];

    if (context.canHaveBreak) {
      let lastNormalCompletions = [];

      for (let i = 0; i < paths.length; i++) {
        const path = paths[i];
        const newContext = Object.assign({}, context, {
          inCaseClause: false,
        });

        if (
          path.isBlockStatement() &&
          (context.inCaseClause || context.shouldPopulateBreak)
        ) {
          newContext.shouldPopulateBreak = true;
        } else {
          newContext.shouldPopulateBreak = false;
        }

        const statementCompletions = _getCompletionRecords(path, newContext);

        if (
          statementCompletions.length > 0 &&
          statementCompletions.every((c) => c.type === BREAK_COMPLETION)
        ) {
          if (
            lastNormalCompletions.length > 0 &&
            statementCompletions.every((c) =>
              c.path.isBreakStatement({
                label: null,
              }),
            )
          ) {
            normalCompletionToBreak(lastNormalCompletions);
            completions = completions.concat(lastNormalCompletions);

            if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
              completions = completions.concat(statementCompletions);
              replaceBreakStatementInBreakCompletion(
                statementCompletions,
                true,
              );
            }

            replaceBreakStatementInBreakCompletion(statementCompletions, false);
          } else {
            completions = completions.concat(statementCompletions);

            if (!context.shouldPopulateBreak) {
              replaceBreakStatementInBreakCompletion(
                statementCompletions,
                true,
              );
            }
          }

          break;
        }

        if (i === paths.length - 1) {
          completions = completions.concat(statementCompletions);
        } else {
          completions = completions.concat(
            statementCompletions.filter((c) => c.type === BREAK_COMPLETION),
          );
          lastNormalCompletions = statementCompletions.filter(
            (c) => c.type === NORMAL_COMPLETION,
          );
        }
      }
    } else if (paths.length) {
      completions = completions.concat(
        _getCompletionRecords(paths[paths.length - 1], context),
      );
    }

    return completions;
  }

  function _getCompletionRecords(path, context) {
    let records = [];

    if (path.isIfStatement()) {
      records = addCompletionRecords(path.get('consequent'), records, context);
      records = addCompletionRecords(path.get('alternate'), records, context);
    } else if (
      path.isDoExpression() ||
      path.isFor() ||
      path.isWhile() ||
      path.isLabeledStatement()
    ) {
      records = addCompletionRecords(path.get('body'), records, context);
    } else if (path.isProgram() || path.isBlockStatement()) {
      records = records.concat(
        getStatementListCompletion(path.get('body'), context),
      );
    } else if (path.isFunction()) {
      return _getCompletionRecords(path.get('body'), context);
    } else if (path.isTryStatement()) {
      records = addCompletionRecords(path.get('block'), records, context);
      records = addCompletionRecords(path.get('handler'), records, context);
    } else if (path.isCatchClause()) {
      records = addCompletionRecords(path.get('body'), records, context);
    } else if (path.isSwitchStatement()) {
      records = completionRecordForSwitch(path.get('cases'), records, context);
    } else if (path.isSwitchCase()) {
      records = records.concat(
        getStatementListCompletion(path.get('consequent'), {
          canHaveBreak: true,
          shouldPopulateBreak: false,
          inCaseClause: true,
        }),
      );
    } else if (path.isBreakStatement()) {
      records.push(BreakCompletion(path));
    } else {
      records.push(NormalCompletion(path));
    }

    return records;
  }

  function getCompletionRecords() {
    const records = _getCompletionRecords(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false,
    });

    return records.map((r) => r.path);
  }

  function getSibling(key) {
    return path
      .get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key: key,
      })
      .setContext(this.context);
  }

  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }

  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }

  function getAllNextSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(++_key);
    const siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }

    return siblings;
  }

  function getAllPrevSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(--_key);
    const siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }

    return siblings;
  }

  function get(key, context = true) {
    if (context === true) context = this.context;
    const parts = key.split('.');

    if (parts.length === 1) {
      return this._getKey(key, context);
    } else {
      return this._getPattern(parts, context);
    }
  }

  function _getKey(key, context) {
    const node = this.node;
    const container = node[key];

    if (Array.isArray(container)) {
      return container.map((_, i) => {
        return path.default
          .get({
            listKey: key,
            parentPath: this,
            parent: node,
            container: container,
            key: i,
          })
          .setContext(context);
      });
    } else {
      return path.default
        .get({
          parentPath: this,
          parent: node,
          container: node,
          key: key,
        })
        .setContext(context);
    }
  }

  function _getPattern(parts, context) {
    let path = this;

    for (const part of parts) {
      if (part === '.') {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }

    return path;
  }

  function getBindingIdentifiers$1(duplicates) {
    return t$d.getBindingIdentifiers(this.node, duplicates);
  }

  function getOuterBindingIdentifiers(duplicates) {
    return t$d.getOuterBindingIdentifiers(this.node, duplicates);
  }

  function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
    const path = this;
    let search = [].concat(path);
    const ids = Object.create(null);

    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      const keys = t$d.getBindingIdentifiers.keys[id.node.type];

      if (id.isIdentifier()) {
        if (duplicates) {
          const _ids = (ids[id.node.name] = ids[id.node.name] || []);

          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }

        continue;
      }

      if (id.isExportDeclaration()) {
        const declaration = id.get('declaration');

        if (declaration.isDeclaration()) {
          search.push(declaration);
        }

        continue;
      }

      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get('id'));
          continue;
        }

        if (id.isFunctionExpression()) {
          continue;
        }
      }

      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const child = id.get(key);

          if (Array.isArray(child) || child.node) {
            search = search.concat(child);
          }
        }
      }
    }

    return ids;
  }

  function getOuterBindingIdentifierPaths(duplicates) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }

  var family = /*#__PURE__*/ Object.defineProperty(
    {
      getOpposite: getOpposite_1,
      getCompletionRecords: getCompletionRecords_1,
      getSibling: getSibling_1,
      getPrevSibling: getPrevSibling_1,
      getNextSibling: getNextSibling_1,
      getAllNextSiblings: getAllNextSiblings_1,
      getAllPrevSiblings: getAllPrevSiblings_1,
      get: get_1,
      _getKey: _getKey_1,
      _getPattern: _getPattern_1,
      getBindingIdentifiers: getBindingIdentifiers_1$1,
      getOuterBindingIdentifiers: getOuterBindingIdentifiers_1$1,
      getBindingIdentifierPaths: getBindingIdentifierPaths_1,
      getOuterBindingIdentifierPaths: getOuterBindingIdentifierPaths_1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var shareCommentsWithSiblings_1 = shareCommentsWithSiblings;
  var addComment_1$1 = addComment$1;
  var addComments_1$1 = addComments$1;

  var t$e = _interopRequireWildcard$o(lib$2);

  function _getRequireWildcardCache$o() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$o = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$o(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$o();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function shareCommentsWithSiblings() {
    if (typeof this.key === 'string') return;
    const node = this.node;
    if (!node) return;
    const trailing = node.trailingComments;
    const leading = node.leadingComments;
    if (!trailing && !leading) return;
    const prev = this.getSibling(this.key - 1);
    const next = this.getSibling(this.key + 1);
    const hasPrev = Boolean(prev.node);
    const hasNext = Boolean(next.node);

    if (hasPrev && !hasNext) {
      prev.addComments('trailing', trailing);
    } else if (hasNext && !hasPrev) {
      next.addComments('leading', leading);
    }
  }

  function addComment$1(type, content, line) {
    t$e.addComment(this.node, type, content, line);
  }

  function addComments$1(type, comments) {
    t$e.addComments(this.node, type, comments);
  }

  var comments = /*#__PURE__*/ Object.defineProperty(
    {
      shareCommentsWithSiblings: shareCommentsWithSiblings_1,
      addComment: addComment_1$1,
      addComments: addComments_1$1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  /**
   * Helpers.
   */
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var ms = function (val, options) {
    options = options || {};
    var type = typeof val;

    if (type === 'string' && val.length > 0) {
      return parse$2(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }

    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val),
    );
  };
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse$2(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str,
    );

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;

      case 'weeks':
      case 'week':
      case 'w':
        return n * w;

      case 'days':
      case 'day':
      case 'd':
        return n * d;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }

    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }

    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }

    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }

    return ms + 'ms';
  }
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }

    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }

    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }

    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }

    return ms + ' ms';
  }
  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms;
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    /**
     * The currently active debug mode names, and names to skip.
     */

    createDebug.names = [];
    createDebug.skips = [];
    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    createDebug.formatters = {};
    /**
     * Selects a color for a debug namespace
     * @param {String} namespace The namespace string for the for the debug instance to be colored
     * @return {Number|String} An ANSI color code for the given namespace
     * @api private
     */

    function selectColor(namespace) {
      let hash = 0;

      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }

    createDebug.selectColor = selectColor;
    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;

      function debug(...args) {
        // Disabled?
        if (!debug.enabled) {
          return;
        }

        const self = debug; // Set `diff` timestamp

        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        } // Apply any `formatters` transformations

        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return '%';
          }

          index++;
          const formatter = createDebug.formatters[format];

          if (typeof formatter === 'function') {
            const val = args[index];
            match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

            args.splice(index, 1);
            index--;
          }

          return match;
        }); // Apply env-specific formatting (colors, etc.)

        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: () =>
          enableOverride === null
            ? createDebug.enabled(namespace)
            : enableOverride,
        set: (v) => {
          enableOverride = v;
        },
      }); // Env-specific initialization logic for debug instances

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }

      return debug;
    }

    function extend(namespace, delimiter) {
      const newDebug = createDebug(
        this.namespace +
          (typeof delimiter === 'undefined' ? ':' : delimiter) +
          namespace,
      );
      newDebug.log = this.log;
      return newDebug;
    }
    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === 'string' ? namespaces : '').split(
        /[\s,]+/,
      );
      const len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          // ignore empty strings
          continue;
        }

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    /**
     * Disable debug output.
     *
     * @return {String} namespaces
     * @api public
     */

    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips
          .map(toNamespace)
          .map((namespace) => '-' + namespace),
      ].join(',');
      createDebug.enable('');
      return namespaces;
    }
    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }

      let i;
      let len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }
    /**
     * Convert regexp to namespace
     *
     * @param {RegExp} regxep
     * @return {String} namespace
     * @api private
     */

    function toNamespace(regexp) {
      return regexp
        .toString()
        .substring(2, regexp.toString().length - 2)
        .replace(/\.\*\?$/, '*');
    }
    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }

      return val;
    }
    /**
     * XXX DO NOT USE. This is a temporary stub function.
     * XXX It WILL be removed in the next major release.
     */

    function destroy() {
      console.warn(
        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
      );
    }

    createDebug.enable(createDebug.load());
    return createDebug;
  }

  var common = setup;

  var browser$3 = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     */
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();

    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn(
            'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
          );
        }
      };
    })();
    /**
     * Colors.
     */

    exports.colors = [
      '#0000CC',
      '#0000FF',
      '#0033CC',
      '#0033FF',
      '#0066CC',
      '#0066FF',
      '#0099CC',
      '#0099FF',
      '#00CC00',
      '#00CC33',
      '#00CC66',
      '#00CC99',
      '#00CCCC',
      '#00CCFF',
      '#3300CC',
      '#3300FF',
      '#3333CC',
      '#3333FF',
      '#3366CC',
      '#3366FF',
      '#3399CC',
      '#3399FF',
      '#33CC00',
      '#33CC33',
      '#33CC66',
      '#33CC99',
      '#33CCCC',
      '#33CCFF',
      '#6600CC',
      '#6600FF',
      '#6633CC',
      '#6633FF',
      '#66CC00',
      '#66CC33',
      '#9900CC',
      '#9900FF',
      '#9933CC',
      '#9933FF',
      '#99CC00',
      '#99CC33',
      '#CC0000',
      '#CC0033',
      '#CC0066',
      '#CC0099',
      '#CC00CC',
      '#CC00FF',
      '#CC3300',
      '#CC3333',
      '#CC3366',
      '#CC3399',
      '#CC33CC',
      '#CC33FF',
      '#CC6600',
      '#CC6633',
      '#CC9900',
      '#CC9933',
      '#CCCC00',
      '#CCCC33',
      '#FF0000',
      '#FF0033',
      '#FF0066',
      '#FF0099',
      '#FF00CC',
      '#FF00FF',
      '#FF3300',
      '#FF3333',
      '#FF3366',
      '#FF3399',
      '#FF33CC',
      '#FF33FF',
      '#FF6600',
      '#FF6633',
      '#FF9900',
      '#FF9933',
      '#FFCC00',
      '#FFCC33',
    ];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    // eslint-disable-next-line complexity

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (
        typeof window !== 'undefined' &&
        window.process &&
        (window.process.type === 'renderer' || window.process.__nwjs)
      ) {
        return true;
      } // Internet Explorer and Edge do not support colors.

      if (
        typeof navigator !== 'undefined' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ) {
        return false;
      } // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632

      return (
        (typeof document !== 'undefined' &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== 'undefined' &&
          window.console &&
          (window.console.firebug ||
            (window.console.exception && window.console.table))) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== 'undefined' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
          parseInt(RegExp.$1, 10) >= 31) || // Double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== 'undefined' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      );
    }
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        args[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      const c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === '%%') {
          return;
        }

        index++;

        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.debug()` when available.
     * No-op when `console.debug` is not a "function".
     * If `console.debug` is not available, falls back
     * to `console.log`.
     *
     * @api public
     */

    exports.log = console.debug || console.log || (() => {});
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      let r;

      try {
        r = exports.storage.getItem('debug');
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG

      if (!r && typeof browser$1 !== 'undefined' && 'env' in browser$1) {
        r = browser$1.env.DEBUG;
      }

      return r;
    }
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    module.exports = common(exports);
    const {formatters} = module.exports;
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  });

  // MIT lisence
  // from https://github.com/substack/tty-browserify/blob/1ba769a6429d242f36226538835b4034bf6b7886/index.js
  function isatty() {
    return false;
  }
  function ReadStream() {
    throw new Error('tty.ReadStream is not implemented');
  }
  function WriteStream() {
    throw new Error('tty.ReadStream is not implemented');
  }
  var tty = {
    isatty: isatty,
    ReadStream: ReadStream,
    WriteStream: WriteStream,
  };

  var tty$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    isatty: isatty,
    ReadStream: ReadStream,
    WriteStream: WriteStream,
    default: tty,
  });

  var inherits$1;

  if (typeof Object.create === 'function') {
    inherits$1 = function inherits(ctor, superCtor) {
      // implementation from standard node.js 'util' module
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true,
        },
      });
    };
  } else {
    inherits$1 = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }

  var inherits$2 = inherits$1;

  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString$1(f)) {
      var objects = [];

      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }

      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') return '%';
      if (i >= len) return x;

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

        default:
          return x;
      }
    });

    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject$1(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }

    return str;
  }
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.

  function deprecate(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global$1.process)) {
      return function () {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    if (browser$1.noDeprecation === true) {
      return fn;
    }

    var warned = false;

    function deprecated() {
      if (!warned) {
        if (browser$1.throwDeprecation) {
          throw new Error(msg);
        } else if (browser$1.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }

        warned = true;
      }

      return fn.apply(this, arguments);
    }

    return deprecated;
  }
  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = browser$1.env.NODE_DEBUG || '';
    set = set.toUpperCase();

    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;

        debugs[set] = function () {
          var msg = format.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function () {};
      }
    }

    return debugs[set];
  }
  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */

  /* legacy: obj, showHidden, depth, colors*/

  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor,
    }; // legacy...

    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];

    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      _extend(ctx, opts);
    } // set default options

    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  } // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

  inspect.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39],
  }; // Don't use 'blue' not visible on cmd.exe

  inspect.styles = {
    special: 'cyan',
    number: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    date: 'magenta',
    // "name": intentionally not styling
    regexp: 'red',
  };

  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return (
        '\u001b[' +
        inspect.colors[style][0] +
        'm' +
        str +
        '\u001b[' +
        inspect.colors[style][1] +
        'm'
      );
    } else {
      return str;
    }
  }

  function stylizeNoColor(str, styleType) {
    return str;
  }

  function arrayToHash(array) {
    var hash = {};
    array.forEach(function (val, idx) {
      hash[val] = true;
    });
    return hash;
  }

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (
      ctx.customInspect &&
      value &&
      isFunction$2(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)
    ) {
      var ret = value.inspect(recurseTimes, ctx);

      if (!isString$1(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties

    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // Look up the keys of the object.

    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    } // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx

    if (
      isError(value) &&
      (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)
    ) {
      return formatError(value);
    } // Some type of object without properties can be shortcutted.

    if (keys.length === 0) {
      if (isFunction$2(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

    if (isArray$2(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions

    if (isFunction$2(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    } // Make RegExps say that they are RegExps

    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date

    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error

    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function (key) {
        return formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          array,
        );
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

    if (isString$1(value)) {
      var simple =
        "'" +
        JSON.stringify(value)
          .replace(/^"|"$/g, '')
          .replace(/'/g, "\\'")
          .replace(/\\"/g, '"') +
        "'";
      return ctx.stylize(simple, 'string');
    }

    if (isNumber$1(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

    if (isNull(value)) return ctx.stylize('null', 'null');
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty$1(value, String(i))) {
        output.push(
          formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true,
          ),
        );
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(
          formatProperty(ctx, value, recurseTimes, visibleKeys, key, true),
        );
      }
    });
    return output;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
      value: value[key],
    };

    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }

    if (!hasOwnProperty$1(visibleKeys, key)) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str
              .split('\n')
              .map(function (line) {
                return '  ' + line;
              })
              .join('\n')
              .substr(2);
          } else {
            str =
              '\n' +
              str
                .split('\n')
                .map(function (line) {
                  return '   ' + line;
                })
                .join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name
          .replace(/'/g, "\\'")
          .replace(/\\"/g, '"')
          .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      if (cur.indexOf('\n') >= 0);
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return (
        braces[0] +
        (base === '' ? '' : base + '\n ') +
        ' ' +
        output.join(',\n  ') +
        ' ' +
        braces[1]
      );
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  } // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.

  function isArray$2(ar) {
    return Array.isArray(ar);
  }
  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  function isNumber$1(arg) {
    return typeof arg === 'number';
  }
  function isString$1(arg) {
    return typeof arg === 'string';
  }
  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  function isRegExp(re) {
    return isObject$1(re) && objectToString(re) === '[object RegExp]';
  }
  function isObject$1(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isDate(d) {
    return isObject$1(d) && objectToString(d) === '[object Date]';
  }
  function isError(e) {
    return (
      isObject$1(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error)
    );
  }
  function isFunction$2(arg) {
    return typeof arg === 'function';
  }
  function isPrimitive(arg) {
    return (
      arg === null ||
      typeof arg === 'boolean' ||
      typeof arg === 'number' ||
      typeof arg === 'string' ||
      typeof arg === 'symbol' || // ES6 symbol
      typeof arg === 'undefined'
    );
  }
  function isBuffer$2(maybeBuf) {
    return Buffer.isBuffer(maybeBuf);
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }

  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }

  var months = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ]; // 26 Feb 16:19:34

  function timestamp() {
    var d = new Date();
    var time = [
      pad(d.getHours()),
      pad(d.getMinutes()),
      pad(d.getSeconds()),
    ].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  } // log is just a thin wrapper to console.log that prepends a timestamp

  function log() {
    console.log('%s - %s', timestamp(), format.apply(null, arguments));
  }
  function _extend(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject$1(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;

    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }

    return origin;
  }

  function hasOwnProperty$1(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var util$1 = {
    inherits: inherits$2,
    _extend: _extend,
    log: log,
    isBuffer: isBuffer$2,
    isPrimitive: isPrimitive,
    isFunction: isFunction$2,
    isError: isError,
    isDate: isDate,
    isObject: isObject$1,
    isRegExp: isRegExp,
    isUndefined: isUndefined,
    isSymbol: isSymbol,
    isString: isString$1,
    isNumber: isNumber$1,
    isNullOrUndefined: isNullOrUndefined,
    isNull: isNull,
    isBoolean: isBoolean,
    isArray: isArray$2,
    inspect: inspect,
    deprecate: deprecate,
    format: format,
    debuglog: debuglog,
  };

  var util$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    format: format,
    deprecate: deprecate,
    debuglog: debuglog,
    inspect: inspect,
    isArray: isArray$2,
    isBoolean: isBoolean,
    isNull: isNull,
    isNullOrUndefined: isNullOrUndefined,
    isNumber: isNumber$1,
    isString: isString$1,
    isSymbol: isSymbol,
    isUndefined: isUndefined,
    isRegExp: isRegExp,
    isObject: isObject$1,
    isDate: isDate,
    isError: isError,
    isFunction: isFunction$2,
    isPrimitive: isPrimitive,
    isBuffer: isBuffer$2,
    log: log,
    inherits: inherits$2,
    _extend: _extend,
    default: util$1,
  });

  var tty$2 = /*@__PURE__*/ getAugmentedNamespace(tty$1);

  var util$3 = /*@__PURE__*/ getAugmentedNamespace(util$2);

  var node$2 = createCommonjsModule(function (module, exports) {
    /**
     * This is the Node.js implementation of `debug()`.
     */
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util$3.deprecate(() => {},
    'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];

    try {
      // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
      // eslint-disable-next-line import/no-extraneous-dependencies
      const supportsColor = supportsColor_1;

      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221,
        ];
      }
    } catch (error) {
      // Swallow - we only care if `supports-color` is available; it doesn't have to be.
    }
    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(browser$1.env)
      .filter((key) => {
        return /^debug_/i.test(key);
      })
      .reduce((obj, key) => {
        // Camel-case
        const prop = key
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (_, k) => {
            return k.toUpperCase();
          }); // Coerce string value into JS value

        let val = browser$1.env[key];

        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === 'null') {
          val = null;
        } else {
          val = Number(val);
        }

        obj[prop] = val;
        return obj;
      }, {});
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts
        ? Boolean(exports.inspectOpts.colors)
        : tty$2.isatty(browser$1.stderr.fd);
    }
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      const {namespace: name, useColors} = this;

      if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(
          colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m',
        );
      } else {
        args[0] = getDate() + name + ' ' + args[0];
      }
    }

    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return '';
      }

      return new Date().toISOString() + ' ';
    }
    /**
     * Invokes `util.format()` with the specified arguments and writes to stderr.
     */

    function log(...args) {
      return browser$1.stderr.write(util$3.format(...args) + '\n');
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      if (namespaces) {
        browser$1.env.DEBUG = namespaces;
      } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete browser$1.env.DEBUG;
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return browser$1.env.DEBUG;
    }
    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);

      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }

    module.exports = common(exports);
    const {formatters} = module.exports;
    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util$3
        .inspect(v, this.inspectOpts)
        .split('\n')
        .map((str) => str.trim())
        .join(' ');
    };
    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util$3.inspect(v, this.inspectOpts);
    };
  });

  var src = createCommonjsModule(function (module) {
    if (
      typeof browser$1 === 'undefined' ||
      browser$1.type === 'renderer' ||
      browser$1.browser === true ||
      browser$1.__nwjs
    ) {
      module.exports = browser$3;
    } else {
      module.exports = node$2;
    }
  });

  var path = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;

    var virtualTypes$1 = _interopRequireWildcard(virtualTypes);

    var _index = _interopRequireDefault(lib$a);

    var _scope = _interopRequireDefault(scope);

    var t = _interopRequireWildcard(lib$2);

    var _generator = _interopRequireDefault(lib$4);

    var NodePath_ancestry = _interopRequireWildcard(ancestry_1);

    var NodePath_inference = _interopRequireWildcard(inference);

    var NodePath_replacement = _interopRequireWildcard(replacement);

    var NodePath_evaluation = _interopRequireWildcard(evaluation);

    var NodePath_conversion = _interopRequireWildcard(conversion);

    var NodePath_introspection = _interopRequireWildcard(introspection);

    var NodePath_context = _interopRequireWildcard(context_1);

    var NodePath_removal = _interopRequireWildcard(removal);

    var NodePath_modification = _interopRequireWildcard(modification);

    var NodePath_family = _interopRequireWildcard(family);

    var NodePath_comments = _interopRequireWildcard(comments);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    const debug = src('babel');
    const REMOVED = 1 << 0;
    exports.REMOVED = REMOVED;
    const SHOULD_STOP = 1 << 1;
    exports.SHOULD_STOP = SHOULD_STOP;
    const SHOULD_SKIP = 1 << 2;
    exports.SHOULD_SKIP = SHOULD_SKIP;

    class NodePath {
      constructor(hub, parent) {
        this.contexts = [];
        this.state = null;
        this.opts = null;
        this._traverseFlags = 0;
        this.skipKeys = null;
        this.parentPath = null;
        this.container = null;
        this.listKey = null;
        this.key = null;
        this.node = null;
        this.type = null;
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
      }

      static get({hub, parentPath, parent, container, listKey, key}) {
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }

        if (!parent) {
          throw new Error('To get a node path the parent needs to exist');
        }

        const targetNode = container[key];

        let paths = cache.path.get(parent);

        if (!paths) {
          paths = new Map();

          cache.path.set(parent, paths);
        }

        let path = paths.get(targetNode);

        if (!path) {
          path = new NodePath(hub, parent);
          if (targetNode) paths.set(targetNode, path);
        }

        path.setup(parentPath, container, listKey, key);
        return path;
      }

      getScope(scope) {
        return this.isScope() ? new _scope.default(this) : scope;
      }

      setData(key, val) {
        if (this.data == null) {
          this.data = Object.create(null);
        }

        return (this.data[key] = val);
      }

      getData(key, def) {
        if (this.data == null) {
          this.data = Object.create(null);
        }

        let val = this.data[key];
        if (val === undefined && def !== undefined) val = this.data[key] = def;
        return val;
      }

      buildCodeFrameError(msg, Error = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error);
      }

      traverse(visitor, state) {
        (0, lib$a.default)(this.node, visitor, this.scope, state, this);
      }

      set(key, node) {
        t.validate(this.node, key, node);
        this.node[key] = node;
      }

      getPathLocation() {
        const parts = [];
        let path = this;

        do {
          let key = path.key;
          if (path.inList) key = `${path.listKey}[${key}]`;
          parts.unshift(key);
        } while ((path = path.parentPath));

        return parts.join('.');
      }

      debug(message) {
        if (!debug.enabled) return;
        debug(`${this.getPathLocation()} ${this.type}: ${message}`);
      }

      toString() {
        return (0, _generator.default)(this.node).code;
      }

      get inList() {
        return !!this.listKey;
      }

      set inList(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }

      get parentKey() {
        return this.listKey || this.key;
      }

      get shouldSkip() {
        return !!(this._traverseFlags & SHOULD_SKIP);
      }

      set shouldSkip(v) {
        if (v) {
          this._traverseFlags |= SHOULD_SKIP;
        } else {
          this._traverseFlags &= ~SHOULD_SKIP;
        }
      }

      get shouldStop() {
        return !!(this._traverseFlags & SHOULD_STOP);
      }

      set shouldStop(v) {
        if (v) {
          this._traverseFlags |= SHOULD_STOP;
        } else {
          this._traverseFlags &= ~SHOULD_STOP;
        }
      }

      get removed() {
        return !!(this._traverseFlags & REMOVED);
      }

      set removed(v) {
        if (v) {
          this._traverseFlags |= REMOVED;
        } else {
          this._traverseFlags &= ~REMOVED;
        }
      }
    }

    Object.assign(
      NodePath.prototype,
      NodePath_ancestry,
      NodePath_inference,
      NodePath_replacement,
      NodePath_evaluation,
      NodePath_conversion,
      NodePath_introspection,
      NodePath_context,
      NodePath_removal,
      NodePath_modification,
      NodePath_family,
      NodePath_comments,
    );

    for (const type of t.TYPES) {
      const typeKey = `is${type}`;
      const fn = t[typeKey];

      NodePath.prototype[typeKey] = function (opts) {
        return fn(this.node, opts);
      };

      NodePath.prototype[`assert${type}`] = function (opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError(`Expected node path of type ${type}`);
        }
      };
    }

    for (const type of Object.keys(virtualTypes$1)) {
      if (type[0] === '_') continue;
      if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);
      const virtualType = virtualTypes$1[type];

      NodePath.prototype[`is${type}`] = function (opts) {
        return virtualType.checkPath(this, opts);
      };
    }

    var _default = NodePath;
    exports.default = _default;
  });

  var context = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    var _path = _interopRequireDefault(path);

    var t = _interopRequireWildcard(lib$2);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    const testing = browser$1.env.NODE_ENV === 'test';

    class TraversalContext {
      constructor(scope, opts, state, parentPath) {
        this.queue = null;
        this.priorityQueue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }

      shouldVisit(node) {
        const opts = this.opts;
        if (opts.enter || opts.exit) return true;
        if (opts[node.type]) return true;
        const keys = t.VISITOR_KEYS[node.type];
        if (!(keys != null && keys.length)) return false;

        for (const key of keys) {
          if (node[key]) return true;
        }

        return false;
      }

      create(node, obj, key, listKey) {
        return _path.default.get({
          parentPath: this.parentPath,
          parent: node,
          container: obj,
          key: key,
          listKey,
        });
      }

      maybeQueue(path, notPriority) {
        if (this.trap) {
          throw new Error('Infinite cycle detected');
        }

        if (this.queue) {
          if (notPriority) {
            this.queue.push(path);
          } else {
            this.priorityQueue.push(path);
          }
        }
      }

      visitMultiple(container, parent, listKey) {
        if (container.length === 0) return false;
        const queue = [];

        for (let key = 0; key < container.length; key++) {
          const node = container[key];

          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key, listKey));
          }
        }

        return this.visitQueue(queue);
      }

      visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      }

      visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        const visited = new WeakSet();
        let stop = false;

        for (const path of queue) {
          path.resync();

          if (
            path.contexts.length === 0 ||
            path.contexts[path.contexts.length - 1] !== this
          ) {
            path.pushContext(this);
          }

          if (path.key === null) continue;

          if (testing && queue.length >= 10000) {
            this.trap = true;
          }

          const {node} = path;
          if (visited.has(node)) continue;
          if (node) visited.add(node);

          if (path.visit()) {
            stop = true;
            break;
          }

          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) break;
          }
        }

        for (const path of queue) {
          path.popContext();
        }

        this.queue = null;
        return stop;
      }

      visit(node, key) {
        const nodes = node[key];
        if (!nodes) return false;

        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      }
    }

    exports.default = TraversalContext;
  });

  var explode_1 = explode;
  var verify_1 = verify;
  var merge_1$1 = merge$1;

  var virtualTypes$1 = _interopRequireWildcard$p(virtualTypes);

  var t$f = _interopRequireWildcard$p(lib$2);

  function _getRequireWildcardCache$p() {
    if (typeof WeakMap !== 'function') return null;
    var cache = new WeakMap();

    _getRequireWildcardCache$p = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard$p(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (
      obj === null ||
      (typeof obj !== 'object' && typeof obj !== 'function')
    ) {
      return {
        default: obj,
      };
    }

    var cache = _getRequireWildcardCache$p();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor =
      Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function explode(visitor) {
    if (visitor._exploded) return visitor;
    visitor._exploded = true;

    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const parts = nodeType.split('|');
      if (parts.length === 1) continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];

      for (const part of parts) {
        visitor[part] = fns;
      }
    }

    verify(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);

    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const wrapper = virtualTypes$1[nodeType];
      if (!wrapper) continue;
      const fns = visitor[nodeType];

      for (const type of Object.keys(fns)) {
        fns[type] = wrapCheck(wrapper, fns[type]);
      }

      delete visitor[nodeType];

      if (wrapper.types) {
        for (const type of wrapper.types) {
          if (visitor[type]) {
            mergePair(visitor[type], fns);
          } else {
            visitor[type] = fns;
          }
        }
      } else {
        mergePair(visitor, fns);
      }
    }

    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const fns = visitor[nodeType];
      let aliases = t$f.FLIPPED_ALIAS_KEYS[nodeType];
      const deprecatedKey = t$f.DEPRECATED_KEYS[nodeType];

      if (deprecatedKey) {
        console.trace(
          `Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`,
        );
        aliases = [deprecatedKey];
      }

      if (!aliases) continue;
      delete visitor[nodeType];

      for (const alias of aliases) {
        const existing = visitor[alias];

        if (existing) {
          mergePair(existing, fns);
        } else {
          visitor[alias] = Object.assign({}, fns);
        }
      }
    }

    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      ensureCallbackArrays(visitor[nodeType]);
    }

    return visitor;
  }

  function verify(visitor) {
    if (visitor._verified) return;

    if (typeof visitor === 'function') {
      throw new Error(
        'You passed `traverse()` a function when it expected a visitor object, ' +
          "are you sure you didn't mean `{ enter: Function }`?",
      );
    }

    for (const nodeType of Object.keys(visitor)) {
      if (nodeType === 'enter' || nodeType === 'exit') {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }

      if (shouldIgnoreKey(nodeType)) continue;

      if (t$f.TYPES.indexOf(nodeType) < 0) {
        throw new Error(
          `You gave us a visitor for the node type ${nodeType} but it's not a valid type`,
        );
      }

      const visitors = visitor[nodeType];

      if (typeof visitors === 'object') {
        for (const visitorKey of Object.keys(visitors)) {
          if (visitorKey === 'enter' || visitorKey === 'exit') {
            validateVisitorMethods(
              `${nodeType}.${visitorKey}`,
              visitors[visitorKey],
            );
          } else {
            throw new Error(
              'You passed `traverse()` a visitor object with the property ' +
                `${nodeType} that has the invalid property ${visitorKey}`,
            );
          }
        }
      }
    }

    visitor._verified = true;
  }

  function validateVisitorMethods(path, val) {
    const fns = [].concat(val);

    for (const fn of fns) {
      if (typeof fn !== 'function') {
        throw new TypeError(
          `Non-function found defined in ${path} with type ${typeof fn}`,
        );
      }
    }
  }

  function merge$1(visitors, states = [], wrapper) {
    const rootVisitor = {};

    for (let i = 0; i < visitors.length; i++) {
      const visitor = visitors[i];
      const state = states[i];
      explode(visitor);

      for (const type of Object.keys(visitor)) {
        let visitorType = visitor[type];

        if (state || wrapper) {
          visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
        }

        const nodeVisitor = (rootVisitor[type] = rootVisitor[type] || {});
        mergePair(nodeVisitor, visitorType);
      }
    }

    return rootVisitor;
  }

  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    const newVisitor = {};

    for (const key of Object.keys(oldVisitor)) {
      let fns = oldVisitor[key];
      if (!Array.isArray(fns)) continue;
      fns = fns.map(function (fn) {
        let newFn = fn;

        if (state) {
          newFn = function (path) {
            return fn.call(state, path, state);
          };
        }

        if (wrapper) {
          newFn = wrapper(state.key, key, newFn);
        }

        if (newFn !== fn) {
          newFn.toString = () => fn.toString();
        }

        return newFn;
      });
      newVisitor[key] = fns;
    }

    return newVisitor;
  }

  function ensureEntranceObjects(obj) {
    for (const key of Object.keys(obj)) {
      if (shouldIgnoreKey(key)) continue;
      const fns = obj[key];

      if (typeof fns === 'function') {
        obj[key] = {
          enter: fns,
        };
      }
    }
  }

  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }

  function wrapCheck(wrapper, fn) {
    const newFn = function (path) {
      if (wrapper.checkPath(path)) {
        return fn.apply(this, arguments);
      }
    };

    newFn.toString = () => fn.toString();

    return newFn;
  }

  function shouldIgnoreKey(key) {
    if (key[0] === '_') return true;
    if (key === 'enter' || key === 'exit' || key === 'shouldSkip') return true;

    if (
      key === 'denylist' ||
      key === 'noScope' ||
      key === 'skipKeys' ||
      key === 'blacklist'
    ) {
      return true;
    }

    return false;
  }

  function mergePair(dest, src) {
    for (const key of Object.keys(src)) {
      dest[key] = [].concat(dest[key] || [], src[key]);
    }
  }

  var visitors = /*#__PURE__*/ Object.defineProperty(
    {
      explode: explode_1,
      verify: verify_1,
      merge: merge_1$1,
    },
    '__esModule',
    {
      value: true,
    },
  );

  var hub = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    exports.default = void 0;

    class Hub {
      getCode() {}

      getScope() {}

      addHelper() {
        throw new Error('Helpers are not supported by the default hub.');
      }

      buildError(node, msg, Error = TypeError) {
        return new Error(msg);
      }
    }

    exports.default = Hub;
  });

  var lib$a = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true,
    });
    Object.defineProperty(exports, 'NodePath', {
      enumerable: true,
      get: function () {
        return _path.default;
      },
    });
    Object.defineProperty(exports, 'Scope', {
      enumerable: true,
      get: function () {
        return _scope.default;
      },
    });
    Object.defineProperty(exports, 'Hub', {
      enumerable: true,
      get: function () {
        return _hub.default;
      },
    });
    exports.visitors = exports.default = void 0;

    var _context = _interopRequireDefault(context);

    var visitors$1 = _interopRequireWildcard(visitors);

    exports.visitors = visitors$1;

    var t = _interopRequireWildcard(lib$2);

    var cache$1 = _interopRequireWildcard(cache);

    var _path = _interopRequireDefault(path);

    var _scope = _interopRequireDefault(scope);

    var _hub = _interopRequireDefault(hub);

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== 'function') return null;
      var cache = new WeakMap();

      _getRequireWildcardCache = function () {
        return cache;
      };

      return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }

      if (
        obj === null ||
        (typeof obj !== 'object' && typeof obj !== 'function')
      ) {
        return {
          default: obj,
        };
      }

      var cache = _getRequireWildcardCache();

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor =
        Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor
            ? Object.getOwnPropertyDescriptor(obj, key)
            : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj.default = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule
        ? obj
        : {
            default: obj,
          };
    }

    function traverse(parent, opts = {}, scope, state, parentPath) {
      if (!parent) return;

      if (!opts.noScope && !scope) {
        if (parent.type !== 'Program' && parent.type !== 'File') {
          throw new Error(
            'You must pass a scope and parentPath unless traversing a Program/File. ' +
              `Instead of that you tried to traverse a ${parent.type} node without ` +
              'passing scope and parentPath.',
          );
        }
      }

      if (!t.VISITOR_KEYS[parent.type]) {
        return;
      }

      visitors$1.explode(opts);
      traverse.node(parent, opts, scope, state, parentPath);
    }

    var _default = traverse;
    exports.default = _default;
    traverse.visitors = visitors$1;
    traverse.verify = visitors$1.verify;
    traverse.explode = visitors$1.explode;

    traverse.cheap = function (node, enter) {
      return t.traverseFast(node, enter);
    };

    traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
      const keys = t.VISITOR_KEYS[node.type];
      if (!keys) return;
      const context = new _context.default(scope, opts, state, parentPath);

      for (const key of keys) {
        if (skipKeys && skipKeys[key]) continue;
        if (context.visit(node, key)) return;
      }
    };

    traverse.clearNode = function (node, opts) {
      t.removeProperties(node, opts);
      cache$1.path.delete(node);
    };

    traverse.removeProperties = function (tree, opts) {
      t.traverseFast(tree, traverse.clearNode, opts);
      return tree;
    };

    function hasDenylistedType(path, state) {
      if (path.node.type === state.type) {
        state.has = true;
        path.stop();
      }
    }

    traverse.hasType = function (tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type))
        return false;
      if (tree.type === type) return true;
      const state = {
        has: false,
        type: type,
      };
      traverse(
        tree,
        {
          noScope: true,
          denylist: denylistTypes,
          enter: hasDenylistedType,
        },
        null,
        state,
      );
      return state.has;
    };

    traverse.cache = cache$1;
  });
  var traverse$1 = /*@__PURE__*/ getDefaultExportFromCjs(lib$a);

  var MMRecord =
    /** @class */
    (function () {
      function MMRecord(source) {
        this.source = source;
        this.varDeclares = {};
        this.breadcrumbs = [];
        this.pileCode();
        this.beginDate = Date.now();
      }
      /**
       * 保存一个变量信息;
       * @param varNodePath
       * @param varDeclareInfo
       */

      MMRecord.prototype.saveVarInfo = function (varNodePath, varDeclareInfo) {
        debugger
        if (this.varDeclares[varNodePath]) {
          if (varDeclareInfo instanceof Array) {
            this.varDeclares[varNodePath] = this.varDeclares[
              varNodePath
            ].concat(varDeclareInfo);
          } else {
            this.varDeclares[varNodePath].push(varDeclareInfo);
          }
        } else {
          if (varDeclareInfo instanceof Array) {
            this.varDeclares[varNodePath] = varDeclareInfo;
          } else {
            this.varDeclares[varNodePath] = [varDeclareInfo];
          }
        }
      };
      /**
       * 保存面包屑
       * @param value     验证下值 是不是基本类型的. 或数组中包含基本类型的.
       * @param breadcumbs
       */

      MMRecord.prototype.saveAssignBreadcrumbs = function (value, breadcumbs) {
        // debugger;
          this.breadcrumbs.push({
          type: 'assign',
          dateStamp: Date.now() - this.beginDate,
          relValue: value,
          breadcumbs: breadcumbs,
        });
        return value;
      };
      /**
       * 对原始js代码进行打桩处理;
       *
       *  接下来的逻辑中必须进行的操作;
       *
       */

      MMRecord.prototype.pileCode = function () {
        debugger
        var ast = parse_1(this.source);

        var _this = this;

        traverse$1(ast, {
          VariableDeclaration: {
            exit: function (path) {
              debugger;
              //@ts-ignore
              _this.saveVarInfo(
                getLatestBlock(path).getPathLocation(),
                path.node.declarations.map(function (item) {
                  return extraVarInfo(item, _this.source);
                }),
              ); // TODO dong 2021/4/29 初始记录应该也用面包屑记录下来
              //@ts-ignore
              // console.log(`声明变量:${ path.node.declarations.map(item=>item.id['name']).join(",")} in ${path.parentPath.getPathLocation()}`)
            },
          },
          AssignmentExpression: function (path) {
            debugger
            if (
              path.node.operator == '=' &&
              path.node.left.type === 'Identifier'
            ) {
              var varDeclareNodePath = getVarDeclareNodePath(
                path,
                path.node.left.name,
              );

              if (varDeclareNodePath) {
                var content = path.toString();

                if (!content.includes('__MMRecord')) {
                  var flag = content.indexOf('=');
                  var result = [
                    content.substring(0, flag),
                    content.substring(flag + 1),
                  ];
                  path.replaceWithSourceString(
                    result[0] +
                      '= (__MMRecord?__MMRecord.saveAssignBreadcrumbs(' +
                      result[1] +
                      ',{\n            type:"AssignmentExpression",\n            currentPath:"' +
                      path.getPathLocation() +
                      '",\n            refVarPath:"' +
                      varDeclareNodePath.getPathLocation() +
                      '",\n            varName:"' +
                      path.node.left.name +
                      '"\n            }):' +
                      result[1] +
                      ')',
                  );
                }
              }
            }
          }, // BlockStatement: {
          //   enter(path, param2) {
          //     // console.log('Entered!');
          //     // path.toString();
          //     // path.scope.bindings
          //     // debugger;
          //   },
          //   exit(path, param2) {
          //     // console.log('Exited!');
          //     // debugger;
          //   },
          // },
          // Function(path) {
          //   // debugger;
          // },
          // enter(path) {
          //   if (path.isIdentifier({ name: "n" })) {
          //     path.node.name = "x";
          //   }
          // },
        });
        var output = generate(ast, {
          /* options */
        });
        this.decorateCode = output;
        return output;
      };
      /**
       * 第二步,执行优化, 把隐藏的值都直接放到对应位置上;
       */

      MMRecord.prototype.optimizedCode = function () {
        //根据记录转化;
        //1. 寻找初始值为null或[]只有一次赋值的记录;
        var varMap = {};

        var _loop_1 = function (varMapKey) {
          this_1.varDeclares[varMapKey].forEach(function (vardecItem) {
            vardecItem.blockPath = varMapKey;
            varMap[varMapKey + '::' + vardecItem.varStr] = vardecItem;
          });
        };

        var this_1 = this;

        for (var varMapKey in this.varDeclares) {
          _loop_1(varMapKey);
        }

        var result = breadCrumbsOrg(this.breadcrumbs); //有效的将要修改的值内容 ;

        var toChangeVar = {},
          toDealBlocks = [];

        for (var resultKey in result) {
          var item = result[resultKey];

          if (item.length === 1 && varMap[resultKey]) {
            var varDec = varMap[resultKey];
            toDealBlocks.push(varDec.blockPath);
            toChangeVar[resultKey] = {
              blockPath: varDec.blockPath,
              varName: varDec.varStr,
              varDeclare: varDec,
              breadCrumbs: item[0],
            };
          }
        } // debugger;
        // TODO dong 2021/4/29 parse 两次, 生成同样 的ast可以简化;

        var ast = parse_1(this.source); //

        traverse$1(ast, {
          VariableDeclarator: {
            enter: function (path) {
              // debugger;
              var lastBlock = getLatestBlock(path);

              if (
                lastBlock &&
                toDealBlocks.includes(lastBlock.getPathLocation())
              ) {
                // debugger; @ts-ignore
                var changeInfo =
                  toChangeVar[
                    lastBlock.getPathLocation() + '::' + path.node.id.name
                  ]; //@ts-ignore

                if (
                  changeInfo &&
                  changeInfo.varDeclare &&
                  changeInfo.varDeclare.initVal&&
                  changeInfo.varDeclare.initVal.type === 'ArrayExpression' &&
                  changeInfo.varDeclare.initVal.valueStr === '[]'
                ) {
                  path.replaceWithSourceString(
                    path
                      .toString()
                      .replace(
                        '[]',
                        JSON.stringify(changeInfo.breadCrumbs.relValue),
                      ),
                  );
                }
              } // toChangeVar[getLatestBlock(path).getPathLocation()]
              //@ts-ignore
              // _this.saveVarInfo(getLatestBlock(path).getPathLocation(), path.node.declarations.map(item => extraVarInfo(item, _this.source)));
              // TODO dong 2021/4/29 初始记录应该也用面包屑记录下来
              //@ts-ignore
              // console.log(`声明变量:${ path.node.declarations.map(item=>item.id['name']).join(",")} in ${path.parentPath.getPathLocation()}`)
            },
          },
          MemberExpression: {
            enter: function (path) {
              var _a; //@ts-ignore

              var varName =
                (_a = path.node.object) === null || _a === void 0
                  ? void 0
                  : _a.name; // if(varName==='a'){
              //   // debugger;
              // }

              var varDecNode = getVarDeclareNodePath(path, varName);
              var keyPath =
                (varDecNode === null || varDecNode === void 0
                  ? void 0
                  : varDecNode.getPathLocation()) +
                '::' +
                varName; // debugger;

              if (toChangeVar[keyPath]) {
                var changeInfo = toChangeVar[keyPath]; // path.toString()
                // changeInfo[]

                if (path.node.property.type === 'NumericLiteral') {
                  var value =
                    changeInfo.breadCrumbs.relValue[path.node.property.value];

                  if (value != undefined) {
                      if(typeof value ==='string'){
                          path.replaceWithSourceString(`\`${value}\``);
                      }else if(typeof value ==='number'){
                          path.replaceWithSourceString(value);
                      }else{
                          console.warn('暂未处理类型',value);
                      }
                  }
                }

                // debugger;
              } // path.getPathLocation()
              //@ts-ignore
              // info.saveVarInfo(path.getPathLocation(),path.node.declarations.map(item=>extraVarInfo(item,jsCode)));
              // TODO dong 2021/4/29 初始记录应该也用面包屑记录下来
              //@ts-ignore
              // console.log(`声明变量:${ path.node.declarations.map(item=>item.id['name']).join(",")} in ${path.parentPath.getPathLocation()}`)
            },
          },
        });
        var output = generate(ast, {
          /* options */
        }); //@ts-ignore

        this.finalCode = output;
        return output; //2.
      };

      return MMRecord;
    })();
  /**
   * 根据引用变量 来进行分组,
   *    组内值数量代表,共进行了多少轮赋值;
   * @param breadCrumbs
   */

  function breadCrumbsOrg(breadCrumbs) {
    // let result = {};
    // breadCrumbs.forEach(item=>{
    //   let key = item.breadcumbs.refVarPath+item.breadcumbs.varName;
    //
    // })
    return breadCrumbs.reduce(function (acc, item) {
      var key = item.breadcumbs.refVarPath + '::' + item.breadcumbs.varName;

      if (!acc[key]) {
        acc[key] = [];
      }

      acc[key].push(item);
      return acc;
    }, {});
  }
  /**
   * 提取声明信息
   * @param declas
   */

  function extraVarInfo(declara, originJSCode) {
    var _a, _b, _c, _d, _e, _f;

    var initVal;

    if (!declara.init);
    else if (
      ((_a = declara.init) === null || _a === void 0 ? void 0 : _a.type) ===
      'NullLiteral'
    ) {
      initVal = {
        type: 'NullLiteral',
      };
    } else if (
      ((_b = declara.init) === null || _b === void 0 ? void 0 : _b.type) ===
      'NumericLiteral'
    ) {
      initVal = {
        type: 'NumericLiteral',
        value: declara.init.value,
      };
    } else if (
      ((_c = declara.init) === null || _c === void 0 ? void 0 : _c.type) ===
      'BooleanLiteral'
    ) {
      initVal = {
        type: 'BooleanLiteral',
        value: declara.init.value,
      };
    } else if (
      ((_d = declara.init) === null || _d === void 0 ? void 0 : _d.type) ===
      'ArrowFunctionExpression'
    ) {
      initVal = {
        type: 'ArrowFunctionExpression',
      };
    } else if (
      ((_e = declara.init) === null || _e === void 0 ? void 0 : _e.type) ===
      'ObjectExpression'
    ) {
      initVal = {
        type: 'ObjectExpression',
        //@ts-ignore
        valueStr: originJSCode.substring(declara.init.start, declara.init.end),
      };
    } else if (
      ((_f = declara.init) === null || _f === void 0 ? void 0 : _f.type) ===
      'ArrayExpression'
    ) {
      initVal = {
        type: 'ArrayExpression',
        elementsCount: declara.init.elements.length,
        //@ts-ignore
        valueStr: originJSCode.substring(declara.init.start, declara.init.end),
      };
    }

    return {
      //@ts-ignore
      varStr: declara.id['name'],
      initVal: initVal,
    };
  }
  /**
   * @desc
   *
   * @使用场景
   *
   * @coder.yang2010@gmail.com
   * @Date    2021/4/29
   **/

  /**
   * 向上寻找变量定义的地方;
   * @param nodePath
   * @param varName
   */

  function getVarDeclareNodePath(nodePath, varName) {
    var current = nodePath; // path.parentPath.scope.bindings

    do {
      if (
        current.type === 'BlockStatement' &&
        current.scope.bindings[varName]
      ) {
        return current;
      } else {
        current = current.parentPath;
      }
    } while (current);

    return null;
  }
  /**
   * 向上寻找block地方;
   * @param nodePath
   * @param varName
   */

  function getLatestBlock(nodePath) {
    var current = nodePath; // path.parentPath.scope.bindings

    do {
      if (current.type === 'BlockStatement') {
        return current;
      } else {
        current = current.parentPath;
      }
    } while (current);

    return null;
  } // TODO dong 2021/4/27 添加一个方法通过路径寻找 nodePath
  // program.body[0].expression.callee.body.body[106]

  /**
   * @desc
   *
   * @使用场景
   *
   * @coder.yang2010@gmail.com
   * @Date    2021/4/27
   **/
  /**
   * 步骤1: 打桩,
   *
   * 赋值的地方添加桩.
   *  方法调用的地方 添加桩.
   *  直接赋值的地方;
   *
   *   记录内容: 1.时间 2. 执行步骤;
   *
   *
   * @param jsCode
   */

  function magicMirror(jsCode) {
    var mmRecord = new MMRecord(jsCode);

    try {
      //@ts-ignore
      window['__MMRecord'] = mmRecord;
    } catch (err) {}

    try {
      //@ts-ignore
      global['__MMRecord'] = mmRecord;
    } catch (err) {}

    return mmRecord;
  }

  try {
    //@ts-ignore
    // window['__MMRecord'] = info;
    window['__magicMirror'] = magicMirror;
    console.log(
      '\u8C03\u7528__magicMirror(\'console.log("hello")\') \u5904\u7406\u4EE3\u7801, \u7136\u540E\u8FD0\u884C',
    );
  } catch (err) {}

  try {
    //@ts-ignore
    global['__magicMirror'] = magicMirror;
    console.log(
      '\u8C03\u7528__magicMirror(\'console.log("hello")\') \u5904\u7406\u4EE3\u7801, \u7136\u540E\u8FD0\u884C',
    );
  } catch (err) {}

  exports.magicMirror = magicMirror;

  Object.defineProperty(exports, '__esModule', {value: true});

  return exports;
})({});
